if not game or not game.GetService then
    warn("Ambiente do jogo não está disponível.")
    return
end
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local teleportEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local selectedMobName = ""
local movementMethod = "Tween" -- Método de movimento padrão
local farmingStyle = "Default" -- Estilo de farm padrão

-- Novo sistema de armazenamento
local ConfigSystem = {}
local HttpService = game:GetService("HttpService")
ConfigSystem.Folder = "Allan Hub"
ConfigSystem.SubFolder = "AriseCrossover"
ConfigSystem.FileName = player.Name .. "_Config.json"
ConfigSystem.FilePath = ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder .. "/" .. ConfigSystem.FileName
ConfigSystem.DefaultConfig = {
    SelectedMobName = "",
    FarmSelectedMob = false,
    AutoFarmNearestNPCs = false,
    MainAutoDestroy = false,
    MainAutoArise = false,
    FarmingMethod = "Tween",
    DamageMobs = false,
    SelectedShop = "",
    SelectedWeapon = "",
    AutoBuyEnabled = false,
    AutoScanEnabled = false,
    ScanDelay = 1,
    SelectedRanks = {},
    AutoSellEnabled = false
}
ConfigSystem.CurrentConfig = {}

-- Função para criar pastas se não existirem
ConfigSystem.CreateFolders = function()
    -- Testar diferentes métodos para criar pasta em vários executores
    local success = pcall(function()
        if makefolder then
            if not isfolder(ConfigSystem.Folder) then
                makefolder(ConfigSystem.Folder)
            end
            
            if not isfolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder) then
                makefolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder)
            end
        end
    end)
    
    return success
end

-- Função para salvar configuração (thử nhiều phương thức)
ConfigSystem.SaveConfig = function()
    -- Garantir que a pasta existe
    ConfigSystem.CreateFolders()
    
    -- Mã hóa cấu hình thành chuỗi JSON
    local jsonData = HttpService:JSONEncode(ConfigSystem.CurrentConfig)
    
    -- Testar diferentes métodos de salvar
    local success, err = pcall(function()
        -- Método 1: writefile trực tiếp (Synapse X, KRNL, Script-Ware)
        if writefile then
            writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 2: Usar SaveInstance (alguns outros executores)
        if saveinstance then
            saveinstance(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 3: Fluxus và alguns outros executores
        if fluxus and fluxus.save_file then
            fluxus.save_file(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 4: Delta và alguns outros executores
        if delta_config and delta_config.save then
            delta_config.save(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 5: Codex
        if writefile and getrenv().writefile then
            getrenv().writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        return false
    end)
    
    if success then
        print("Configuração salva com sucesso em: " .. ConfigSystem.FilePath)
        return true
    else
        warn("Falha ao salvar configuração:", err)
        return false
    end
end

-- Função para carregar configuração (thử nhiều phương thức)
ConfigSystem.LoadConfig = function()
    -- Thử các phương thức đọc khác nhau
    local success, content = pcall(function()
        -- Método 1: readfile padrão (Synapse X, KRNL, Script-Ware)
        if readfile and isfile and isfile(ConfigSystem.FilePath) then
            return readfile(ConfigSystem.FilePath)
        end
        
        -- Método 2: Fluxus
        if fluxus and fluxus.read_file and fluxus.file_exists and fluxus.file_exists(ConfigSystem.FilePath) then
            return fluxus.read_file(ConfigSystem.FilePath)
        end
        
        -- Método 3: Delta
        if delta_config and delta_config.load and delta_config.exists and delta_config.exists(ConfigSystem.FilePath) then
            return delta_config.load(ConfigSystem.FilePath)
        end
        
        -- Método 4: Codex
        if readfile and getrenv().readfile and isfile and getrenv().isfile and getrenv().isfile(ConfigSystem.FilePath) then
            return getrenv().readfile(ConfigSystem.FilePath)
        end
        
        return nil
    end)
    
    if success and content then
        local data
        success, data = pcall(function()
            return HttpService:JSONDecode(content)
        end)
        
        if success and data then
        ConfigSystem.CurrentConfig = data
            print("Configuração carregada de: " .. ConfigSystem.FilePath)
        return true
    else
            warn("Erro ao analisar configuração, criando nova.")
        end
    end
    
    -- Se não conseguir ler ou ocorrer erro, criar configuração padrão
        ConfigSystem.CurrentConfig = table.clone(ConfigSystem.DefaultConfig)
        ConfigSystem.SaveConfig()
    print("Inicializando nova configuração")
        return false
    end

-- Criar um sistema de auto save separado
local function setupAutoSave()
    spawn(function()
        while wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                ConfigSystem.SaveConfig()
            end)
        end
    end)
end

-- Carregar configuração ao iniciar
ConfigSystem.LoadConfig()
setupAutoSave() -- Iniciando salvamento automático

-- Atualizar função para salvar imediatamente ao alterar valor
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then
            for _, element in pairs(tab._components) do
                if element and element.OnChanged then
                    element.OnChanged:Connect(function()
                        pcall(function()
                            ConfigSystem.SaveConfig()
                        end)
                    end)
                end
            end
        end
    end
end

-- Configurar SaveManager do Fluent para compatibilidade
local playerName = game:GetService("Players").LocalPlayer.Name
if InterfaceManager then
    InterfaceManager:SetFolder("Allan Hub")
end
if SaveManager then
    SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)
end

-- Detectar automaticamente novo HumanoidRootPart quando o jogador renascer
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
end)

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end

            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function getNearestSelectedEnemy()
    -- Se nenhum inimigo for encontrado em 5 segundos, atualizar lista
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 5 then
        killedNPCs = {} -- Redefinir lista de inimigos mortos
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time() -- Atualizar hora em que o inimigo foi encontrado
    end
    
    return nearestEnemy
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] then
            return enemy
        end
    end
    return nil
end

local function fireShowPetsRemote()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    remote:FireServer(unpack(args))
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
    elseif movementMethod == "Walk" then
        hrp.Parent:MoveTo(enemyHrp.Position)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.2)
    end
end

local function teleportDungeon()
    while teleportEnabled do
        local function getDistance(pos1, pos2)
            return (pos1 - pos2).Magnitude
        end

        local function getClosestEnemy()
            local closestEnemy = nil
            local closestDistance = math.huge
            local playerPosition = hrp.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local distance = getDistance(playerPosition, enemy.HumanoidRootPart.Position)
                    if distance < closestDistance then
                        closestDistance = distance
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            if enemy and enemy:FindFirstChild("HumanoidRootPart") then
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(hrp, tweenInfo, {
                    CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
                })
                tween:Play()
                tween.Completed:Wait()
            end
        end

        local enemy = getClosestEnemy()
        if enemy then
            moveToEnemy(enemy)
            while teleportEnabled and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 do
                task.wait(0.3)
            end
        else
            task.wait(1)
        end
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = getNearestSelectedEnemy()
        
        -- Se não encontrar alvo em 3 segundos, atualizar lista
        if not target and os.time() - lastResetTime > 3 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Lista de inimigos mortos foi atualizada")
        end
        
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()

            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.20)
    end
end

-- Farm Method Selection Dropdown
local Fluent
local SaveManager
local InterfaceManager

local success, err = pcall(function()
    Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
    SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
    InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
end)

if not success then
    warn("Erro ao carregar biblioteca Fluent: " .. tostring(err))
    -- Thử tải từ URL dự phòng
    pcall(function()
        Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Fluent.lua"))()
        SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
        InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
    end)
end

if not Fluent then
    error("Não foi possível carregar a biblioteca Fluent. Verifique sua conexão com a internet ou executor.")
    return
end

local Window = Fluent:CreateWindow({
    Title = "Allan Hub | Arise Crossover",
    SubTitle = "",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 350),
    Acrylic = false,
    Theme = "Luffy",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = {
    Discord = Window:AddTab({ Title = "INFO", Icon = ""}),
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    tp = Window:AddTab({ Title = "Teleports", Icon = "" }),
    mount = Window:AddTab({ Title = "Mount Location/farm", Icon = "" }),
    dungeon = Window:AddTab({ Title = "Dungeon ", Icon = "" }),
    shop = Window:AddTab({ Title = "Shop", Icon = "" }),
    Player = Window:AddTab({ Title = "Player", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" }),
}


-- Tạo mapping giữa các map và danh sách mob tương ứng
local mobsByWorld = {
    ["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
    ["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
    ["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
    ["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
    ["BCWorld"] = {"Sortudo", "Michille", "Wind"},
    ["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
    ["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
    ["DBWorld"] = {"Turtle", "Green", "Sky"},
    ["OPMWorld"] = {"Rider", "Cryborg", "Hurricane"}
}

local selectedWorld = "SoloWorld" -- Default world

-- Dropdown để chọn World/Map
Tabs.Main:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Values = {"SoloWorld", "NarutoWorld", "OPWorld", "BleachWorld", "BCWorld", "ChainsawWorld", "JojoWorld", "DBWorld", "OPMWorld"},
    Multi = false,
    Default = selectedWorld,
    Callback = function(world)
        selectedWorld = world
        ConfigSystem.CurrentConfig.SelectedWorld = world
        
        -- Cập nhật danh sách mob dựa trên world được chọn
        local mobDropdown = Fluent.Options.WorldMobDropdown
        if mobDropdown then
            mobDropdown:SetValues(mobsByWorld[world] or {})
            -- Đặt giá trị mặc định nếu có mob
            if #mobsByWorld[world] > 0 then
                selectedMobName = mobsByWorld[world][1]
                mobDropdown:SetValue(selectedMobName)
                ConfigSystem.CurrentConfig.SelectedMobName = selectedMobName
            else
                selectedMobName = ""
            end
        end
        
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de world
    end
})

-- Dropdown để chọn Mob trong world đã chọn
Tabs.Main:AddDropdown("WorldMobDropdown", {
    Title = "Select Enemy",
    Values = mobsByWorld[selectedWorld] or {},
    Multi = false,
    Default = mobsByWorld[selectedWorld] and mobsByWorld[selectedWorld][1] or "",
    Callback = function(mob)
        selectedMobName = mob
        ConfigSystem.CurrentConfig.SelectedMobName = mob
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de mob
        print("Selected Mob:", selectedMobName) -- Debug
    end
})

Tabs.Main:AddToggle("FarmSelectedMob", {
    Title = "Farm Selected Mob",
    Default = ConfigSystem.CurrentConfig.FarmSelectedMob or false,
    Callback = function(state)
        teleportEnabled = state
        damageEnabled = state -- Đảm bảo tính năng tấn công mobs được kích hoạt
        ConfigSystem.CurrentConfig.FarmSelectedMob = state
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao iniciar farm
        if state then
            task.spawn(teleportToSelectedEnemy)
        end
    end
})

Tabs.Main:AddToggle("TeleportMobs", {
    Title = "Auto farm (nearest NPCs)",
    Default = ConfigSystem.CurrentConfig.AutoFarmNearestNPCs or false,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmNearestNPCs = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(teleportAndTrackDeath)
        end
    end
})

local Dropdown = Tabs.Main:AddDropdown("MovementMethod", {
    Title = "Farming Method",
    Values = {"Tween", "Teleport"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.FarmingMethod == "Teleport" and 2 or 1,
    Callback = function(option)
        movementMethod = option
        ConfigSystem.CurrentConfig.FarmingMethod = option
        ConfigSystem.SaveConfig()
    end 
})

Tabs.Main:AddToggle("GamepassShadowFarm", {
    Title = "Shadow farm",
    Default = false,
    Callback = function(state)
        local attackatri = game:GetService("Players").LocalPlayer.Settings
        local atri = attackatri:GetAttribute("AutoAttack")
        
        if state then
            -- Bật tính năng
            if atri == false then
                attackatri:SetAttribute("AutoAttack", true)
            end
            print("Shadow farm ativado")
        else
            -- Tắt tính năng
            attackatri:SetAttribute("AutoAttack", false)
            print("Shadow farm desativado")
        end
    end
})

-- Adicionar toggle de Auto Attack
local autoAttackEnabled = false
local attackCooldown = 0.5

Tabs.Main:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack Mobs",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        
        if state then
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Ativado ataque automático a mobs",
                Duration = 3
            })
            
            -- Bắt đầu vòng lặp auto attack
            task.spawn(function()
                while autoAttackEnabled do
                    local targetEnemy
                    
                    -- Kiểm tra xem Farm Selected Mob có đang bật không
                    if ConfigSystem.CurrentConfig.FarmSelectedMob and selectedMobName ~= "" then
                        -- Nếu đang farm mob đã chọn, tìm mob đó
                        targetEnemy = getNearestSelectedEnemy()
                    else
                        -- Nếu không, tìm bất kỳ mob nào gần nhất
                        targetEnemy = getNearestEnemy()
                    end
                    
                    if targetEnemy then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "PunchAttack",
                                    ["Enemy"] = targetEnemy.Name
                                },
                                [2] = "\4"
                            }
                        }
                        remote:FireServer(unpack(args))
                    end
                    task.wait(attackCooldown) -- Chờ giữa các lần tấn công
                end
            end)
        else
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Desativado ataque automático a mobs",
                Duration = 3
            })
        end
    end
})

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tùy chọn, để đảm bảo điểm hồi sinh được thiết lập)
    task.wait(0.5)

    -- Hồi sinh nhân vật
    local player = game.Players.LocalPlayer
if player.Character and player.Character.Parent then
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0 -- Tạo ra cái chết tự nhiên mà không xóa nhân vật đột ngột
    end
end

end

local TweenService = game:GetService("TweenService")

-- Lấy Player và HumanoidRootPart
local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Cập nhật HRP khi nhân vật hồi sinh
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart") -- Lấy HRP mới sau khi hồi sinh
end)

-- Hàm di chuyển (Luôn sử dụng HRP mới nhất)
local function teleportWithTween(targetCFrame)
    if hrp then
        local tweenInfo = TweenInfo.new(
            2, -- Thời gian (giây)
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.Out,
            0, -- Không lặp lại
            false, -- Không đảo ngược
            0 -- Không độ trễ
        )

        local tweenGoal = {CFrame = targetCFrame}
        local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
        tween:Play()
    end
end


-- Locations List
local locations = {
    {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668, -0.41691944, -8.07482721e-08, 0.908943415, -2.94452178e-07, 1, -4.62235228e-08, -0.908943415, -2.86911842e-07, -0.41691944)},
    {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379, 0.836233854, -7.47273816e-08, -0.548372984, 2.59595481e-07, 1, 2.59595481e-07, 0.548372984, -3.59437678e-07, 0.836233854)},
    {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244, 0.8239398, -3.60997859e-07, -0.566677332, 2.59595453e-07, 1, -2.59595396e-07, 0.566677332, 6.67841249e-08, 0.8239398)},
    {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646, 0.978662074, 0.000114096198, -0.205476329, -0.000112703143, 1, 1.84834444e-05, 0.205476329, 5.06878177e-06, 0.978662074)},
    {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292, -0.999887109, -1.20863996e-12, 0.0150266131, -1.12492459e-12, 1, 5.57959278e-12, -0.0150266131, 5.56205906e-12, -0.999887109)},
    {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113, -0.534268856, -4.75206689e-05, 0.845314622, -7.48304665e-05, 1, 8.92103617e-06, -0.845314622, -5.84890549e-05, -0.534268856)},
 -- Continuar o resto do código...
local localPlayer = game:GetService("Players").LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local playerHRP = playerCharacter:WaitForChild("HumanoidRootPart")
local enemyContainer = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local networkEvent = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local autoFarmActive = false
local defeatedEnemies = {}

local function isTargetDefeated(target)
    local healthUI = target:FindFirstChild("HealthBar")
    if healthUI and healthUI:FindFirstChild("Main") and healthUI.Main:FindFirstChild("Bar") then
        local healthText = healthUI.Main.Bar:FindFirstChild("Amount")
        if healthText and healthText:IsA("TextLabel") and healthText.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function findClosestTarget()
    local closestJJ2, closestJJ3, closestJJ4 = nil, nil, nil
    local distJJ2, distJJ3, distJJ4 = math.huge, math.huge, math.huge
    local playerPos = localPlayer.Character and localPlayer.Character:GetPivot().Position

    if not playerPos then return nil end

    for _, enemy in ipairs(enemyContainer:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local enemyType = enemy:GetAttribute("ID")
            
            -- Đảm bảo script bỏ qua các kẻ địch đã chết
            if not defeatedEnemies[enemy.Name] then
                local distance = (playerPos - enemy:GetPivot().Position).Magnitude
                
                if enemyType == "JJ2" and distance < distJJ2 then
                    distJJ2 = distance
                    closestJJ2 = enemy
                elseif enemyType == "JJ3" and distance < distJJ3 then
                    distJJ3 = distance
                    closestJJ3 = enemy
                elseif enemyType == "JJ4" and distance < distJJ4 then
                    distJJ4 = distance
                    closestJJ4 = enemy
                end
            end
        end
    end

    -- Ưu tiên: JJ2 > JJ3 > JJ4
    return closestJJ2 or closestJJ3 or closestJJ4
end

local function triggerPetVisibility()
    local arguments = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    gameif not game or not game.GetService then
    warn("Ambiente do jogo não está disponível.")
    return
end
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local teleportEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local selectedMobName = ""
local movementMethod = "Tween" -- Método de movimento padrão
local farmingStyle = "Default" -- Estilo de farm padrão

-- Novo sistema de armazenamento
local ConfigSystem = {}
local HttpService = game:GetService("HttpService")
ConfigSystem.Folder = "Allan Hub"
ConfigSystem.SubFolder = "AriseCrossover"
ConfigSystem.FileName = player.Name .. "_Config.json"
ConfigSystem.FilePath = ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder .. "/" .. ConfigSystem.FileName
ConfigSystem.DefaultConfig = {
    SelectedMobName = "",
    FarmSelectedMob = false,
    AutoFarmNearestNPCs = false,
    MainAutoDestroy = false,
    MainAutoArise = false,
    FarmingMethod = "Tween",
    DamageMobs = false,
    SelectedShop = "",
    SelectedWeapon = "",
    AutoBuyEnabled = false,
    AutoScanEnabled = false,
    ScanDelay = 1,
    SelectedRanks = {},
    AutoSellEnabled = false
}
ConfigSystem.CurrentConfig = {}

-- Função para criar pastas se não existirem
ConfigSystem.CreateFolders = function()
    -- Testar diferentes métodos para criar pasta em vários executores
    local success = pcall(function()
        if makefolder then
            if not isfolder(ConfigSystem.Folder) then
                makefolder(ConfigSystem.Folder)
            end
            
            if not isfolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder) then
                makefolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder)
            end
        end
    end)
    
    return success
end

-- Função para salvar configuração (thử nhiều phương thức)
ConfigSystem.SaveConfig = function()
    -- Garantir que a pasta existe
    ConfigSystem.CreateFolders()
    
    -- Mã hóa cấu hình thành chuỗi JSON
    local jsonData = HttpService:JSONEncode(ConfigSystem.CurrentConfig)
    
    -- Testar diferentes métodos de salvar
    local success, err = pcall(function()
        -- Método 1: writefile trực tiếp (Synapse X, KRNL, Script-Ware)
        if writefile then
            writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 2: Usar SaveInstance (alguns outros executores)
        if saveinstance then
            saveinstance(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 3: Fluxus và alguns outros executores
        if fluxus and fluxus.save_file then
            fluxus.save_file(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 4: Delta và alguns outros executores
        if delta_config and delta_config.save then
            delta_config.save(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 5: Codex
        if writefile and getrenv().writefile then
            getrenv().writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        return false
    end)
    
    if success then
        print("Configuração salva com sucesso em: " .. ConfigSystem.FilePath)
        return true
    else
        warn("Falha ao salvar configuração:", err)
        return false
    end
end

-- Função para carregar configuração (thử nhiều phương thức)
ConfigSystem.LoadConfig = function()
    -- Thử các phương thức đọc khác nhau
    local success, content = pcall(function()
        -- Método 1: readfile padrão (Synapse X, KRNL, Script-Ware)
        if readfile and isfile and isfile(ConfigSystem.FilePath) then
            return readfile(ConfigSystem.FilePath)
        end
        
        -- Método 2: Fluxus
        if fluxus and fluxus.read_file and fluxus.file_exists and fluxus.file_exists(ConfigSystem.FilePath) then
            return fluxus.read_file(ConfigSystem.FilePath)
        end
        
        -- Método 3: Delta
        if delta_config and delta_config.load and delta_config.exists and delta_config.exists(ConfigSystem.FilePath) then
            return delta_config.load(ConfigSystem.FilePath)
        end
        
        -- Método 4: Codex
        if readfile and getrenv().readfile and isfile and getrenv().isfile and getrenv().isfile(ConfigSystem.FilePath) then
            return getrenv().readfile(ConfigSystem.FilePath)
        end
        
        return nil
    end)
    
    if success and content then
        local data
        success, data = pcall(function()
            return HttpService:JSONDecode(content)
        end)
        
        if success and data then
        ConfigSystem.CurrentConfig = data
            print("Configuração carregada de: " .. ConfigSystem.FilePath)
        return true
    else
            warn("Erro ao analisar configuração, criando nova.")
        end
    end
    
    -- Se não conseguir ler ou ocorrer erro, criar configuração padrão
        ConfigSystem.CurrentConfig = table.clone(ConfigSystem.DefaultConfig)
        ConfigSystem.SaveConfig()
    print("Inicializando nova configuração")
        return false
    end

-- Criar um sistema de auto save separado
local function setupAutoSave()
    spawn(function()
        while wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                ConfigSystem.SaveConfig()
            end)
        end
    end)
end

-- Carregar configuração ao iniciar
ConfigSystem.LoadConfig()
setupAutoSave() -- Iniciando salvamento automático

-- Atualizar função para salvar imediatamente ao alterar valor
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then
            for _, element in pairs(tab._components) do
                if element and element.OnChanged then
                    element.OnChanged:Connect(function()
                        pcall(function()
                            ConfigSystem.SaveConfig()
                        end)
                    end)
                end
            end
        end
    end
end

-- Configurar SaveManager do Fluent para compatibilidade
local playerName = game:GetService("Players").LocalPlayer.Name
if InterfaceManager then
    InterfaceManager:SetFolder("Allan Hub")
end
if SaveManager then
    SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)
end

-- Detectar automaticamente novo HumanoidRootPart quando o jogador renascer
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
end)

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end

            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function getNearestSelectedEnemy()
    -- Se nenhum inimigo for encontrado em 5 segundos, atualizar lista
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 5 then
        killedNPCs = {} -- Redefinir lista de inimigos mortos
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time() -- Atualizar hora em que o inimigo foi encontrado
    end
    
    return nearestEnemy
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] then
            return enemy
        end
    end
    return nil
end

local function fireShowPetsRemote()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    remote:FireServer(unpack(args))
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
    elseif movementMethod == "Walk" then
        hrp.Parent:MoveTo(enemyHrp.Position)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.2)
    end
end

local function teleportDungeon()
    while teleportEnabled do
        local function getDistance(pos1, pos2)
            return (pos1 - pos2).Magnitude
        end

        local function getClosestEnemy()
            local closestEnemy = nil
            local closestDistance = math.huge
            local playerPosition = hrp.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local distance = getDistance(playerPosition, enemy.HumanoidRootPart.Position)
                    if distance < closestDistance then
                        closestDistance = distance
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            if enemy and enemy:FindFirstChild("HumanoidRootPart") then
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(hrp, tweenInfo, {
                    CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
                })
                tween:Play()
                tween.Completed:Wait()
            end
        end

        local enemy = getClosestEnemy()
        if enemy then
            moveToEnemy(enemy)
            while teleportEnabled and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 do
                task.wait(0.3)
            end
        else
            task.wait(1)
        end
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = getNearestSelectedEnemy()
        
        -- Se não encontrar alvo em 3 segundos, atualizar lista
        if not target and os.time() - lastResetTime > 3 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Lista de inimigos mortos foi atualizada")
        end
        
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()

            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.20)
    end
end

-- Farm Method Selection Dropdown
local Fluent
local SaveManager
local InterfaceManager

local success, err = pcall(function()
    Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
    SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
    InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
end)

if not success then
    warn("Erro ao carregar biblioteca Fluent: " .. tostring(err))
    -- Thử tải từ URL dự phòng
    pcall(function()
        Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Fluent.lua"))()
        SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
        InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
    end)
end

if not Fluent then
    error("Não foi possível carregar a biblioteca Fluent. Verifique sua conexão com a internet ou executor.")
    return
end

local Window = Fluent:CreateWindow({
    Title = "Allan Hub | Arise Crossover",
    SubTitle = "",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 350),
    Acrylic = false,
    Theme = "Luffy",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = {
    Discord = Window:AddTab({ Title = "INFO", Icon = ""}),
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    tp = Window:AddTab({ Title = "Teleports", Icon = "" }),
    mount = Window:AddTab({ Title = "Mount Location/farm", Icon = "" }),
    dungeon = Window:AddTab({ Title = "Dungeon ", Icon = "" }),
    shop = Window:AddTab({ Title = "Shop", Icon = "" }),
    Player = Window:AddTab({ Title = "Player", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" }),
}


-- Tạo mapping giữa các map và danh sách mob tương ứng
local mobsByWorld = {
    ["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
    ["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
    ["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
    ["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
    ["BCWorld"] = {"Sortudo", "Michille", "Wind"},
    ["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
    ["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
    ["DBWorld"] = {"Turtle", "Green", "Sky"},
    ["OPMWorld"] = {"Rider", "Cryborg", "Hurricane"}
}

local selectedWorld = "SoloWorld" -- Default world

-- Dropdown để chọn World/Map
Tabs.Main:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Values = {"SoloWorld", "NarutoWorld", "OPWorld", "BleachWorld", "BCWorld", "ChainsawWorld", "JojoWorld", "DBWorld", "OPMWorld"},
    Multi = false,
    Default = selectedWorld,
    Callback = function(world)
        selectedWorld = world
        ConfigSystem.CurrentConfig.SelectedWorld = world
        
        -- Cập nhật danh sách mob dựa trên world được chọn
        local mobDropdown = Fluent.Options.WorldMobDropdown
        if mobDropdown then
            mobDropdown:SetValues(mobsByWorld[world] or {})
            -- Đặt giá trị mặc định nếu có mob
            if #mobsByWorld[world] > 0 then
                selectedMobName = mobsByWorld[world][1]
                mobDropdown:SetValue(selectedMobName)
                ConfigSystem.CurrentConfig.SelectedMobName = selectedMobName
            else
                selectedMobName = ""
            end
        end
        
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de world
    end
})

-- Dropdown để chọn Mob trong world đã chọn
Tabs.Main:AddDropdown("WorldMobDropdown", {
    Title = "Select Enemy",
    Values = mobsByWorld[selectedWorld] or {},
    Multi = false,
    Default = mobsByWorld[selectedWorld] and mobsByWorld[selectedWorld][1] or "",
    Callback = function(mob)
        selectedMobName = mob
        ConfigSystem.CurrentConfig.SelectedMobName = mob
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de mob
        print("Selected Mob:", selectedMobName) -- Debug
    end
})

Tabs.Main:AddToggle("FarmSelectedMob", {
    Title = "Farm Selected Mob",
    Default = ConfigSystem.CurrentConfig.FarmSelectedMob or false,
    Callback = function(state)
        teleportEnabled = state
        damageEnabled = state -- Đảm bảo tính năng tấn công mobs được kích hoạt
        ConfigSystem.CurrentConfig.FarmSelectedMob = state
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao iniciar farm
        if state then
            task.spawn(teleportToSelectedEnemy)
        end
    end
})

Tabs.Main:AddToggle("TeleportMobs", {
    Title = "Auto farm (nearest NPCs)",
    Default = ConfigSystem.CurrentConfig.AutoFarmNearestNPCs or false,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmNearestNPCs = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(teleportAndTrackDeath)
        end
    end
})

local Dropdown = Tabs.Main:AddDropdown("MovementMethod", {
    Title = "Farming Method",
    Values = {"Tween", "Teleport"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.FarmingMethod == "Teleport" and 2 or 1,
    Callback = function(option)
        movementMethod = option
        ConfigSystem.CurrentConfig.FarmingMethod = option
        ConfigSystem.SaveConfig()
    end 
})

Tabs.Main:AddToggle("GamepassShadowFarm", {
    Title = "Shadow farm",
    Default = false,
    Callback = function(state)
        local attackatri = game:GetService("Players").LocalPlayer.Settings
        local atri = attackatri:GetAttribute("AutoAttack")
        
        if state then
            -- Bật tính năng
            if atri == false then
                attackatri:SetAttribute("AutoAttack", true)
            end
            print("Shadow farm ativado")
        else
            -- Tắt tính năng
            attackatri:SetAttribute("AutoAttack", false)
            print("Shadow farm desativado")
        end
    end
})

-- Adicionar toggle de Auto Attack
local autoAttackEnabled = false
local attackCooldown = 0.5

Tabs.Main:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack Mobs",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        
        if state then
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Ativado ataque automático a mobs",
                Duration = 3
            })
            
            -- Bắt đầu vòng lặp auto attack
            task.spawn(function()
                while autoAttackEnabled do
                    local targetEnemy
                    
                    -- Kiểm tra xem Farm Selected Mob có đang bật không
                    if ConfigSystem.CurrentConfig.FarmSelectedMob and selectedMobName ~= "" then
                        -- Nếu đang farm mob đã chọn, tìm mob đó
                        targetEnemy = getNearestSelectedEnemy()
                    else
                        -- Nếu không, tìm bất kỳ mob nào gần nhất
                        targetEnemy = getNearestEnemy()
                    end
                    
                    if targetEnemy then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "PunchAttack",
                                    ["Enemy"] = targetEnemy.Name
                                },
                                [2] = "\4"
                            }
                        }
                        remote:FireServer(unpack(args))
                    end
                    task.wait(attackCooldown) -- Chờ giữa các lần tấn công
                end
            end)
        else
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Desativado ataque automático a mobs",
                Duration = 3
            })
        end
    end
})

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tùy chọn, để đảm bảo điểm hồi sinh được thiết lập)
    task.wait(0.5)

    -- Hồi sinh nhân vật
    local player = game.Players.LocalPlayer
if player.Character and player.Character.Parent then
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0 -- Tạo ra cái chết tự nhiên mà không xóa nhân vật đột ngột
    end
end

end

local TweenService = game:GetService("TweenService")

-- Lấy Player và HumanoidRootPart
local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Cập nhật HRP khi nhân vật hồi sinh
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart") -- Lấy HRP mới sau khi hồi sinh
end)

-- Hàm di chuyển (Luôn sử dụng HRP mới nhất)
local function teleportWithTween(targetCFrame)
    if hrp then
        local tweenInfo = TweenInfo.new(
            2, -- Thời gian (giây)
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.Out,
            0, -- Không lặp lại
            false, -- Không đảo ngược
            0 -- Không độ trễ
        )

        local tweenGoal = {CFrame = targetCFrame}
        local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
        tween:Play()
    end
end


-- Locations List
local locations = {
    {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668, -0.41691944, -8.07482721e-08, 0.908943415, -2.94452178e-07, 1, -4.62235228e-08, -0.908943415, -2.86911842e-07, -0.41691944)},
    {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379, 0.836233854, -7.47273816e-08, -0.548372984, 2.59595481e-07, 1, 2.59595481e-07, 0.548372984, -3.59437678e-07, 0.836233854)},
    {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244, 0.8239398, -3.60997859e-07, -0.566677332, 2.59595453e-07, 1, -2.59595396e-07, 0.566677332, 6.67841249e-08, 0.8239398)},
    {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646, 0.978662074, 0.000114096198, -0.205476329, -0.000112703143, 1, 1.84834444e-05, 0.205476329, 5.06878177e-06, 0.978662074)},
    {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292, -0.999887109, -1.20863996e-12, 0.0150266131, -1.12492459e-12, 1, 5.57959278e-12, -0.0150266131, 5.56205906e-12, -0.999887109)},
    {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113, -0.534268856, -4.75206689e-05, 0.845314622, -7.48304665e-05, 1, 8.92103617e-06, -0.845314622, -5.84890549e-05, -0.534268856)},
    {Name = "Location 7", CFrame = CFrame.new(4325.36523, 118.995422, -4819.78857, -0.257801384, 3.98855832e-07, -0.966197908, -5.63039578e-07, 1, 5.63040146e-07, 0.966197908, 6.89160231e-07, -0.257801384)}
    
}

-- Add buttons for each location
for _, loc in ipairs(locations) do
    Tabs.mount:AddButton({
        Title = loc.Name,
        Callback = function()
            teleportWithTween(loc.CFrame)
        end
    })
end


local autoDestroy = false
local autoArise = false

-- Function to Fire DestroyPrompt
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")

local function fireDestroy()
    while autoDestroy do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local DestroyPrompt = rootPart and rootPart:FindFirstChild("DestroyPrompt")

                if DestroyPrompt then
                    DestroyPrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(DestroyPrompt)
                end
            end
        end
    end
end

-- Function to Fire ArisePrompt
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")

local function fireArise()
    while autoArise do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local arisePrompt = rootPart and rootPart:FindFirstChild("ArisePrompt")

                if arisePrompt then
                    arisePrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(arisePrompt)
                end
            end
        end
    end
end

-- Auto Destroy Toggle
Tabs.Main:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = ConfigSystem.CurrentConfig.MainAutoDestroy or false,
    Callback = function(state)
        autoDestroy = state
        ConfigSystem.CurrentConfig.MainAutoDestroy = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.Main:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = ConfigSystem.CurrentConfig.MainAutoArise or false,
    Callback = function(state)
        autoArise = state
        ConfigSystem.CurrentConfig.MainAutoArise = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireArise)
        end
    end
})

Tabs.dungeon:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = false,
    Flag = "DungeonAutoDestroy", -- Adicionar Flag para salvar configuração
    Callback = function(state)
        autoDestroy = state
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.dungeon:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = false,
    Flag = "DungeonAutoArise", -- Adicionar Flag para salvar configuração
    Callback = function(state)
        autoArise = state
        if state then
            task.spawn(fireArise)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local dungeonFolder = workspace:WaitForChild("__Main"):WaitForChild("__Dungeon")

-- Variable to control teleporting
local teleportingEnabled = false
-- Função para criar a dungeon
local function createDungeon()
    print("[DEBUG] Tentando criar dungeon...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("✓ Dungeon criada.")
    task.wait(3)

    -- Iniciar a dungeon
    local iniciarArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(iniciarArgs))
    print("▶ Dungeon iniciada.")
end

-- Function to start the dungeon (mantida como backup)
local function startDungeon()
    local dungeonInstance = dungeonFolder:FindFirstChild("Dungeon")
    if dungeonInstance then
        local dungeonID = dungeonInstance:GetAttribute("ID")
        if dungeonID then
            print("[DEBUG] Iniciando dungeon com ID:", dungeonID)
            local args = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = dungeonID,
                        ["Event"] = "DungeonAction",
                        ["Action"] = "Start"
                    },
                    [2] = "\n"
                }
            }
            ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("[DEBUG] Evento de início da Dungeon ativado!")
        else
            print("[LỖI] Não foi encontrado ID da Dungeon!")
        end
    else
        print("[LỖI] Não foi encontrada instância da Dungeon!")
    end
end

-- Function to teleport directly to an object and bypass anti-cheat
local function teleportToObject(object)
    if object and object:IsA("Part") then
        print("[DEBUG] Teleportando para:", object.Name)

        -- Bypass anti-cheat
        local f = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("FlyingFixer")
        if f then f:Destroy() else print("blablabla bleble") end

        local cha = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("CharacterUpdater")
        if cha then cha:Destroy() print("discord") else print("Cid") end

        -- Dịch chuyển trực tiếp
        hrp.CFrame = object.CFrame
        print("[DEBUG] Teleport concluído para:", object.Name)

        task.wait(2) -- Pequeno atraso após teleporte
        createDungeon() -- Kích hoạt remote tạo dungeon usando a função corrigida
    else
        print("[LỖI] Alvo de teleporte inválido!")
    end
end

-- Function to continuously teleport to objects when enabled
local function teleportLoop()
    while teleportingEnabled do
        print("[DEBUG] Procurando objetos de dungeon...")
        local foundObject = false
        for _, object in ipairs(dungeonFolder:GetChildren()) do
            if object:IsA("Part") then
                foundObject = true
                teleportToObject(object)
                task.wait(1) -- Evitar execução excessiva
            end
        end
        if not foundObject then
            print("[CẢNH BÁO] Nenhum objeto de dungeon válido encontrado!")
        end
        task.wait(0.5) -- Atraso antes de verificar novamente
    end
end

-- Add the toggle button to start/stop teleporting
Tabs.dungeon:AddToggle("TeleportToDungeon", {
    Title = "Teleport to Dungeon",
    Default = false,
    Callback = function(state)
        teleportingEnabled = state
        print("[DEBUG] Teleporte ativado/desativado:", state)
        if state then
            task.spawn(teleportLoop) -- Bắt đầu vòng lặp dịch chuyển khi bật
        end
    end
})

local AutoDetectToggle = Tabs.dungeon:AddToggle("AutoDetectDungeon", {Title = "Auto Detect Dungeon", Default = true})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local villageSpawns = {
    ["Grass Village"] = "NarutoWorld",
    ["BRUM ISLAND"] = "OPWorld",
    ["Leveling City"] = "SoloWorld",
    ["FACEHEAL TOWN"] = "BleachWorld",
    ["Lucky"] = "BCWorld",
    ["Nipon City"] = "ChainsawWorld",
    ["Mori Town"] = "JojoWorld",
    ["Dragon City"] = "DBWorld",
    ["XZ City"] = "OPMWorld",
}

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tùy chọn, để đảm bảo điểm hồi sinh được thiết lập)
    task.wait(0.5)

    -- Hồi sinh nhân vật
    if player.Character then
        player.Character:BreakJoints() -- Buộc nhân vật phải hồi sinh
    end
end

local function detectDungeon()
    player.PlayerGui.Warn.ChildAdded:Connect(function(dungeon)
        if dungeon:IsA("Frame") and AutoDetectToggle.Value then
            print("Dungeon detectada!")
            for _, child in ipairs(dungeon:GetChildren()) do
                if child:IsA("TextLabel") then
                    for village, spawnName in pairs(villageSpawns) do
                        if string.find(string.lower(child.Text), string.lower(village)) then
                            teleportEnabled = false
                            print("Vila detectada:", village)
                            SetSpawnAndReset(spawnName)
                            return
                        end
                    end
                end
            end
        end
    end)
end

-- Đảm bảo hàm hoạt động
AutoDetectToggle:OnChanged(function(value)
    if value then
        detectDungeon()
    end
end)

detectDungeon()

local function resetAutoFarm()
    -- Đặt lại tất cả trạng thái và hàm
    killedNPCs = {} -- Đặt lại số lượng NPC đã tiêu diệt

    print("AutoFarm foi reiniciado!") -- In thông báo xác nhận

    -- Khởi động lại tất cả các hàm nếu cần
end

task.spawn(function()
    while true do
        task.wait(120) -- Đợi 120 giây
        resetAutoFarm() -- Gọi hàm đặt lại
    end
end)

-- ==========================
-- NOVA SEÇÃO CASTLE INF CORRIGIDA (SUBSTITUI TODA A ANTERIOR)
-- ==========================

-- Config padrão para Castle
if ConfigSystem.DefaultConfig.CastleEntryFloor == nil then
    ConfigSystem.DefaultConfig.CastleEntryFloor = 1
end
if ConfigSystem.CurrentConfig.CastleEntryFloor == nil then
    ConfigSystem.CurrentConfig.CastleEntryFloor = ConfigSystem.DefaultConfig.CastleEntryFloor
end
local entryFloor = ConfigSystem.CurrentConfig.CastleEntryFloor

if ConfigSystem.DefaultConfig.CastleExitFloor == nil then
    ConfigSystem.DefaultConfig.CastleExitFloor = 101
end
if ConfigSystem.CurrentConfig.CastleExitFloor == nil then
    ConfigSystem.CurrentConfig.CastleExitFloor = ConfigSystem.DefaultConfig.CastleExitFloor
end
local exitFloor = ConfigSystem.CurrentConfig.CastleExitFloor

-- Variáveis de controle para Castle
local castleEnabled = false
local castleResetEnabled = false
local lastUsedFloor = nil
local floorCooldown = {}

-- Inputs para configuração de andares
Tabs.dungeon:AddInput("CastleEntryFloorNew", {
    Title = "Castle Entry Floor",
    Default = tostring(entryFloor),
    Placeholder = "Andar de entrada",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            entryFloor = floor
            ConfigSystem.CurrentConfig.CastleEntryFloor = floor
            ConfigSystem.SaveConfig()
            print("[Castle] Andar de entrada atualizado para:", floor)
        end
    end
})

Tabs.dungeon:AddInput("CastleExitFloorNew", {
    Title = "Castle Exit Floor", 
    Default = tostring(exitFloor),
    Placeholder = "Andar de saída",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            exitFloor = floor
            ConfigSystem.CurrentConfig.CastleExitFloor = floor
            ConfigSystem.SaveConfig()
            print("[Castle] Andar de saída atualizado para:", floor)
        end
    end
})

-- Funções Castle
local function buyCastleTicket()
    local args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "CastleAction", 
                ["Action"] = "BuyTicket"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Ticket comprado")
end

local function joinCastle(floor)
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(floor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Entrando no andar:", floor)
end

local function leaveCastle()
    local args = {
        [1] = {
            [1] = { ["Event"] = "LeaveDungeon" },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Saindo do castle")
end

local function resetCastleInside(floor)
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(floor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Reset interno para andar:", floor)
end

local function getCurrentFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end
    
    local current = nil
    for i = 1, 200 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end
    return current
end

-- Farm de mobs
local function getEnemies()
    local main = workspace:FindFirstChild("__Main")
    if not main then return {} end
    local enemiesFolder = main:FindFirstChild("__Enemies")
    if enemiesFolder and enemiesFolder:FindFirstChild("Server") then
        return enemiesFolder.Server:GetChildren()
    end
    return {}
end

local function enemiesAlive()
    for _, enemy in ipairs(getEnemies()) do
        local hp = enemy:GetAttribute("HP")
        if hp and hp > 0 then
            return true
        end
    end
    return false
end

-- FirePortal com voo melhorado
local function flyTo(targetPos)
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local speed = 60
    
    -- Criar BodyVelocity para voo suave
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.Parent = hrp
    
    while (castleEnabled or castleResetEnabled) do
        if not hrp.Parent then break end
        local dist = (hrp.Position - targetPos).Magnitude
        if dist < 10 then break end
        
        local dir = (targetPos - hrp.Position).Unit
        bodyVelocity.Velocity = dir * speed
        task.wait(0.1)
    end
    
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity:Destroy()
end

local function waitAndActivatePortal(floor)
    local main = workspace:FindFirstChild("__Main")
    if not main then return false end
    local world = main:FindFirstChild("__World")
    if not world then return false end
    
    local room = world:FindFirstChild("Room_" .. floor)
    if not room then return false end

    local portal
    -- Espera até 15s pelo FirePortal
    for i = 1, 150 do
        portal = room:FindFirstChild("FirePortal", true)
        if portal then break end
        task.wait(0.1)
    end

    if not portal then
        warn("[Castle] Nenhum FirePortal encontrado no andar " .. tostring(floor))
        return false
    end

    print("[Castle] Portal encontrado no andar " .. floor .. ", voando até ele...")
    
    -- Voa até o portal
    flyTo(portal.Position + Vector3.new(0, 5, 0))
    task.wait(0.5)

    -- Até 3 tentativas de ativar
    local prompt = portal:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        -- Procurar em descendentes
        for _, obj in ipairs(portal:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                prompt = obj
                break
            end
        end
    end
    
    for attempt = 1, 3 do
        if prompt then
            pcall(function() 
                fireproximityprompt(prompt)
            end)
            print(string.format("[Castle] Tentativa %d de ativar portal do andar %d", attempt, floor))
            task.wait(1.5)
            
            -- Verifica se subiu de andar
            if not world:FindFirstChild("Room_" .. floor) then
                print("[Castle] Subiu para o próximo andar!")
                return true
            end
        else
            warn("[Castle] ProximityPrompt não encontrado")
            break
        end
    end

    warn("[Castle] Não conseguiu ativar o portal no andar " .. tostring(floor))
    return false
end

-- Loop SAIR (modo original)
local function autoCastleLeave()
    task.spawn(function()
        print("[Castle] Iniciando modo AUTO CASTLE (sair)")
        while castleEnabled do
            pcall(function()
                local floor = getCurrentFloor()
                if not floor then
                    -- Fora do castle - comprar ticket e entrar
                    print("[Castle] Fora do castle, comprando ticket...")
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    print("[Castle] Andar atual:", floor)
                    if floor >= exitFloor then
                        print("[Castle] Atingiu andar de saída, saindo...")
                        leaveCastle()
                        task.wait(8)
                        -- Reiniciar ciclo
                        buyCastleTicket()
                        task.wait(1)
                        joinCastle(entryFloor)
                        task.wait(5)
                    else
                        -- Verificar se há inimigos vivos
                        if not enemiesAlive() then
                            print("[Castle] Nenhum inimigo vivo, tentando subir...")
                            waitAndActivatePortal(floor)
                            task.wait(2)
                        else
                            print("[Castle] Ainda há inimigos vivos, aguardando...")
                        end
                    end
                end
            end)
            task.wait(0.5)
        end
        print("[Castle] Loop AUTO CASTLE (sair) encerrado")
    end)
end

-- Loop RESET (modo novo)
local function autoCastleReset()
    task.spawn(function()
        print("[Castle] Iniciando modo AUTO CASTLE (reset interno)")
        while castleResetEnabled do
            pcall(function()
                local floor = getCurrentFloor()
                if not floor then
                    -- Fora do castle - comprar ticket e entrar
                    print("[Castle] Fora do castle, comprando ticket...")
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    print("[Castle] Andar atual:", floor)
                    if floor >= exitFloor then
                        print("[Castle] Atingiu andar de saída, fazendo reset interno...")
                        resetCastleInside(entryFloor)
                        task.wait(5)
                    else
                        -- Verificar se há inimigos vivos
                        if not enemiesAlive() then
                            print("[Castle] Nenhum inimigo vivo, tentando subir...")
                            waitAndActivatePortal(floor)
                            task.wait(2)
                        else
                            print("[Castle] Ainda há inimigos vivos, aguardando...")
                        end
                    end
                end
            end)
            task.wait(0.5)
        end
        print("[Castle] Loop AUTO CASTLE (reset interno) encerrado")
    end)
end

-- Seção Castle
local CastleSection = Tabs.dungeon:AddSection("Castle INF Functions")

-- Toggles para Castle
Tabs.dungeon:AddToggle("AutoCastleLeave", {
    Title = "Auto Castle INF (Sair)",
    Description = "Sai do castle quando atinge o andar alvo",
    Default = false,
    Callback = function(state)
        castleEnabled = state
        if state then
            -- Desativar o outro modo se estiver ativo
            castleResetEnabled = false
            
            Fluent:Notify({
                Title = "Auto Castle (Sair)",
                Content = string.format("Ativado - Entrada: %d, Saída: %d", entryFloor, exitFloor),
                Duration = 3
            })
            
            buyCastleTicket()
            task.wait(1)
            joinCastle(entryFloor)
            autoCastleLeave()
        else
            Fluent:Notify({
                Title = "Auto Castle (Sair)",
                Content = "Desativado",
                Duration = 3
            })
            pcall(function() leaveCastle() end)
        end
    end
})

Tabs.dungeon:AddToggle("AutoCastleReset", {
    Title = "Auto Castle INF (Reset)",
    Description = "Faz reset interno quando atinge o andar alvo",
    Default = false,
    Callback = function(state)
        castleResetEnabled = state
        if state then
            -- Desativar o outro modo se estiver ativo
            castleEnabled = false
            
            Fluent:Notify({
                Title = "Auto Castle (Reset)",
                Content = string.format("Ativado - Entrada: %d, Reset: %d", entryFloor, exitFloor),
                Duration = 3
            })
            
            buyCastleTicket()
            task.wait(1)
            joinCastle(entryFloor)
            autoCastleReset()
        else
            Fluent:Notify({
                Title = "Auto Castle (Reset)",
                Content = "Desativado", 
                Duration = 3
            })
            pcall(function() leaveCastle() end)
        end
    end
})

-- Botões auxiliares
Tabs.dungeon:AddButton({
    Title = "Show Current Floor",
    Description = "Mostra o andar atual do castle",
    Callback = function()
        local floor = getCurrentFloor()
        if floor then
            Fluent:Notify({
                Title = "Andar Atual",
                Content = "Você está no andar: " .. floor,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Fora do Castle",
                Content = "Você não está no castle no momento",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddButton({
    Title = "Manual Leave Castle",
    Description = "Sair manualmente do castle",
    Callback = function()
        leaveCastle()
        Fluent:Notify({
            Title = "Castle",
            Content = "Comando de saída enviado",
            Duration = 3
        })
    end
})

-- Continuar o resto do código...
local localPlayer = game:GetService("Players").LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local playerHRP = playerCharacter:WaitForChild("HumanoidRootPart")
local enemyContainer = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local networkEvent = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local autoFarmActive = false
local defeatedEnemies = {}

local function isTargetDefeated(target)
    local healthUI = target:FindFirstChild("HealthBar")
    if healthUI and healthUI:FindFirstChild("Main") and healthUI.Main:FindFirstChild("Bar") then
        local healthText = healthUI.Main.Bar:FindFirstChild("Amount")
        if healthText and healthText:IsA("TextLabel") and healthText.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function findClosestTarget()
    local closestJJ2, closestJJ3, closestJJ4 = nil, nil, nil
    local distJJ2, distJJ3, distJJ4 = math.huge, math.huge, math.huge
    local playerPos = localPlayer.Character and localPlayer.Character:GetPivot().Position

    if not playerPos then return nil end

    for _, enemy in ipairs(enemyContainer:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local enemyType = enemy:GetAttribute("ID")
            
            -- Đảm bảo script bỏ qua các kẻ địch đã chết
            if not defeatedEnemies[enemy.Name] then
                local distance = (playerPos - enemy:GetPivot().Position).Magnitude
                
                if enemyType == "JJ2" and distance < distJJ2 then
                    distJJ2 = distance
                    closestJJ2 = enemy
                elseif enemyType == "JJ3" and distance < distJJ3 then
                    distJJ3 = distance
                    closestJJ3 = enemy
                elseif enemyType == "JJ4" and distance < distJJ4 then
                    distJJ4 = distance
                    closestJJ4 = enemy
                end
            end
        end
    end

    -- Ưu tiên: JJ2 > JJ3 > JJ4
    return closestJJ2 or closestJJ3 or closestJJ4
end

local function triggerPetVisibility()
    local arguments = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(arguments))
end

local function startAutoFarm()
    while autoFarmActive do
        local targetEnemy = findClosestTarget()
        
        while autoFarmActive and targetEnemy do
            if not targetEnemy.Parent then break end

            local targetHRP = targetEnemy:FindFirstChild("HumanoidRootPart")
            local playerHRP = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

            if targetHRP and playerHRP then
                -- Move to target enemy
                playerHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 6)

                task.wait(0.5)
                triggerPetVisibility()

                networkEvent:FireServer({
                    {
                        ["PetPos"] = {},
                        ["AttackType"] = "All",
                        ["Event"] = "Attack",
                        ["Enemy"] = targetEnemy.Name
                    },
                    "\7"
                })

                -- Wait until enemy is defeated or a higher-priority one appears
                while autoFarmActive and targetEnemy.Parent do
                    if isTargetDefeated(targetEnemy) then
                        defeatedEnemies[targetEnemy.Name] = true -- Mark it as dead immediately
                        break
                    end
                    
                    task.wait(0.1)
                    
                    -- Switch if a higher-priority target appears
                    local newTarget = findClosestTarget()
                    if newTarget and newTarget:GetAttribute("ID") == "JJ2" and newTarget ~= targetEnemy then
                        break
                    elseif newTarget and newTarget:GetAttribute("ID") == "JJ3" and targetEnemy:GetAttribute("ID") == "JJ4" then
                        break
                    end
                end
            end

            targetEnemy = findClosestTarget() -- Move to next enemy
        end

        task.wait(0.20)
    end
end

Tabs.Main:AddToggle("AutoFarmToggle", {
    Title = "auto Jeju farm",
    Default = false,
    Callback = function(state)
        autoFarmActive = state
        if state then
            task.spawn(startAutoFarm)
        end
    end
})

Tabs.dungeon:AddToggle("AutoBuyDungeonTicket", {
    Title = "Auto Buy Dungeon Ticket",
    Default = false,
    Callback = function(state)
        buyTicketEnabled = state
        print("[DEBUG] Auto Buy Dungeon Ticket toggled:", state)
        
        if state then
            task.spawn(function()
                while buyTicketEnabled do
                    local args = {
                        [1] = {
                            [1] = {
                                ["Type"] = "Gems",
                                ["Event"] = "DungeonAction",
                                ["Action"] = "BuyTicket"
                            },
                            [2] = "\n"
                        }
                    }

                    game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
                    task.wait(5) -- Đợi 5 giây trước khi gửi lại
                end
            end)
        end
    end
})

local AutoEnterDungeon = Tabs.dungeon:AddToggle("AutoEnterDungeon", { Title = "Auto Enter Guild Dungeon", Default = false })

local function EnterDungeon()
    while AutoEnterDungeon.Value do
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "DungeonAction",
                    ["Action"] = "TestEnter"
                },
                [2] = "\n"
            }
        }

        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
        task.wait(0.5) -- Ajustar o atraso se necessário
    end
end

AutoEnterDungeon:OnChanged(function(Value)
    if Value then
        task.spawn(EnterDungeon) -- Start loop when enabled
    end
end)

Tabs.Discord:AddParagraph({
    Title = "Thông tin",
    Content = "Script được tạo bởi Allan Hub"
})

Tabs.Discord:AddButton({
    Title = "Copy Discord Link",
    Description = "Join my discord",
    Callback = function()
        setclipboard("https://discord.gg/v94FqK3zH5")
        Fluent:Notify({
            Title = "Đã sao chép!",
            Content = "Đường dẫn Discord đã được sao chép vào clipboard.",
            Duration = 3
        })
    end
})

-- ==========================
-- SISTEMA DE SHOP
-- ==========================

local BuyWeaponSection = Tabs.shop:AddSection("Buy Weapon")
-- Mapping giữa shops và weapons
local weaponsByShop = {
    ["WeaponShop1"] = {"SpikeMace", "GemStaff", "DualKando", "CrystalScepter", "DualBoneMace", "DualSteelNaginata"},
    ["WeaponShop2"] = {"MonsterSlayer", "DualBasicStaffs", "PirateSaber", "BronzeGreatAxe", "MixedBattleAxe", "DualAncientMace"},
    ["WeaponShop3"] = {"DualPirateSaber", "DualSteelSabers", "DualSteelButterfly", "SteelSaber", "SteelButterfly", "SteelKando"},
    ["WeaponShop4"] = {"SteelNaginata", "GreatKopesh", "BoneMace", "CrimsonStaff", "AncientMace", "GreatSaber"},
    ["WeaponShop5"] = {"DualGreatSaber", "BasicStaff", "StellKopesh", "GreatTrident", "DualCrystalScepter", "DualTrident"},
    ["WeaponShop6"] = {"OzSword2", "CrystalSword2", "ObsidianDualAxe2", "SilverSpear2", "DragonAxe2", "DualDivineAxe2"},
    ["WeaponShop7"] = {"BloodStaff2", "DualCrimsonStaff2", "DualGemStaffs2", "GreatScythe2", "TwinObsidianDualStaff2", "SlayerScythe2"},
    ["WeaponShop8"] = {"BeholderStaff2", "TwinMixedAxe2", "TwinTrollSlayer2", "RuneAxe2", "DualSilverSpear2", "DualDragonAxe2"},
    ["WeaponShop9"] = {"SteelSword2", "SteelSpear2", "StarSpear2", "BoneStaff2", "SunGreatAxe2", "EnergyGreatSword2"},
}

local selectedShop = "WeaponShop1" -- Shop mặc định
local selectedWeapon = "" -- Weapon mặc định
local autoBuyEnabled = false -- Trạng thái Auto Buy

-- Cập nhật ConfigSystem để lưu các biến mới
ConfigSystem.DefaultConfig.SelectedShop = selectedShop
ConfigSystem.DefaultConfig.SelectedWeapon = selectedWeapon
ConfigSystem.DefaultConfig.AutoBuyEnabled = autoBuyEnabled

-- Dropdown để chọn Shop
Tabs.shop:AddDropdown("ShopDropdown", {
    Title = "Select Shop",
    Values = {"WeaponShop1", "WeaponShop2", "WeaponShop3", "WeaponShop4", "WeaponShop5", "WeaponShop6", "WeaponShop7", "WeaponShop8", "WeaponShop9"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedShop or selectedShop,
    Callback = function(shop)
        selectedShop = shop
        ConfigSystem.CurrentConfig.SelectedShop = shop
        
        -- Cập nhật danh sách weapon dựa trên shop được chọn
        local weaponDropdown = Fluent.Options.WeaponDropdown
        if weaponDropdown then
            weaponDropdown:SetValues(weaponsByShop[shop] or {})
            -- Đặt giá trị mặc định nếu có weapon
            if #weaponsByShop[shop] > 0 then
                selectedWeapon = weaponsByShop[shop][1]
                weaponDropdown:SetValue(selectedWeapon)
                ConfigSystem.CurrentConfig.SelectedWeapon = selectedWeapon
            else
                selectedWeapon = ""
            end
        end
        
        ConfigSystem.SaveConfig()
    end
})

-- Dropdown để chọn Weapon trong shop đã chọn
Tabs.shop:AddDropdown("WeaponDropdown", {
    Title = "Select Weapon",
    Values = weaponsByShop[selectedShop] or {},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeapon or (weaponsByShop[selectedShop] and weaponsByShop[selectedShop][1] or ""),
    Callback = function(weapon)
        selectedWeapon = weapon
        ConfigSystem.CurrentConfig.SelectedWeapon = weapon
        ConfigSystem.SaveConfig()
        print("Selected Weapon:", selectedWeapon) -- Debug
    end
})

-- Đồng bộ lại danh sách vũ khí sau khi GUI đã khởi tạo
task.defer(function()
    local currentShop = ConfigSystem.CurrentConfig.SelectedShop
    local currentWeapon = ConfigSystem.CurrentConfig.SelectedWeapon
    local weaponDropdown = Fluent.Options.WeaponDropdown

    if currentShop and weaponsByShop[currentShop] and weaponDropdown then
        weaponDropdown:SetValues(weaponsByShop[currentShop])
        if table.find(weaponsByShop[currentShop], currentWeapon) then
            weaponDropdown:SetValue(currentWeapon)
        else
            local defaultWeapon = weaponsByShop[currentShop][1]
            selectedWeapon = defaultWeapon
            weaponDropdown:SetValue(defaultWeapon)
            ConfigSystem.CurrentConfig.SelectedWeapon = defaultWeapon
            ConfigSystem.SaveConfig()
        end
    end
end)

-- Hàm để mua weapon
local function buyWeapon()
    if selectedShop and selectedWeapon and selectedWeapon ~= "" then
        local args = {
            [1] = {
                [1] = {
                    ["Action"] = "Buy",
                    ["Shop"] = selectedShop,
                    ["Item"] = selectedWeapon,
                    ["Event"] = "ItemShopAction"
                },
                [2] = "\n"
            }
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
        print("Comprado:", selectedWeapon, "da loja:", selectedShop)
    else
        print("Por favor, selecione uma loja e uma arma!")
    end
end

-- Toggle để bật/tắt Auto Buy
Tabs.shop:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy Weapon",
    Default = ConfigSystem.CurrentConfig.AutoBuyEnabled or false,
    Callback = function(state)
        autoBuyEnabled = state
        ConfigSystem.CurrentConfig.AutoBuyEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            task.spawn(function()
                while autoBuyEnabled do
                    buyWeapon()
                    task.wait(1) -- Chờ 1 giây giữa mỗi lần mua
                end
            end)
        end
    end
})

local UpdateWeaponSection = Tabs.shop:AddSection("Update Weapon")
-- Thêm code cho tab Update sau phần mã của tab Buy
-- Hàm để lấy danh sách tên vũ khí duy nhất từ inventory
local function getUniqueWeaponNames()
    local weapons = {}
    local seenNames = {} -- Để theo dõi tên duy nhất

    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    print("Obtendo lista de armas...") -- Gỡ LỖI

    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name") -- Lấy thuộc tính "Name"
        if weaponName then
            print("Arma encontrada:", weaponName) -- Gỡ LỖI
            if not seenNames[weaponName] then
                table.insert(weapons, weaponName)
                seenNames[weaponName] = true -- Đánh dấu tên đã thấy
            end
        end
    end
    return weapons
end

-- Lấy danh sách tên vũ khí ban đầu
local weaponTypes = getUniqueWeaponNames()
local selectedWeaponType = weaponTypes[1] or "" -- Loại vũ khí mặc định
local autoUpdateEnabled = false -- Trạng thái Auto Update
local autoSelectedEnabled = false -- Trạng thái Auto Update cho vũ khí đã chọn

-- Cập nhật ConfigSystem
ConfigSystem.DefaultConfig.SelectedWeaponType = selectedWeaponType
ConfigSystem.DefaultConfig.AutoUpdateEnabled = autoUpdateEnabled
ConfigSystem.DefaultConfig.AutoSelectedEnabled = autoSelectedEnabled

-- Dropdown để chọn loại vũ khí muốn nâng cấp
Tabs.shop:AddDropdown("WeaponTypeDropdown", {
    Title = "Select Weapon",
    Values = weaponTypes,
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeaponType or selectedWeaponType,
    Callback = function(weaponType)
        selectedWeaponType = weaponType
        ConfigSystem.CurrentConfig.SelectedWeaponType = weaponType
        ConfigSystem.SaveConfig()
        print("Selected Weapon Type:", selectedWeaponType) -- Gỡ LỖI
    end
})

-- Hàm để lấy tất cả vũ khí theo level
local function getWeaponsByLevel(weaponType)
    local weaponsByLevel = {}
    
    -- Khởi tạo mảng để lưu trữ vũ khí theo level
    for i = 1, 7 do
        weaponsByLevel[i] = {}
    end
    
    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name")
        local weaponLevel = weapon:GetAttribute("Level") or 1
        
        -- Nếu không chọn loại vũ khí cụ thể hoặc vũ khí thuộc loại đã chọn
        if (not weaponType or weaponType == "" or weaponName == weaponType) and weaponLevel >= 1 and weaponLevel <= 7 then
            table.insert(weaponsByLevel[weaponLevel], weapon.Name)
            print("Arma encontrada:", weaponName, "Level:", weaponLevel, "ID:", weapon.Name)
        end
    end
    
    return weaponsByLevel
end

-- Hàm để nâng cấp vũ khí theo level
local function upgradeWeaponsByLevel(weaponType)
    local weaponsByLevel = getWeaponsByLevel(weaponType)
    local anyUpgraded = false
    
    -- Duyệt qua từng level, bắt đầu từ level thấp nhất
    for level = 1, 6 do
        local weapons = weaponsByLevel[level]
        
        -- Nếu có ít nhất 3 vũ khí cùng level, thực hiện nâng cấp
        while #weapons >= 3 do
            -- Lấy 3 vũ khí đầu tiên để nâng cấp
            local upgradeWeapons = {
                weapons[1],
                weapons[2],
                weapons[3]
            }
            
            -- Xóa 3 vũ khí này khỏi danh sách
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            
            -- Thực hiện nâng cấp
            local weaponName = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:FindFirstChild(upgradeWeapons[1]):GetAttribute("Name")
            
            local args = {
                [1] = {
                    [1] = {
                        ["Type"] = weaponName,
                        ["BuyType"] = "Gems",
                        ["Weapons"] = upgradeWeapons,
                        ["Event"] = "UpgradeWeapon",
                        ["Level"] = level + 1
                    },
                    [2] = "\n"
                }
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("Đang nâng cấp", #upgradeWeapons, "vũ khí", weaponName, "từ level", level, "lên level", level + 1)
            
            Fluent:Notify({
                Title = "Đang nâng cấp",
                Content = "Đang nâng cấp " .. weaponName .. " từ level " .. level .. " lên level " .. (level + 1),
                Duration = 3
            })
            
            anyUpgraded = true
            task.wait(1) -- Đợi 1 giây để tránh spam server
        end
    end
    
    if not anyUpgraded then
        Fluent:Notify({
            Title = "Thông báo",
            Content = "Không có vũ khí nào đủ số lượng để nâng cấp",
            Duration = 3
        })
    end
    
    return anyUpgraded
end

-- Nút để làm mới danh sách vũ khí
Tabs.shop:AddButton({
    Title = "Refresh Weapon List",
    Description = "Refresh the list of available weapons",
    Callback = function()
        weaponTypes = getUniqueWeaponNames()
        local weaponTypeDropdown = Fluent.Options.WeaponTypeDropdown
        if weaponTypeDropdown then
            weaponTypeDropdown:SetValues(weaponTypes)
            if #weaponTypes > 0 and not table.find(weaponTypes, selectedWeaponType) then
                selectedWeaponType = weaponTypes[1]
                weaponTypeDropdown:SetValue(selectedWeaponType)
                ConfigSystem.CurrentConfig.SelectedWeaponType = selectedWeaponType
                ConfigSystem.SaveConfig()
            end
        end
        
        Fluent:Notify({
            Title = "Danh sách đã làm mới",
            Content = "Đã cập nhật danh sách vũ khí có sẵn",
            Duration = 3
        })
    end
})

-- Toggle để bật/tắt nâng cấp vũ khí đã chọn
Tabs.shop:AddToggle("AutoSelectToggle", {
    Title = "Upgrade Selected Weapon",
    Default = ConfigSystem.CurrentConfig.AutoSelectedEnabled or false,
    Callback = function(state)
        autoSelectedEnabled = state
        ConfigSystem.CurrentConfig.AutoSelectedEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if not selectedWeaponType or selectedWeaponType == "" then
                Fluent:Notify({
                    Title = "Lỗi",
                    Content = "Vui lòng chọn loại vũ khí trước khi nâng cấp",
                    Duration = 3
                })
                return
            end
            
            task.spawn(function()
                while autoSelectedEnabled do
                    local upgraded = upgradeWeaponsByLevel(selectedWeaponType)
                    if not upgraded then
                        task.wait(5) -- Đợi lâu hơn nếu không có vũ khí nào được nâng cấp
                    else
                        task.wait(1) -- Đợi ngắn hơn nếu có vũ khí được nâng cấp
                    end
                end
            end)
        end
    end
})

-- Thêm section sell pet vào tab shop
local SellPetSection = Tabs.shop:AddSection("Sell Pet")
-- Ánh xạ các rank số sang chữ cái
local rankMapping = {
    [1] = "E",
    [2] = "D",
    [3] = "C",
    [4] = "B",
    [5] = "A",
    [6] = "S",
    [7] = "SS",
    [8] = "G",
    [9] = "N"
}

-- Tạo mảng giá trị để hiển thị trong dropdown
local rankValues = {}
for i = 1, 9 do
    table.insert(rankValues, rankMapping[i] .. " (Rank " .. i .. ")")
end

-- Biến để lưu trạng thái
local selectedRanks = {}
local autoSellEnabled = false

-- Cập nhật ConfigSystem để lưu các biến mới
ConfigSystem.DefaultConfig.SelectedRanks = {}
ConfigSystem.DefaultConfig.AutoSellEnabled = false

-- Dropdown để chọn Rank
Tabs.shop:AddDropdown("RankDropdown", {
    Title = "Choose Ranks",
    Values = rankValues,
    Multi = true,
    Default = ConfigSystem.CurrentConfig.SelectedRanks or {},
    Callback = function(selections)
        selectedRanks = {}
        -- Kiểm tra xem selections có phải là table hay không
        if type(selections) == "table" then
            for selection, isSelected in pairs(selections) do
                -- Chỉ xử lý các mục đã chọn (boolean = true)
                if isSelected == true then
                    -- Trích xuất số rank từ chuỗi (vd: từ "E (Rank 1)" lấy ra 1)
                    local rankStr = selection:match("Rank (%d+)")
                    if rankStr then
                        local rank = tonumber(rankStr)
                        if rank then
                            table.insert(selectedRanks, rank)
                        end
                    end
                end
            end
        end
        ConfigSystem.CurrentConfig.SelectedRanks = selections
        ConfigSystem.SaveConfig()
        print("Selected Ranks:", table.concat(selectedRanks, ", "))
    end
})

-- Hàm để bán pet theo rank
local function sellPetsByRank()
    local petFolder = player.leaderstats.Inventory:WaitForChild("Pets")
    local petsToSell = {}
    
    for _, pet in ipairs(petFolder:GetChildren()) do
        local rankVal = pet:GetAttribute("Rank")
        if typeof(rankVal) == "number" and table.find(selectedRanks, rankVal) then
            table.insert(petsToSell, pet.Name)
            
            -- Nếu đạt đủ 20 pet hoặc đây là pet cuối cùng, tiến hành bán
            if #petsToSell >= 20 then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "SellPet",
                            ["Pets"] = petsToSell
                        },
                        [2] = "\t"
                    }
                }
                remote:FireServer(unpack(args))
                print("Đã bán", #petsToSell, "pet với rank đã chọn")
                
                -- Đợi một khoảng thời gian ngắn để tránh spam
                task.wait(0.3)
                
                -- Đặt lại danh sách
                petsToSell = {}
            end
        end
    end
    
    -- Bán nốt những pet còn lại (nếu có)
    if #petsToSell > 0 then
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "SellPet",
                    ["Pets"] = petsToSell
                },
                [2] = "\t"
            }
        }
        remote:FireServer(unpack(args))
        print("Đã bán", #petsToSell, "pet còn lại với rank đã chọn")
    end
end

-- Nút để bán ngay
Tabs.shop:AddButton({
    Title = "Sell Now",
    Description = "Sell all pets with selected ranks immediately",
    Callback = function()
        if #selectedRanks > 0 then
            sellPetsByRank()
        else
            Fluent:Notify({
                Title = "Chưa chọn rank",
                Content = "Vui lòng chọn ít nhất một rank để bán pet",
                Duration = 3
            })
        end
    end
})

-- Toggle để bật/tắt Auto Sell
Tabs.shop:AddToggle("AutoSellToggle", {
    Title = "Auto Sell Pets",
    Default = ConfigSystem.CurrentConfig.AutoSellEnabled or false,
    Callback = function(state)
        autoSellEnabled = state
        ConfigSystem.CurrentConfig.AutoSellEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if #selectedRanks > 0 then
                Fluent:Notify({
                    Title = "Auto Sell đã bật",
                    Content = "Sẽ tự động bán pet với các rank: " .. table.concat(selectedRanks, ", "),
                    Duration = 3
                })
                
                task.spawn(function()
                    while autoSellEnabled do
                        sellPetsByRank()
                        task.wait(5) -- Đợi 5 giây giữa mỗi lần kiểm tra và bán
                    end
                end)
            else
                Fluent:Notify({
                    Title = "Chưa chọn rank",
                    Content = "Vui lòng chọn ít nhất một rank để bán pet",
                    Duration = 3
                })
            end
        end
    end
})

-- Continuando com o resto do script...
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = game:GetService("Players").LocalPlayerif not game or not game.GetService then
    warn("Ambiente do jogo não está disponível.")
    return
end
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local teleportEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local selectedMobName = ""
local movementMethod = "Tween" -- Método de movimento padrão
local farmingStyle = "Default" -- Estilo de farm padrão

-- Novo sistema de armazenamento
local ConfigSystem = {}
local HttpService = game:GetService("HttpService")
ConfigSystem.Folder = "Allan Hub"
ConfigSystem.SubFolder = "AriseCrossover"
ConfigSystem.FileName = player.Name .. "_Config.json"
ConfigSystem.FilePath = ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder .. "/" .. ConfigSystem.FileName
ConfigSystem.DefaultConfig = {
    SelectedMobName = "",
    FarmSelectedMob = false,
    AutoFarmNearestNPCs = false,
    MainAutoDestroy = false,
    MainAutoArise = false,
    FarmingMethod = "Tween",
    DamageMobs = false,
    SelectedShop = "",
    SelectedWeapon = "",
    AutoBuyEnabled = false,
    AutoScanEnabled = false,
    ScanDelay = 1,
    SelectedRanks = {},
    AutoSellEnabled = false
}
ConfigSystem.CurrentConfig = {}

-- Função para criar pastas se não existirem
ConfigSystem.CreateFolders = function()
    -- Testar diferentes métodos para criar pasta em vários executores
    local success = pcall(function()
        if makefolder then
            if not isfolder(ConfigSystem.Folder) then
                makefolder(ConfigSystem.Folder)
            end
            
            if not isfolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder) then
                makefolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder)
            end
        end
    end)
    
    return success
end

-- Função para salvar configuração (thử nhiều phương thức)
ConfigSystem.SaveConfig = function()
    -- Garantir que a pasta existe
    ConfigSystem.CreateFolders()
    
    -- Mã hóa cấu hình thành chuỗi JSON
    local jsonData = HttpService:JSONEncode(ConfigSystem.CurrentConfig)
    
    -- Testar diferentes métodos de salvar
    local success, err = pcall(function()
        -- Método 1: writefile trực tiếp (Synapse X, KRNL, Script-Ware)
        if writefile then
            writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 2: Usar SaveInstance (alguns outros executores)
        if saveinstance then
            saveinstance(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 3: Fluxus và alguns outros executores
        if fluxus and fluxus.save_file then
            fluxus.save_file(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 4: Delta và alguns outros executores
        if delta_config and delta_config.save then
            delta_config.save(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- Método 5: Codex
        if writefile and getrenv().writefile then
            getrenv().writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        return false
    end)
    
    if success then
        print("Configuração salva com sucesso em: " .. ConfigSystem.FilePath)
        return true
    else
        warn("Falha ao salvar configuração:", err)
        return false
    end
end

-- Função para carregar configuração (thử nhiều phương thức)
ConfigSystem.LoadConfig = function()
    -- Thử các phương thức đọc khác nhau
    local success, content = pcall(function()
        -- Método 1: readfile padrão (Synapse X, KRNL, Script-Ware)
        if readfile and isfile and isfile(ConfigSystem.FilePath) then
            return readfile(ConfigSystem.FilePath)
        end
        
        -- Método 2: Fluxus
        if fluxus and fluxus.read_file and fluxus.file_exists and fluxus.file_exists(ConfigSystem.FilePath) then
            return fluxus.read_file(ConfigSystem.FilePath)
        end
        
        -- Método 3: Delta
        if delta_config and delta_config.load and delta_config.exists and delta_config.exists(ConfigSystem.FilePath) then
            return delta_config.load(ConfigSystem.FilePath)
        end
        
        -- Método 4: Codex
        if readfile and getrenv().readfile and isfile and getrenv().isfile and getrenv().isfile(ConfigSystem.FilePath) then
            return getrenv().readfile(ConfigSystem.FilePath)
        end
        
        return nil
    end)
    
    if success and content then
        local data
        success, data = pcall(function()
            return HttpService:JSONDecode(content)
        end)
        
        if success and data then
        ConfigSystem.CurrentConfig = data
            print("Configuração carregada de: " .. ConfigSystem.FilePath)
        return true
    else
            warn("Erro ao analisar configuração, criando nova.")
        end
    end
    
    -- Se não conseguir ler ou ocorrer erro, criar configuração padrão
        ConfigSystem.CurrentConfig = table.clone(ConfigSystem.DefaultConfig)
        ConfigSystem.SaveConfig()
    print("Inicializando nova configuração")
        return false
    end

-- Criar um sistema de auto save separado
local function setupAutoSave()
    spawn(function()
        while wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                ConfigSystem.SaveConfig()
            end)
        end
    end)
end

-- Carregar configuração ao iniciar
ConfigSystem.LoadConfig()
setupAutoSave() -- Iniciando salvamento automático

-- Atualizar função para salvar imediatamente ao alterar valor
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then
            for _, element in pairs(tab._components) do
                if element and element.OnChanged then
                    element.OnChanged:Connect(function()
                        pcall(function()
                            ConfigSystem.SaveConfig()
                        end)
                    end)
                end
            end
        end
    end
end

-- Configurar SaveManager do Fluent para compatibilidade
local playerName = game:GetService("Players").LocalPlayer.Name
if InterfaceManager then
    InterfaceManager:SetFolder("Allan Hub")
end
if SaveManager then
    SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)
end

-- Detectar automaticamente novo HumanoidRootPart quando o jogador renascer
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
end)

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end

            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function getNearestSelectedEnemy()
    -- Se nenhum inimigo for encontrado em 5 segundos, atualizar lista
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 5 then
        killedNPCs = {} -- Redefinir lista de inimigos mortos
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time() -- Atualizar hora em que o inimigo foi encontrado
    end
    
    return nearestEnemy
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] then
            return enemy
        end
    end
    return nil
end

local function fireShowPetsRemote()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    remote:FireServer(unpack(args))
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
    elseif movementMethod == "Walk" then
        hrp.Parent:MoveTo(enemyHrp.Position)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.2)
    end
end

local function teleportDungeon()
    while teleportEnabled do
        local function getDistance(pos1, pos2)
            return (pos1 - pos2).Magnitude
        end

        local function getClosestEnemy()
            local closestEnemy = nil
            local closestDistance = math.huge
            local playerPosition = hrp.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local distance = getDistance(playerPosition, enemy.HumanoidRootPart.Position)
                    if distance < closestDistance then
                        closestDistance = distance
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            if enemy and enemy:FindFirstChild("HumanoidRootPart") then
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(hrp, tweenInfo, {
                    CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
                })
                tween:Play()
                tween.Completed:Wait()
            end
        end

        local enemy = getClosestEnemy()
        if enemy then
            moveToEnemy(enemy)
            while teleportEnabled and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 do
                task.wait(0.3)
            end
        else
            task.wait(1)
        end
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = getNearestSelectedEnemy()
        
        -- Se não encontrar alvo em 3 segundos, atualizar lista
        if not target and os.time() - lastResetTime > 3 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Lista de inimigos mortos foi atualizada")
        end
        
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()

            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.20)
    end
end

-- Farm Method Selection Dropdown
local Fluent
local SaveManager
local InterfaceManager

local success, err = pcall(function()
    Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
    SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
    InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
end)

if not success then
    warn("Erro ao carregar biblioteca Fluent: " .. tostring(err))
    -- Thử tải từ URL dự phòng
    pcall(function()
        Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Fluent.lua"))()
        SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
        InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
    end)
end

if not Fluent then
    error("Não foi possível carregar a biblioteca Fluent. Verifique sua conexão com a internet ou executor.")
    return
end

local Window = Fluent:CreateWindow({
    Title = "Allan Hub | Arise Crossover",
    SubTitle = "",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 350),
    Acrylic = false,
    Theme = "Luffy",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = {
    Discord = Window:AddTab({ Title = "INFO", Icon = ""}),
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    tp = Window:AddTab({ Title = "Teleports", Icon = "" }),
    mount = Window:AddTab({ Title = "Mount Location/farm", Icon = "" }),
    dungeon = Window:AddTab({ Title = "Dungeon ", Icon = "" }),
    shop = Window:AddTab({ Title = "Shop", Icon = "" }),
    Player = Window:AddTab({ Title = "Player", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" }),
}


-- Tạo mapping giữa các map và danh sách mob tương ứng
local mobsByWorld = {
    ["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
    ["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
    ["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
    ["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
    ["BCWorld"] = {"Sortudo", "Michille", "Wind"},
    ["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
    ["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
    ["DBWorld"] = {"Turtle", "Green", "Sky"},
    ["OPMWorld"] = {"Rider", "Cryborg", "Hurricane"}
}

local selectedWorld = "SoloWorld" -- Default world

-- Dropdown để chọn World/Map
Tabs.Main:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Values = {"SoloWorld", "NarutoWorld", "OPWorld", "BleachWorld", "BCWorld", "ChainsawWorld", "JojoWorld", "DBWorld", "OPMWorld"},
    Multi = false,
    Default = selectedWorld,
    Callback = function(world)
        selectedWorld = world
        ConfigSystem.CurrentConfig.SelectedWorld = world
        
        -- Cập nhật danh sách mob dựa trên world được chọn
        local mobDropdown = Fluent.Options.WorldMobDropdown
        if mobDropdown then
            mobDropdown:SetValues(mobsByWorld[world] or {})
            -- Đặt giá trị mặc định nếu có mob
            if #mobsByWorld[world] > 0 then
                selectedMobName = mobsByWorld[world][1]
                mobDropdown:SetValue(selectedMobName)
                ConfigSystem.CurrentConfig.SelectedMobName = selectedMobName
            else
                selectedMobName = ""
            end
        end
        
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de world
    end
})

-- Dropdown để chọn Mob trong world đã chọn
Tabs.Main:AddDropdown("WorldMobDropdown", {
    Title = "Select Enemy",
    Values = mobsByWorld[selectedWorld] or {},
    Multi = false,
    Default = mobsByWorld[selectedWorld] and mobsByWorld[selectedWorld][1] or "",
    Callback = function(mob)
        selectedMobName = mob
        ConfigSystem.CurrentConfig.SelectedMobName = mob
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de mob
        print("Selected Mob:", selectedMobName) -- Debug
    end
})

Tabs.Main:AddToggle("FarmSelectedMob", {
    Title = "Farm Selected Mob",
    Default = ConfigSystem.CurrentConfig.FarmSelectedMob or false,
    Callback = function(state)
        teleportEnabled = state
        damageEnabled = state -- Đảm bảo tính năng tấn công mobs được kích hoạt
        ConfigSystem.CurrentConfig.FarmSelectedMob = state
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao iniciar farm
        if state then
            task.spawn(teleportToSelectedEnemy)
        end
    end
})

Tabs.Main:AddToggle("TeleportMobs", {
    Title = "Auto farm (nearest NPCs)",
    Default = ConfigSystem.CurrentConfig.AutoFarmNearestNPCs or false,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmNearestNPCs = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(teleportAndTrackDeath)
        end
    end
})

local Dropdown = Tabs.Main:AddDropdown("MovementMethod", {
    Title = "Farming Method",
    Values = {"Tween", "Teleport"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.FarmingMethod == "Teleport" and 2 or 1,
    Callback = function(option)
        movementMethod = option
        ConfigSystem.CurrentConfig.FarmingMethod = option
        ConfigSystem.SaveConfig()
    end 
})

Tabs.Main:AddToggle("GamepassShadowFarm", {
    Title = "Shadow farm",
    Default = false,
    Callback = function(state)
        local attackatri = game:GetService("Players").LocalPlayer.Settings
        local atri = attackatri:GetAttribute("AutoAttack")
        
        if state then
            -- Bật tính năng
            if atri == false then
                attackatri:SetAttribute("AutoAttack", true)
            end
            print("Shadow farm ativado")
        else
            -- Tắt tính năng
            attackatri:SetAttribute("AutoAttack", false)
            print("Shadow farm desativado")
        end
    end
})

-- Adicionar toggle de Auto Attack
local autoAttackEnabled = false
local attackCooldown = 0.5

Tabs.Main:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack Mobs",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        
        if state then
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Ativado ataque automático a mobs",
                Duration = 3
            })
            
            -- Bắt đầu vòng lặp auto attack
            task.spawn(function()
                while autoAttackEnabled do
                    local targetEnemy
                    
                    -- Kiểm tra xem Farm Selected Mob có đang bật không
                    if ConfigSystem.CurrentConfig.FarmSelectedMob and selectedMobName ~= "" then
                        -- Nếu đang farm mob đã chọn, tìm mob đó
                        targetEnemy = getNearestSelectedEnemy()
                    else
                        -- Nếu không, tìm bất kỳ mob nào gần nhất
                        targetEnemy = getNearestEnemy()
                    end
                    
                    if targetEnemy then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "PunchAttack",
                                    ["Enemy"] = targetEnemy.Name
                                },
                                [2] = "\4"
                            }
                        }
                        remote:FireServer(unpack(args))
                    end
                    task.wait(attackCooldown) -- Chờ giữa các lần tấn công
                end
            end)
        else
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Desativado ataque automático a mobs",
                Duration = 3
            })
        end
    end
})

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tùy chọn, để đảm bảo điểm hồi sinh được thiết lập)
    task.wait(0.5)

    -- Hồi sinh nhân vật
    local player = game.Players.LocalPlayer
if player.Character and player.Character.Parent then
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0 -- Tạo ra cái chết tự nhiên mà không xóa nhân vật đột ngột
    end
end

end

local TweenService = game:GetService("TweenService")

-- Lấy Player và HumanoidRootPart
local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Cập nhật HRP khi nhân vật hồi sinh
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart") -- Lấy HRP mới sau khi hồi sinh
end)

-- Hàm di chuyển (Luôn sử dụng HRP mới nhất)
local function teleportWithTween(targetCFrame)
    if hrp then
        local tweenInfo = TweenInfo.new(
            2, -- Thời gian (giây)
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.Out,
            0, -- Không lặp lại
            false, -- Không đảo ngược
            0 -- Không độ trễ
        )

        local tweenGoal = {CFrame = targetCFrame}
        local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
        tween:Play()
    end
end


-- Locations List
local locations = {
    {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668, -0.41691944, -8.07482721e-08, 0.908943415, -2.94452178e-07, 1, -4.62235228e-08, -0.908943415, -2.86911842e-07, -0.41691944)},
    {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379, 0.836233854, -7.47273816e-08, -0.548372984, 2.59595481e-07, 1, 2.59595481e-07, 0.548372984, -3.59437678e-07, 0.836233854)},
    {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244, 0.8239398, -3.60997859e-07, -0.566677332, 2.59595453e-07, 1, -2.59595396e-07, 0.566677332, 6.67841249e-08, 0.8239398)},
    {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646, 0.978662074, 0.000114096198, -0.205476329, -0.000112703143, 1, 1.84834444e-05, 0.205476329, 5.06878177e-06, 0.978662074)},
    {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292, -0.999887109, -1.20863996e-12, 0.0150266131, -1.12492459e-12, 1, 5.57959278e-12, -0.0150266131, 5.56205906e-12, -0.999887109)},
    {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113, -0.534268856, -4.75206689e-05, 0.845314622, -7.48304665e-05, 1, 8.92103617e-06, -0.845314622, -5.84890549e-05, -0.534268856)},
    {Name = "Location 7", CFrame = CFrame.new(4325.36523, 118.995422, -4819.78857, -0.257801384, 3.98855832e-07, -0.966197908, -5.63039578e-07, 1, 5.63040146e-07, 0.966197908, 6.89160231e-07, -0.257801384)}
    
}

-- Add buttons for each location
for _, loc in ipairs(locations) do
    Tabs.mount:AddButton({
        Title = loc.Name,
        Callback = function()
            teleportWithTween(loc.CFrame)
        end
    })
end


local autoDestroy = false
local autoArise = false

-- Function to Fire DestroyPrompt
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")

local function fireDestroy()
    while autoDestroy do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local DestroyPrompt = rootPart and rootPart:FindFirstChild("DestroyPrompt")

                if DestroyPrompt then
                    DestroyPrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(DestroyPrompt)
                end
            end
        end
    end
end

-- Function to Fire ArisePrompt
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")

local function fireArise()
    while autoArise do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local arisePrompt = rootPart and rootPart:FindFirstChild("ArisePrompt")

                if arisePrompt then
                    arisePrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(arisePrompt)
                end
            end
        end
    end
end

-- Auto Destroy Toggle
Tabs.Main:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = ConfigSystem.CurrentConfig.MainAutoDestroy or false,
    Callback = function(state)
        autoDestroy = state
        ConfigSystem.CurrentConfig.MainAutoDestroy = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.Main:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = ConfigSystem.CurrentConfig.MainAutoArise or false,
    Callback = function(state)
        autoArise = state
        ConfigSystem.CurrentConfig.MainAutoArise = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireArise)
        end
    end
})

Tabs.dungeon:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = false,
    Flag = "DungeonAutoDestroy", -- Adicionar Flag para salvar configuração
    Callback = function(state)
        autoDestroy = state
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.dungeon:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = false,
    Flag = "DungeonAutoArise", -- Adicionar Flag para salvar configuração
    Callback = function(state)
        autoArise = state
        if state then
            task.spawn(fireArise)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local dungeonFolder = workspace:WaitForChild("__Main"):WaitForChild("__Dungeon")

-- Variable to control teleporting
local teleportingEnabled = false
-- Função para criar a dungeon
local function createDungeon()
    print("[DEBUG] Tentando criar dungeon...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("✓ Dungeon criada.")
    task.wait(3)

    -- Iniciar a dungeon
    local iniciarArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(iniciarArgs))
    print("▶ Dungeon iniciada.")
end

-- Function to start the dungeon (mantida como backup)
local function startDungeon()
    local dungeonInstance = dungeonFolder:FindFirstChild("Dungeon")
    if dungeonInstance then
        local dungeonID = dungeonInstance:GetAttribute("ID")
        if dungeonID then
            print("[DEBUG] Iniciando dungeon com ID:", dungeonID)
            local args = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = dungeonID,
                        ["Event"] = "DungeonAction",
                        ["Action"] = "Start"
                    },
                    [2] = "\n"
                }
            }
            ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("[DEBUG] Evento de início da Dungeon ativado!")
        else
            print("[LỖI] Não foi encontrado ID da Dungeon!")
        end
    else
        print("[LỖI] Não foi encontrada instância da Dungeon!")
    end
end

-- Function to teleport directly to an object and bypass anti-cheat
local function teleportToObject(object)
    if object and object:IsA("Part") then
        print("[DEBUG] Teleportando para:", object.Name)

        -- Bypass anti-cheat
        local f = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("FlyingFixer")
        if f then f:Destroy() else print("blablabla bleble") end

        local cha = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("CharacterUpdater")
        if cha then cha:Destroy() print("discord") else print("Cid") end

        -- Dịch chuyển trực tiếp
        hrp.CFrame = object.CFrame
        print("[DEBUG] Teleport concluído para:", object.Name)

        task.wait(2) -- Pequeno atraso após teleporte
        createDungeon() -- Kích hoạt remote tạo dungeon usando a função corrigida
    else
        print("[LỖI] Alvo de teleporte inválido!")
    end
end

-- Function to continuously teleport to objects when enabled
local function teleportLoop()
    while teleportingEnabled do
        print("[DEBUG] Procurando objetos de dungeon...")
        local foundObject = false
        for _, object in ipairs(dungeonFolder:GetChildren()) do
            if object:IsA("Part") then
                foundObject = true
                teleportToObject(object)
                task.wait(1) -- Evitar execução excessiva
            end
        end
        if not foundObject then
            print("[CẢNH BÁO] Nenhum objeto de dungeon válido encontrado!")
        end
        task.wait(0.5) -- Atraso antes de verificar novamente
    end
end

-- Add the toggle button to start/stop teleporting
Tabs.dungeon:AddToggle("TeleportToDungeon", {
    Title = "Teleport to Dungeon",
    Default = false,
    Callback = function(state)
        teleportingEnabled = state
        print("[DEBUG] Teleporte ativado/desativado:", state)
        if state then
            task.spawn(teleportLoop) -- Bắt đầu vòng lặp dịch chuyển khi bật
        end
    end
})

local AutoDetectToggle = Tabs.dungeon:AddToggle("AutoDetectDungeon", {Title = "Auto Detect Dungeon", Default = true})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local villageSpawns = {
    ["Grass Village"] = "NarutoWorld",
    ["BRUM ISLAND"] = "OPWorld",
    ["Leveling City"] = "SoloWorld",
    ["FACEHEAL TOWN"] = "BleachWorld",
    ["Lucky"] = "BCWorld",
    ["Nipon City"] = "ChainsawWorld",
    ["Mori Town"] = "JojoWorld",
    ["Dragon City"] = "DBWorld",
    ["XZ City"] = "OPMWorld",
}

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tùy chọn, để đảm bảo điểm hồi sinh được thiết lập)
    task.wait(0.5)

    -- Hồi sinh nhân vật
    if player.Character then
        player.Character:BreakJoints() -- Buộc nhân vật phải hồi sinh
    end
end

local function detectDungeon()
    player.PlayerGui.Warn.ChildAdded:Connect(function(dungeon)
        if dungeon:IsA("Frame") and AutoDetectToggle.Value then
            print("Dungeon detectada!")
            for _, child in ipairs(dungeon:GetChildren()) do
                if child:IsA("TextLabel") then
                    for village, spawnName in pairs(villageSpawns) do
                        if string.find(string.lower(child.Text), string.lower(village)) then
                            teleportEnabled = false
                            print("Vila detectada:", village)
                            SetSpawnAndReset(spawnName)
                            return
                        end
                    end
                end
            end
        end
    end)
end

-- Đảm bảo hàm hoạt động
AutoDetectToggle:OnChanged(function(value)
    if value then
        detectDungeon()
    end
end)

detectDungeon()

local function resetAutoFarm()
    -- Đặt lại tất cả trạng thái và hàm
    killedNPCs = {} -- Đặt lại số lượng NPC đã tiêu diệt

    print("AutoFarm foi reiniciado!") -- In thông báo xác nhận

    -- Khởi động lại tất cả các hàm nếu cần
end

task.spawn(function()
    while true do
        task.wait(120) -- Đợi 120 giây
        resetAutoFarm() -- Gọi hàm đặt lại
    end
end)

-- ==========================
-- NOVA SEÇÃO CASTLE INF CORRIGIDA (SUBSTITUI TODA A ANTERIOR)
-- ==========================

-- Config padrão para Castle
if ConfigSystem.DefaultConfig.CastleEntryFloor == nil then
    ConfigSystem.DefaultConfig.CastleEntryFloor = 1
end
if ConfigSystem.CurrentConfig.CastleEntryFloor == nil then
    ConfigSystem.CurrentConfig.CastleEntryFloor = ConfigSystem.DefaultConfig.CastleEntryFloor
end
local entryFloor = ConfigSystem.CurrentConfig.CastleEntryFloor

if ConfigSystem.DefaultConfig.CastleExitFloor == nil then
    ConfigSystem.DefaultConfig.CastleExitFloor = 101
end
if ConfigSystem.CurrentConfig.CastleExitFloor == nil then
    ConfigSystem.CurrentConfig.CastleExitFloor = ConfigSystem.DefaultConfig.CastleExitFloor
end
local exitFloor = ConfigSystem.CurrentConfig.CastleExitFloor

-- Variáveis de controle para Castle
local castleEnabled = false
local castleResetEnabled = false
local lastUsedFloor = nil
local floorCooldown = {}

-- Inputs para configuração de andares
Tabs.dungeon:AddInput("CastleEntryFloorNew", {
    Title = "Castle Entry Floor",
    Default = tostring(entryFloor),
    Placeholder = "Andar de entrada",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            entryFloor = floor
            ConfigSystem.CurrentConfig.CastleEntryFloor = floor
            ConfigSystem.SaveConfig()
            print("[Castle] Andar de entrada atualizado para:", floor)
        end
    end
})

Tabs.dungeon:AddInput("CastleExitFloorNew", {
    Title = "Castle Exit Floor", 
    Default = tostring(exitFloor),
    Placeholder = "Andar de saída",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            exitFloor = floor
            ConfigSystem.CurrentConfig.CastleExitFloor = floor
            ConfigSystem.SaveConfig()
            print("[Castle] Andar de saída atualizado para:", floor)
        end
    end
})

-- Funções Castle
local function buyCastleTicket()
    local args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "CastleAction", 
                ["Action"] = "BuyTicket"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Ticket comprado")
end

local function joinCastle(floor)
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(floor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Entrando no andar:", floor)
end

local function leaveCastle()
    local args = {
        [1] = {
            [1] = { ["Event"] = "LeaveDungeon" },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Saindo do castle")
end

local function resetCastleInside(floor)
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(floor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(args))
    print("[Castle] Reset interno para andar:", floor)
end

local function getCurrentFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end
    
    local current = nil
    for i = 1, 200 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end
    return current
end

-- Farm de mobs
local function getEnemies()
    local main = workspace:FindFirstChild("__Main")
    if not main then return {} end
    local enemiesFolder = main:FindFirstChild("__Enemies")
    if enemiesFolder and enemiesFolder:FindFirstChild("Server") then
        return enemiesFolder.Server:GetChildren()
    end
    return {}
end

local function enemiesAlive()
    for _, enemy in ipairs(getEnemies()) do
        local hp = enemy:GetAttribute("HP")
        if hp and hp > 0 then
            return true
        end
    end
    return false
end

-- FirePortal com voo melhorado
local function flyTo(targetPos)
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local speed = 60
    
    -- Criar BodyVelocity para voo suave
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.Parent = hrp
    
    while (castleEnabled or castleResetEnabled) do
        if not hrp.Parent then break end
        local dist = (hrp.Position - targetPos).Magnitude
        if dist < 10 then break end
        
        local dir = (targetPos - hrp.Position).Unit
        bodyVelocity.Velocity = dir * speed
        task.wait(0.1)
    end
    
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity:Destroy()
end

local function waitAndActivatePortal(floor)
    local main = workspace:FindFirstChild("__Main")
    if not main then return false end
    local world = main:FindFirstChild("__World")
    if not world then return false end
    
    local room = world:FindFirstChild("Room_" .. floor)
    if not room then return false end

    local portal
    -- Espera até 15s pelo FirePortal
    for i = 1, 150 do
        portal = room:FindFirstChild("FirePortal", true)
        if portal then break end
        task.wait(0.1)
    end

    if not portal then
        warn("[Castle] Nenhum FirePortal encontrado no andar " .. tostring(floor))
        return false
    end

    print("[Castle] Portal encontrado no andar " .. floor .. ", voando até ele...")
    
    -- Voa até o portal
    flyTo(portal.Position + Vector3.new(0, 5, 0))
    task.wait(0.5)

    -- Até 3 tentativas de ativar
    local prompt = portal:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        -- Procurar em descendentes
        for _, obj in ipairs(portal:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                prompt = obj
                break
            end
        end
    end
    
    for attempt = 1, 3 do
        if prompt then
            pcall(function() 
                fireproximityprompt(prompt)
            end)
            print(string.format("[Castle] Tentativa %d de ativar portal do andar %d", attempt, floor))
            task.wait(1.5)
            
            -- Verifica se subiu de andar
            if not world:FindFirstChild("Room_" .. floor) then
                print("[Castle] Subiu para o próximo andar!")
                return true
            end
        else
            warn("[Castle] ProximityPrompt não encontrado")
            break
        end
    end

    warn("[Castle] Não conseguiu ativar o portal no andar " .. tostring(floor))
    return false
end

-- Loop SAIR (modo original)
local function autoCastleLeave()
    task.spawn(function()
        print("[Castle] Iniciando modo AUTO CASTLE (sair)")
        while castleEnabled do
            pcall(function()
                local floor = getCurrentFloor()
                if not floor then
                    -- Fora do castle - comprar ticket e entrar
                    print("[Castle] Fora do castle, comprando ticket...")
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    print("[Castle] Andar atual:", floor)
                    if floor >= exitFloor then
                        print("[Castle] Atingiu andar de saída, saindo...")
                        leaveCastle()
                        task.wait(8)
                        -- Reiniciar ciclo
                        buyCastleTicket()
                        task.wait(1)
                        joinCastle(entryFloor)
                        task.wait(5)
                    else
                        -- Verificar se há inimigos vivos
                        if not enemiesAlive() then
                            print("[Castle] Nenhum inimigo vivo, tentando subir...")
                            waitAndActivatePortal(floor)
                            task.wait(2)
                        else
                            print("[Castle] Ainda há inimigos vivos, aguardando...")
                        end
                    end
                end
            end)
            task.wait(0.5)
        end
        print("[Castle] Loop AUTO CASTLE (sair) encerrado")
    end)
end

-- Loop RESET (modo novo)
local function autoCastleReset()
    task.spawn(function()
        print("[Castle] Iniciando modo AUTO CASTLE (reset interno)")
        while castleResetEnabled do
            pcall(function()
                local floor = getCurrentFloor()
                if not floor then
                    -- Fora do castle - comprar ticket e entrar
                    print("[Castle] Fora do castle, comprando ticket...")
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    print("[Castle] Andar atual:", floor)
                    if floor >= exitFloor then
                        print("[Castle] Atingiu andar de saída, fazendo reset interno...")
                        resetCastleInside(entryFloor)
                        task.wait(5)
                    else
                        -- Verificar se há inimigos vivos
                        if not enemiesAlive() then
                            print("[Castle] Nenhum inimigo vivo, tentando subir...")
                            waitAndActivatePortal(floor)
                            task.wait(2)
                        else
                            print("[Castle] Ainda há inimigos vivos, aguardando...")
                        end
                    end
                end
            end)
            task.wait(0.5)
        end
        print("[Castle] Loop AUTO CASTLE (reset interno) encerrado")
    end)
end

-- Seção Castle
local CastleSection = Tabs.dungeon:AddSection("Castle INF Functions")

-- Toggles para Castle
Tabs.dungeon:AddToggle("AutoCastleLeave", {
    Title = "Auto Castle INF (Sair)",
    Description = "Sai do castle quando atinge o andar alvo",
    Default = false,
    Callback = function(state)
        castleEnabled = state
        if state then
            -- Desativar o outro modo se estiver ativo
            castleResetEnabled = false
            
            Fluent:Notify({
                Title = "Auto Castle (Sair)",
                Content = string.format("Ativado - Entrada: %d, Saída: %d", entryFloor, exitFloor),
                Duration = 3
            })
            
            buyCastleTicket()
            task.wait(1)
            joinCastle(entryFloor)
            autoCastleLeave()
        else
            Fluent:Notify({
                Title = "Auto Castle (Sair)",
                Content = "Desativado",
                Duration = 3
            })
            pcall(function() leaveCastle() end)
        end
    end
})

Tabs.dungeon:AddToggle("AutoCastleReset", {
    Title = "Auto Castle INF (Reset)",
    Description = "Faz reset interno quando atinge o andar alvo",
    Default = false,
    Callback = function(state)
        castleResetEnabled = state
        if state then
            -- Desativar o outro modo se estiver ativo
            castleEnabled = false
            
            Fluent:Notify({
                Title = "Auto Castle (Reset)",
                Content = string.format("Ativado - Entrada: %d, Reset: %d", entryFloor, exitFloor),
                Duration = 3
            })
            
            buyCastleTicket()
            task.wait(1)
            joinCastle(entryFloor)
            autoCastleReset()
        else
            Fluent:Notify({
                Title = "Auto Castle (Reset)",
                Content = "Desativado", 
                Duration = 3
            })
            pcall(function() leaveCastle() end)
        end
    end
})

-- Botões auxiliares
Tabs.dungeon:AddButton({
    Title = "Show Current Floor",
    Description = "Mostra o andar atual do castle",
    Callback = function()
        local floor = getCurrentFloor()
        if floor then
            Fluent:Notify({
                Title = "Andar Atual",
                Content = "Você está no andar: " .. floor,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Fora do Castle",
                Content = "Você não está no castle no momento",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddButton({
    Title = "Manual Leave Castle",
    Description = "Sair manualmente do castle",
    Callback = function()
        leaveCastle()
        Fluent:Notify({
            Title = "Castle",
            Content = "Comando de saída enviado",
            Duration = 3
        })
    end
})

-- Continuar o resto do código...
local localPlayer = game:GetService("Players").LocalPlayer
