--[=[
    Script: Allan Hub - Arise (FIXED + Fly System Upgrade)
    Descri√ß√£o: Vers√£o corrigida do script de auto dungeon com um sistema
               de voo aprimorado para ca√ßar mobs de forma mais eficiente.
    Data da Atualiza√ß√£o: 19/08/2025
--]=]

-- ===== Servi√ßos e Vari√°veis Globais =====
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Vari√°veis de controle de estado
local ativarEvento = false
local ativarDungeon = false
local ativarGems = false
local ativarFly = false
local andarEntrada = 10
local andarSaida = 1
local currentFloor = 0
local dungeonActive = false

-- Vari√°veis para o sistema de voo
local currentTween = nil
local flyConnection = nil

-- Nomes de arquivos de configura√ß√£o
local configFile = "allan_hub_castelo.json"
local tempFile = "temp_dungeon.json"

-- Configura√ß√µes de Voo
local FLIGHT_SPEED = 500 -- Velocidade de voo
local FLIGHT_HEIGHT = 5 -- Altura acima do mob ao voar

-- ===== Fun√ß√µes de Arquivo =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Fun√ß√µes de Configura√ß√£o (Salvar/Carregar) =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        fly = ativarFly, dungeonActive = dungeonActive
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local success, data = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end)
        if success and type(data) == "table" then
            andarEntrada = tonumber(data.entrada) or andarEntrada
            andarSaida = tonumber(data.saida) or andarSaida
            ativarEvento = data.evento or false
            ativarDungeon = data.dungeon or false
            ativarGems = data.gems or false
            ativarFly = data.fly or false
            dungeonActive = data.dungeonActive or false
        else
            salvarConfig() -- Cria um novo arquivo se o antigo estiver corrompido
        end
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Fun√ß√µes de Verifica√ß√£o de Estado =====
local function isInDungeon()
    return workspace:FindFirstChild("__Enemies") or workspace:FindFirstChild("Dungeon")
end

local function mobsVivos()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                print("üéØ Mob vivo encontrado, iniciando combate.")
                return true
            end
        end
    end
    return false
end

-- ===== A√ß√µes da Dungeon =====
local function entrarCastelo()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = { [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local function sairCastelo()
    print("üö™ Saindo do castelo")
    local args = { [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local function iniciarDungeon()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local function criarDungeon()
    if dungeonActive then print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o."); return end
    if isInDungeon() then print("‚ö†Ô∏è J√° est√° em uma dungeon."); dungeonActive = true; salvarConfig(); return end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5)
    iniciarDungeon()
end

local function resetarDungeon()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

---------------------------------------------------------------------
--- NOVA SE√á√ÉO DE VOO (Integrada do primeiro script) ---
---------------------------------------------------------------------

-- Fun√ß√£o para ativar o voo
local function enableFlight()
    if flyConnection then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    flyConnection = bodyVelocity
end

-- Fun√ß√£o para desativar o voo
local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

-- Fun√ß√£o para voar at√© uma posi√ß√£o usando Tween
local function flyToPosition(targetPosition)
    enableFlight()
    
    if currentTween then currentTween:Cancel(); currentTween = nil; end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    
    print("‚úàÔ∏è Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    return currentTween
end

-- Verifica se uma posi√ß√£o j√° foi visitada recentemente para n√£o ficar preso
local function isPositionVisited(position, visitedPositions)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

-- Adiciona uma posi√ß√£o √† lista de visitadas
local function addVisitedPosition(position, visitedPositions)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

-- Encontra o mob mais pr√≥ximo que ainda n√£o foi visitado
local function getClosestUnvisitedMob(visitedPositions)
    local closestMob, shortestDistance = nil, math.huge
    local allMobs = {}
    local maxDistance = 50000 -- Dist√¢ncia m√°xima de busca
    local enemiesFolder = workspace:FindFirstChild("__Enemies")
    if not enemiesFolder then return nil end

    -- Coleta todos os mobs vivos no alcance
    for _, mobFolder in ipairs(enemiesFolder:GetChildren()) do
        if mobFolder:IsA("Model") then
            local mobHRP = mobFolder:FindFirstChild("HumanoidRootPart")
            local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
            if mobHRP and humanoid and humanoid.Health > 0 then
                local dist = (hrp.Position - mobHRP.Position).Magnitude
                if dist <= maxDistance then
                    table.insert(allMobs, {mob = mobHRP, distance = dist})
                end
            end
        end
    end

    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        if not isPositionVisited(mobData.mob.Position, visitedPositions) then
            if mobData.distance < shortestDistance then
                shortestDistance = mobData.distance
                closestMob = mobData.mob
            end
        end
    end
    
    -- Se n√£o encontrar mobs n√£o visitados, limpa a lista e pega o mais pr√≥ximo de todos
    if not closestMob and #allMobs > 0 then
        print("üîç Nenhum mob novo encontrado. Resetando lista de visitados.")
        for i = #visitedPositions, 1, -1 do table.remove(visitedPositions, i) end
        
        for _, mobData in pairs(allMobs) do
            if mobData.distance < shortestDistance then
                shortestDistance = mobData.distance
                closestMob = mobData.mob
            end
        end
    end
    
    if closestMob then
        print("üéØ Mobs encontrados:", #allMobs, "| Pr√≥ximo alvo a", math.floor(shortestDistance), "metros.")
    end
    return closestMob
end

---------------------------------------------------------------------
--- FIM DA SE√á√ÉO DE VOO ---
---------------------------------------------------------------------

-- ===== Fun√ß√µes de Combate =====
local function teleportToNearestMob()
    local root = char:FindFirstChild("HumanoidRootPart")
    local folder = workspace:FindFirstChild("__Enemies")
    if not root or not folder then return false end

    local closest, bestDistance = nil, math.huge
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            local mobHrp = mob:FindFirstChild("HumanoidRootPart")
            if humanoid and mobHrp and humanoid.Health > 0 then
                local distance = (root.Position - mobHrp.Position).Magnitude
                if distance < bestDistance then
                    bestDistance = distance
                    closest = mobHrp
                end
            end
        end
    end
    
    if closest then
        root.CFrame = closest.CFrame * CFrame.new(0, 0, 5)
        print("üìç Teleportado para mob mais pr√≥ximo")
        return true
    end
    return false
end

local function atacarInimigos()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    if attacked > 0 then print("‚öîÔ∏è Atacou", attacked, "inimigos") end
    return attacked
end

-- ===== Fun√ß√£o Principal de Combate (com voo integrado) =====
local function solarDungeon()
    print("üåü Iniciando combate na dungeon...")
    
    local waitStart = tick()
    while tick() - waitStart < 30 and not mobsVivos() do
        print("‚è≥ Aguardando mobs aparecerem...")
        task.wait(2)
    end
    
    if not mobsVivos() then print("‚ùå Nenhum mob encontrado ap√≥s 30 segundos."); return; end

    local combatStart = tick()
    -- Vari√°veis locais para o ciclo de combate
    local visitedPositions, currentTarget = {}, nil
    local stuckCounter = 0

    if ativarFly then enableFlight() end

    while mobsVivos() and tick() - combatStart < 300 do -- Timeout de 5 minutos
        if ativarFly then
            local mob = getClosestUnvisitedMob(visitedPositions)
            
            if mob and mob.Parent then
                if currentTarget and currentTarget == mob then
                    stuckCounter += 1
                    if stuckCounter > 3 then
                        print("‚ö†Ô∏è Parece que estou preso no mesmo mob. Adicionando √† lista de visitados.")
                        addVisitedPosition(mob.Position, visitedPositions)
                        stuckCounter = 0
                        currentTarget = nil
                        task.wait(1)
                        continue
                    end
                else
                    stuckCounter = 0
                    currentTarget = mob
                end
                
                local flyTween = flyToPosition(mob.Position)
                local startTime = tick()
                
                repeat
                    task.wait(0.1)
                    if not mob.Parent then break end
                    if (hrp.Position - mob.Position).Magnitude < 15 then break end
                until (tick() - startTime) > 10 or flyTween.PlaybackState == Enum.PlaybackState.Completed
                
                if currentTween then currentTween:Cancel(); currentTween = nil; end
                
                print("‚úÖ Chegou pr√≥ximo ao mob!")
                atacarInimigos()
                task.wait(0.5)
                addVisitedPosition(mob.Position, visitedPositions)
                
            else
                print("ü§∑ Nenhum mob encontrado para voar. Parando ciclo de voo.")
                break
            end
        else -- Modo Teleporte (padr√£o)
            teleportToNearestMob()
            task.wait(0.5)
            atacarInimigos()
            task.wait(1)
        end
    end
    
    if ativarFly then disableFlight() end

    if mobsVivos() then print("‚è∞ Timeout no combate ap√≥s 5 minutos.")
    else print("üéâ Todos os mobs foram derrotados!") end
end

-- ===== Loop Principal =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5)
        
        if not isInDungeon() and not dungeonActive then
            print("üèóÔ∏è Preparando para criar dungeon...")
            if ativarEvento then entrarCastelo(); task.wait(5); end
            criarDungeon()
            task.wait(8)
        end

        if isInDungeon() then
            print("üéÆ Executando dungeon...")
            solarDungeon()
            task.wait(3)
            
            if ativarGems then
                resetarDungeon()
            else
                sairCastelo()
                task.wait(5)
                if ativarEvento then entrarCastelo() end
            end
            task.wait(5)
        end
    end
    
    print("üõë Loop de auto dungeon parado")
end

-- ===== Interface Gr√°fica (GUI) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED + Fly)",
    SubTitle = "Dungeon Autom√°tica com Voo Aprimorado",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 420),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })

-- Painel de Status
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

task.spawn(function()
    while task.wait(2) do
        local statusContent = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
‚úàÔ∏è Auto Fly: %s
]], 
            ativarEvento and "‚úÖ" or "‚ùå",
            isInDungeon() and "‚úÖ" or "‚ùå", 
            mobsVivos() and "‚úÖ" or "‚ùå", 
            dungeonActive and "‚úÖ" or "‚ùå",
            ativarDungeon and "‚úÖ" or "‚ùå",
            ativarFly and "‚úÖ" or "‚ùå"
        )
        statusParagraph:SetDesc(statusContent)
    end
end)

-- Controles na Aba Principal
local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Cria/Inicia/Reseta automaticamente",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then task.spawn(autoDungeonLoop) end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

t:AddToggle("ToggleAutoFly", {
    Title = "Auto Fly to Mobs",
    Description = "Voa at√© os mobs em vez de teleportar durante o combate",
    Default = ativarFly,
    Callback = function(state) ativarFly = state; salvarConfig() end
})

t:AddButton({
    Title = "üîÑ Reset Dungeon Status",
    Description = "Limpa flags de dungeon se algo der errado",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("üîÑ Status da dungeon resetado!")
    end
})

-- Bot√£o Flutuante para Abrir/Fechar GUI
local floatingGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
floatingGui.Name = "AllanHubFloating"
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton", floatingGui)
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
toggleButton.Text = "üîº"
toggleButton.TextScaled = true
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    Window.Visible = hubVisivel
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Monitoramento do andar do jogador
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üè¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Inicializa√ß√£o Autom√°tica
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("‚úÖ Allan Hub (Voo Aprimorado) carregado com sucesso!")
