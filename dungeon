if not game or not game.GetService then
    warn("Ambiente do jogo nÃ£o estÃ¡ disponÃ­vel.")
    return
end
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local teleportEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local selectedMobName = ""
local movementMethod = "Tween" -- MÃ©todo de movimento padrÃ£o
local farmingStyle = "Default" -- Estilo de farm padrÃ£o

-- Novo sistema de armazenamento
local ConfigSystem = {}
local HttpService = game:GetService("HttpService")
ConfigSystem.Folder = "Allan Hub"
ConfigSystem.SubFolder = "AriseCrossover"
ConfigSystem.FileName = player.Name .. "_Config.json"
ConfigSystem.FilePath = ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder .. "/" .. ConfigSystem.FileName
ConfigSystem.DefaultConfig = {
    SelectedMobName = "",
    FarmSelectedMob = false,
    AutoFarmNearestNPCs = false,
    MainAutoDestroy = false,
    MainAutoArise = false,
    FarmingMethod = "Tween",
    DamageMobs = false,
    SelectedShop = "",
    SelectedWeapon = "",
    AutoBuyEnabled = false,
    AutoScanEnabled = false,
    ScanDelay = 1,
    SelectedRanks = {},
    AutoSellEnabled = false
}
ConfigSystem.CurrentConfig = {}

-- FunÃ§Ã£o para criar pastas se nÃ£o existirem
ConfigSystem.CreateFolders = function()
    -- Testar diferentes mÃ©todos para criar pasta em vÃ¡rios executores
    local success = pcall(function()
        if makefolder then
            if not isfolder(ConfigSystem.Folder) then
                makefolder(ConfigSystem.Folder)
            end
            
            if not isfolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder) then
                makefolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder)
            end
        end
    end)
    
    return success
end

-- FunÃ§Ã£o para salvar configuraÃ§Ã£o (thá»­ nhiá»u phÆ°Æ¡ng thá»©c)
ConfigSystem.SaveConfig = function()
    -- Garantir que a pasta existe
    ConfigSystem.CreateFolders()
    
    -- MÃ£ hÃ³a cáº¥u hÃ¬nh thÃ nh chuá»—i JSON
    local jsonData = HttpService:JSONEncode(ConfigSystem.CurrentConfig)
    
    -- Testar diferentes mÃ©todos de salvar
    local success, err = pcall(function()
        -- MÃ©todo 1: writefile trá»±c tiáº¿p (Synapse X, KRNL, Script-Ware)
        if writefile then
            writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- MÃ©todo 2: Usar SaveInstance (alguns outros executores)
        if saveinstance then
            saveinstance(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- MÃ©todo 3: Fluxus vÃ  alguns outros executores
        if fluxus and fluxus.save_file then
            fluxus.save_file(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- MÃ©todo 4: Delta vÃ  alguns outros executores
        if delta_config and delta_config.save then
            delta_config.save(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- MÃ©todo 5: Codex
        if writefile and getrenv().writefile then
            getrenv().writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        return false
    end)
    
    if success then
        print("ConfiguraÃ§Ã£o salva com sucesso em: " .. ConfigSystem.FilePath)
        return true
    else
        warn("Falha ao salvar configuraÃ§Ã£o:", err)
        return false
    end
end

-- FunÃ§Ã£o para carregar configuraÃ§Ã£o (thá»­ nhiá»u phÆ°Æ¡ng thá»©c)
ConfigSystem.LoadConfig = function()
    -- Thá»­ cÃ¡c phÆ°Æ¡ng thá»©c Ä‘á»c khÃ¡c nhau
    local success, content = pcall(function()
        -- MÃ©todo 1: readfile padrÃ£o (Synapse X, KRNL, Script-Ware)
        if readfile and isfile and isfile(ConfigSystem.FilePath) then
            return readfile(ConfigSystem.FilePath)
        end
        
        -- MÃ©todo 2: Fluxus
        if fluxus and fluxus.read_file and fluxus.file_exists and fluxus.file_exists(ConfigSystem.FilePath) then
            return fluxus.read_file(ConfigSystem.FilePath)
        end
        
        -- MÃ©todo 3: Delta
        if delta_config and delta_config.load and delta_config.exists and delta_config.exists(ConfigSystem.FilePath) then
            return delta_config.load(ConfigSystem.FilePath)
        end
        
        -- MÃ©todo 4: Codex
        if readfile and getrenv().readfile and isfile and getrenv().isfile and getrenv().isfile(ConfigSystem.FilePath) then
            return getrenv().readfile(ConfigSystem.FilePath)
        end
        
        return nil
    end)
    
    if success and content then
        local data
        success, data = pcall(function()
            return HttpService:JSONDecode(content)
        end)
        
        if success and data then
        ConfigSystem.CurrentConfig = data
            print("ConfiguraÃ§Ã£o carregada de: " .. ConfigSystem.FilePath)
        return true
    else
            warn("Erro ao analisar configuraÃ§Ã£o, criando nova.")
        end
    end
    
    -- Se nÃ£o conseguir ler ou ocorrer erro, criar configuraÃ§Ã£o padrÃ£o
        ConfigSystem.CurrentConfig = table.clone(ConfigSystem.DefaultConfig)
        ConfigSystem.SaveConfig()
    print("Inicializando nova configuraÃ§Ã£o")
        return false
    end

-- Criar um sistema de auto save separado
local function setupAutoSave()
    spawn(function()
        while wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                ConfigSystem.SaveConfig()
            end)
        end
    end)
end

-- Carregar configuraÃ§Ã£o ao iniciar
ConfigSystem.LoadConfig()
setupAutoSave() -- Iniciando salvamento automÃ¡tico

-- Atualizar funÃ§Ã£o para salvar imediatamente ao alterar valor
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then
            for _, element in pairs(tab._components) do
                if element and element.OnChanged then
                    element.OnChanged:Connect(function()
                        pcall(function()
                            ConfigSystem.SaveConfig()
                        end)
                    end)
                end
            end
        end
    end
end

-- Configurar SaveManager do Fluent para compatibilidade
local playerName = game:GetService("Players").LocalPlayer.Name
if InterfaceManager then
    InterfaceManager:SetFolder("Allan Hub")
end
if SaveManager then
    SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)
end

-- Detectar automaticamente novo HumanoidRootPart quando o jogador renascer
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
end)

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end

            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function getNearestSelectedEnemy()
    -- Se nenhum inimigo for encontrado em 5 segundos, atualizar lista
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 5 then
        killedNPCs = {} -- Redefinir lista de inimigos mortos
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time() -- Atualizar hora em que o inimigo foi encontrado
    end
    
    return nearestEnemy
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] then
            return enemy
        end
    end
    return nil
end

local function fireShowPetsRemote()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    remote:FireServer(unpack(args))
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
    elseif movementMethod == "Walk" then
        hrp.Parent:MoveTo(enemyHrp.Position)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.2)
    end
end

local function teleportDungeon()
    while teleportEnabled do
        local function getDistance(pos1, pos2)
            return (pos1 - pos2).Magnitude
        end

        local function getClosestEnemy()
            local closestEnemy = nil
            local closestDistance = math.huge
            local playerPosition = hrp.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local distance = getDistance(playerPosition, enemy.HumanoidRootPart.Position)
                    if distance < closestDistance then
                        closestDistance = distance
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            if enemy and enemy:FindFirstChild("HumanoidRootPart") then
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(hrp, tweenInfo, {
                    CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
                })
                tween:Play()
                tween.Completed:Wait()
            end
        end

        local enemy = getClosestEnemy()
        if enemy then
            moveToEnemy(enemy)
            while teleportEnabled and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 do
                task.wait(0.3)
            end
        else
            task.wait(1)
        end
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = getNearestSelectedEnemy()
        
        -- Se nÃ£o encontrar alvo em 3 segundos, atualizar lista
        if not target and os.time() - lastResetTime > 3 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Lista de inimigos mortos foi atualizada")
        end
        
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()

            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.20)
    end
end

-- Farm Method Selection Dropdown
local Fluent
local SaveManager
local InterfaceManager

local success, err = pcall(function()
    Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
    SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
    InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
end)

if not success then
    warn("Erro ao carregar biblioteca Fluent: " .. tostring(err))
    -- Thá»­ táº£i tá»« URL dá»± phÃ²ng
    pcall(function()
        Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Fluent.lua"))()
        SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
        InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
    end)
end

if not Fluent then
    error("NÃ£o foi possÃ­vel carregar a biblioteca Fluent. Verifique sua conexÃ£o com a internet ou executor.")
    return
end

local Window = Fluent:CreateWindow({
    Title = "Allan Hub | Arise Crossover",
    SubTitle = "",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 350),
    Acrylic = false,
    Theme = "Luffy",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = {
    Discord = Window:AddTab({ Title = "INFO", Icon = ""}),
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    tp = Window:AddTab({ Title = "Teleports", Icon = "" }),
    mount = Window:AddTab({ Title = "Mount Location/farm", Icon = "" }),
    dungeon = Window:AddTab({ Title = "Dungeon ", Icon = "" }),
    shop = Window:AddTab({ Title = "Shop", Icon = "" }),
    Player = Window:AddTab({ Title = "Player", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" }),
castle = Window:AddTab({ Title = "ðŸ° Castelo Infinito", Icon = "shield" })
}
-- Táº¡o mapping giá»¯a cÃ¡c map vÃ  danh sÃ¡ch mob tÆ°Æ¡ng á»©ng
local mobsByWorld = {
    ["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
    ["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
    ["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
    ["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
    ["BCWorld"] = {"Sortudo", "Michille", "Wind"},
    ["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
    ["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
    ["DBWorld"] = {"Turtle", "Green", "Sky"},
    ["OPMWorld"] = {"Rider", "Cryborg", "Hurricane"}
}

local selectedWorld = "SoloWorld" -- Default world

-- Dropdown Ä‘á»ƒ chá»n World/Map
Tabs.Main:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Values = {"SoloWorld", "NarutoWorld", "OPWorld", "BleachWorld", "BCWorld", "ChainsawWorld", "JojoWorld", "DBWorld", "OPMWorld"},
    Multi = false,
    Default = selectedWorld,
    Callback = function(world)
        selectedWorld = world
        ConfigSystem.CurrentConfig.SelectedWorld = world
        
        -- Cáº­p nháº­t danh sÃ¡ch mob dá»±a trÃªn world Ä‘Æ°á»£c chá»n
        local mobDropdown = Fluent.Options.WorldMobDropdown
        if mobDropdown then
            mobDropdown:SetValues(mobsByWorld[world] or {})
            -- Äáº·t giÃ¡ trá»‹ máº·c Ä‘á»‹nh náº¿u cÃ³ mob
            if #mobsByWorld[world] > 0 then
                selectedMobName = mobsByWorld[world][1]
                mobDropdown:SetValue(selectedMobName)
                ConfigSystem.CurrentConfig.SelectedMobName = selectedMobName
            else
                selectedMobName = ""
            end
        end
        
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de world
    end
})

-- Dropdown Ä‘á»ƒ chá»n Mob trong world Ä‘Ã£ chá»n
Tabs.Main:AddDropdown("WorldMobDropdown", {
    Title = "Select Enemy",
    Values = mobsByWorld[selectedWorld] or {},
    Multi = false,
    Default = mobsByWorld[selectedWorld] and mobsByWorld[selectedWorld][1] or "",
    Callback = function(mob)
        selectedMobName = mob
        ConfigSystem.CurrentConfig.SelectedMobName = mob
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de mob
        print("Selected Mob:", selectedMobName) -- Debug
    end
})

Tabs.Main:AddToggle("FarmSelectedMob", {
    Title = "Farm Selected Mob",
    Default = ConfigSystem.CurrentConfig.FarmSelectedMob or false,
    Callback = function(state)
        teleportEnabled = state
        damageEnabled = state -- Äáº£m báº£o tÃ­nh nÄƒng táº¥n cÃ´ng mobs Ä‘Æ°á»£c kÃ­ch hoáº¡t
        ConfigSystem.CurrentConfig.FarmSelectedMob = state
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao iniciar farm
        if state then
            task.spawn(teleportToSelectedEnemy)
        end
    end
})

Tabs.Main:AddToggle("TeleportMobs", {
    Title = "Auto farm (nearest NPCs)",
    Default = ConfigSystem.CurrentConfig.AutoFarmNearestNPCs or false,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmNearestNPCs = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(teleportAndTrackDeath)
        end
    end
})

local Dropdown = Tabs.Main:AddDropdown("MovementMethod", {
    Title = "Farming Method",
    Values = {"Tween", "Teleport"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.FarmingMethod == "Teleport" and 2 or 1,
    Callback = function(option)
        movementMethod = option
        ConfigSystem.CurrentConfig.FarmingMethod = option
        ConfigSystem.SaveConfig()
    end 
})

Tabs.Main:AddToggle("GamepassShadowFarm", {
    Title = "Shadow farm",
    Default = false,
    Callback = function(state)
        local attackatri = game:GetService("Players").LocalPlayer.Settings
        local atri = attackatri:GetAttribute("AutoAttack")
        
        if state then
            -- Báº­t tÃ­nh nÄƒng
            if atri == false then
                attackatri:SetAttribute("AutoAttack", true)
            end
            print("Shadow farm ativado")
        else
            -- Táº¯t tÃ­nh nÄƒng
            attackatri:SetAttribute("AutoAttack", false)
            print("Shadow farm desativado")
        end
    end
})

-- Adicionar toggle de Auto Attack
local autoAttackEnabled = false
local attackCooldown = 0.5

Tabs.Main:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack Mobs",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        
        if state then
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Ativado ataque automÃ¡tico a mobs",
                Duration = 3
            })
            
            -- Báº¯t Ä‘áº§u vÃ²ng láº·p auto attack
            task.spawn(function()
                while autoAttackEnabled do
                    local targetEnemy
                    
                    -- Kiá»ƒm tra xem Farm Selected Mob cÃ³ Ä‘ang báº­t khÃ´ng
                    if ConfigSystem.CurrentConfig.FarmSelectedMob and selectedMobName ~= "" then
                        -- Náº¿u Ä‘ang farm mob Ä‘Ã£ chá»n, tÃ¬m mob Ä‘Ã³
                        targetEnemy = getNearestSelectedEnemy()
                    else
                        -- Náº¿u khÃ´ng, tÃ¬m báº¥t ká»³ mob nÃ o gáº§n nháº¥t
                        targetEnemy = getNearestEnemy()
                    end
                    
                    if targetEnemy then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "PunchAttack",
                                    ["Enemy"] = targetEnemy.Name
                                },
                                [2] = "\4"
                            }
                        }
                        remote:FireServer(unpack(args))
                    end
                    task.wait(attackCooldown) -- Chá» giá»¯a cÃ¡c láº§n táº¥n cÃ´ng
                end
            end)
        else
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Desativado ataque automÃ¡tico a mobs",
                Duration = 3
            })
        end
    end
})

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tÃ¹y chá»n, Ä‘á»ƒ Ä‘áº£m báº£o Ä‘iá»ƒm há»“i sinh Ä‘Æ°á»£c thiáº¿t láº­p)
    task.wait(0.5)

    -- Há»“i sinh nhÃ¢n váº­t
    local player = game.Players.LocalPlayer
if player.Character and player.Character.Parent then
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0 -- Táº¡o ra cÃ¡i cháº¿t tá»± nhiÃªn mÃ  khÃ´ng xÃ³a nhÃ¢n váº­t Ä‘á»™t ngá»™t
    end
end

end

Tabs.tp:AddButton({
    Title = "Leveling City",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("SoloWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Grass Village",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("NarutoWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Brum Island",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("OPWorld") -- Alterar para o nome correto do ponto de spawn
    end
})

Tabs.tp:AddButton({
    Title = "Faceheal Town",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("BleachWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Lucky Kingdom",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("BCWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Nipon City",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("ChainsawWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Mori Town",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("JojoWorld")
    end
})

Tabs.tp:AddButton({
    Title = "Dragon City",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("DBWorld")
    end
})

Tabs.tp:AddButton({
    Title = "XZ City",
    Description = "Set spawn & reset",
    Callback = function()
        SetSpawnAndReset("OPMWorld")
    end
})

local TweenService = game:GetService("TweenService")

-- Láº¥y Player vÃ  HumanoidRootPart
local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Cáº­p nháº­t HRP khi nhÃ¢n váº­t há»“i sinh
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart") -- Láº¥y HRP má»›i sau khi há»“i sinh
end)

-- HÃ m di chuyá»ƒn (LuÃ´n sá»­ dá»¥ng HRP má»›i nháº¥t)
local function teleportWithTween(targetCFrame)
    if hrp then
        local tweenInfo = TweenInfo.new(
            2, -- Thá»i gian (giÃ¢y)
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.Out,
            0, -- KhÃ´ng láº·p láº¡i
            false, -- KhÃ´ng Ä‘áº£o ngÆ°á»£c
            0 -- KhÃ´ng Ä‘á»™ trá»…
        )

        local tweenGoal = {CFrame = targetCFrame}
        local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
        tween:Play()
    end
end


-- Locations List
local locations = {
    {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668, -0.41691944, -8.07482721e-08, 0.908943415, -2.94452178e-07, 1, -4.62235228e-08, -0.908943415, -2.86911842e-07, -0.41691944)},
    {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379, 0.836233854, -7.47273816e-08, -0.548372984, 2.59595481e-07, 1, 2.59595481e-07, 0.548372984, -3.59437678e-07, 0.836233854)},
    {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244, 0.8239398, -3.60997859e-07, -0.566677332, 2.59595453e-07, 1, -2.59595396e-07, 0.566677332, 6.67841249e-08, 0.8239398)},
    {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646, 0.978662074, 0.000114096198, -0.205476329, -0.000112703143, 1, 1.84834444e-05, 0.205476329, 5.06878177e-06, 0.978662074)},
    {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292, -0.999887109, -1.20863996e-12, 0.0150266131, -1.12492459e-12, 1, 5.57959278e-12, -0.0150266131, 5.56205906e-12, -0.999887109)},
    {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113, -0.534268856, -4.75206689e-05, 0.845314622, -7.48304665e-05, 1, 8.92103617e-06, -0.845314622, -5.84890549e-05, -0.534268856)},
    {Name = "Location 7", CFrame = CFrame.new(4325.36523, 118.995422, -4819.78857, -0.257801384, 3.98855832e-07, -0.966197908, -5.63039578e-07, 1, 5.63040146e-07, 0.966197908, 6.89160231e-07, -0.257801384)}
    
    
}

-- Add buttons for each location
for _, loc in ipairs(locations) do
    Tabs.mount:AddButton({
        Title = loc.Name,
        Callback = function()
            teleportWithTween(loc.CFrame)
        end
    })
end


local autoDestroy = false
local autoArise = false

-- Function to Fire DestroyPrompt


local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")


local function fireDestroy()
    while autoDestroy do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local DestroyPrompt = rootPart and rootPart:FindFirstChild("DestroyPrompt")

                if DestroyPrompt then
                    DestroyPrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(DestroyPrompt)
                end
            end
        end
    end
end



-- Function to Fire ArisePrompt

local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")


local function fireArise()
    while autoArise do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local arisePrompt = rootPart and rootPart:FindFirstChild("ArisePrompt")

                if arisePrompt then
                    arisePrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(arisePrompt)
                end
            end
        end
    end
end


-- Auto Destroy Toggle
Tabs.Main:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = ConfigSystem.CurrentConfig.MainAutoDestroy or false,
    Callback = function(state)
        autoDestroy = state
        ConfigSystem.CurrentConfig.MainAutoDestroy = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.Main:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = ConfigSystem.CurrentConfig.MainAutoArise or false,
    Callback = function(state)
        autoArise = state
        ConfigSystem.CurrentConfig.MainAutoArise = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireArise)
        end
    end
})

Tabs.dungeon:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = false,
    Flag = "DungeonAutoDestroy", -- Adicionar Flag para salvar configuraÃ§Ã£o
    Callback = function(state)
        autoDestroy = state
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.dungeon:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = false,
    Flag = "DungeonAutoArise", -- Adicionar Flag para salvar configuraÃ§Ã£o
    Callback = function(state)
        autoArise = state
        if state then
            task.spawn(fireArise)
        end
    end
})


local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local dungeonFolder = workspace:WaitForChild("__Main"):WaitForChild("__Dungeon")

-- Variable to control teleporting
local teleportingEnabled = false
-- FunÃ§Ã£o para criar a dungeon
local function createDungeon()
    print("[DEBUG] Tentando criar dungeon...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("âœ” Dungeon criada.")
    task.wait(3)

    -- Iniciar a dungeon
    local iniciarArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(iniciarArgs))
    print("â–¶ Dungeon iniciada.")
end

-- Function to start the dungeon (mantida como backup)
local function startDungeon()
    local dungeonInstance = dungeonFolder:FindFirstChild("Dungeon")
    if dungeonInstance then
        local dungeonID = dungeonInstance:GetAttribute("ID")
        if dungeonID then
            print("[DEBUG] Iniciando dungeon com ID:", dungeonID)
            local args = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = dungeonID,
                        ["Event"] = "DungeonAction",
                        ["Action"] = "Start"
                    },
                    [2] = "\n"
                }
            }
            ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("[DEBUG] Evento de inÃ­cio da Dungeon ativado!")
        else
            print("[Lá»–I] NÃ£o foi encontrado ID da Dungeon!")
        end
    else
        print("[Lá»–I] NÃ£o foi encontrada instÃ¢ncia da Dungeon!")
    end
end

-- Function to teleport directly to an object and bypass anti-cheat
local function teleportToObject(object)
    if object and object:IsA("Part") then
        print("[DEBUG] Teleportando para:", object.Name)

        -- Bypass anti-cheat
        local f = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("FlyingFixer")
        if f then f:Destroy() else print("blablabla bleble") end

        local cha = player.Character and player.Character:FindFirstChild("CharacterScripts") and player.Character.CharacterScripts:FindFirstChild("CharacterUpdater")
        if cha then cha:Destroy() print("discord") else print("Cid") end

        -- Dá»‹ch chuyá»ƒn trá»±c tiáº¿p
        hrp.CFrame = object.CFrame
        print("[DEBUG] Teleport concluÃ­do para:", object.Name)

        task.wait(2) -- Pequeno atraso apÃ³s teleporte
        createDungeon() -- KÃ­ch hoáº¡t remote táº¡o dungeon usando a funÃ§Ã£o corrigida
    else
        print("[Lá»–I] Alvo de teleporte invÃ¡lido!")
    end
end

-- Function to continuously teleport to objects when enabled
local function teleportLoop()
    while teleportingEnabled do
        print("[DEBUG] Procurando objetos de dungeon...")
        local foundObject = false
        for _, object in ipairs(dungeonFolder:GetChildren()) do
            if object:IsA("Part") then
                foundObject = true
                teleportToObject(object)
                task.wait(1) -- Evitar execuÃ§Ã£o excessiva
            end
        end
        if not foundObject then
            print("[Cáº¢NH BÃO] Nenhum objeto de dungeon vÃ¡lido encontrado!")
        end
        task.wait(0.5) -- Atraso antes de verificar novamente
    end
end



-- Add the toggle button to start/stop teleporting
Tabs.dungeon:AddToggle("TeleportToDungeon", {
    Title = "Teleport to Dungeon",
    Default = false,
    Callback = function(state)
        teleportingEnabled = state
        print("[DEBUG] Teleporte ativado/desativado:", state)
        if state then
            task.spawn(teleportLoop) -- Báº¯t Ä‘áº§u vÃ²ng láº·p dá»‹ch chuyá»ƒn khi báº­t
        end
    end
})


local AutoDetectToggle = Tabs.dungeon:AddToggle("AutoDetectDungeon", {Title = "Auto Detect Dungeon", Default = true})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local villageSpawns = {
    ["Grass Village"] = "NarutoWorld",
    ["BRUM ISLAND"] = "OPWorld",
    ["Leveling City"] = "SoloWorld",
    ["FACEHEAL TOWN"] = "BleachWorld",
    ["Lucky"] = "BCWorld",
    ["Nipon City"] = "ChainsawWorld",
    ["Mori Town"] = "JojoWorld",
    ["Dragon City"] = "DBWorld",
    ["XZ City"] = "OPMWorld",
}

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (tÃ¹y chá»n, Ä‘á»ƒ Ä‘áº£m báº£o Ä‘iá»ƒm há»“i sinh Ä‘Æ°á»£c thiáº¿t láº­p)
    task.wait(0.5)

    -- Há»“i sinh nhÃ¢n váº­t
    if player.Character then
        player.Character:BreakJoints() -- Buá»™c nhÃ¢n váº­t pháº£i há»“i sinh
    end
end

local function detectDungeon()
    player.PlayerGui.Warn.ChildAdded:Connect(function(dungeon)
        if dungeon:IsA("Frame") and AutoDetectToggle.Value then
            print("Dungeon detectada!")
            for _, child in ipairs(dungeon:GetChildren()) do
                if child:IsA("TextLabel") then
                    for village, spawnName in pairs(villageSpawns) do
                        if string.find(string.lower(child.Text), string.lower(village)) then
                            teleportEnabled = false
                            print("Vila detectada:", village)
                            SetSpawnAndReset(spawnName)
                            return
                        end
                    end
                end
            end
        end
    end)
end

-- Äáº£m báº£o hÃ m hoáº¡t Ä‘á»™ng
AutoDetectToggle:OnChanged(function(value)
    if value then
        detectDungeon()
    end
end)

detectDungeon()

local function resetAutoFarm()
    -- Äáº·t láº¡i táº¥t cáº£ tráº¡ng thÃ¡i vÃ  hÃ m
    killedNPCs = {} -- Äáº·t láº¡i sá»‘ lÆ°á»£ng NPC Ä‘Ã£ tiÃªu diá»‡t

    print("AutoFarm foi reiniciado!") -- In thÃ´ng bÃ¡o xÃ¡c nháº­n

    -- Khá»Ÿi Ä‘á»™ng láº¡i táº¥t cáº£ cÃ¡c hÃ m náº¿u cáº§n
end

task.spawn(function()
    while true do
        task.wait(120) -- Äá»£i 120 giÃ¢y
        resetAutoFarm() -- Gá»i hÃ m Ä‘áº·t láº¡i
    end
end)

local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = game:GetService("Players").LocalPlayer

local antiAfkConnection

local AntiAfkToggle = Tabs.Player:AddToggle("AntiAfk", {
    Title = "Anti AFK",
    Default = false,
    Callback = function(enabled)
        if enabled then
            print("Anti AFK ativado")
            -- Äáº£m báº£o khÃ´ng táº¡o nhiá»u káº¿t ná»‘i
            if not antiAfkConnection then
                antiAfkConnection = LocalPlayer.Idled:Connect(function()
                    VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                    task.wait(1) -- Thá»i gian chá» cÃ³ thá»ƒ Ä‘iá»u chá»‰nh
                    VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                end)
            end
        else
            print("Anti AFK desativado")
            -- Ngáº¯t káº¿t ná»‘i sá»± kiá»‡n khi táº¯t
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil -- Äáº·t láº¡i biáº¿n káº¿t ná»‘i
            end
        end
    end
})

Tabs.Player:AddButton({
    Title = "Boost FPS",
    Description = "Lowers graphics",
    Callback = function()
        local Optimizer = {Enabled = false}

        local function DisableEffects()
            for _, v in pairs(game:GetDescendants()) do
                if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") or v:IsA("Sparkles") then
                    v.Enabled = not Optimizer.Enabled
                end
                if v:IsA("PostEffect") or v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = not Optimizer.Enabled
                end
            end
        end

        local function MaximizePerformance()
            local lighting = game:GetService("Lighting")
            if Optimizer.Enabled then
                lighting.GlobalShadows = false
                lighting.FogEnd = 9e9
                lighting.Brightness = 2
                settings().Rendering.QualityLevel = 1
                settings().Physics.PhysicsEnvironmentalThrottle = 1
                settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level01
                settings().Physics.AllowSleep = true
                settings().Physics.ForceCSGv2 = false
                settings().Physics.DisableCSGv2 = true
                settings().Rendering.EagerBulkExecution = true

                game:GetService("StarterGui"):SetCore("TopbarEnabled", false)

                settings().Network.IncomingReplicationLag = 0
                settings().Rendering.MaxPartCount = 100000
            else
                lighting.GlobalShadows = true
                lighting.FogEnd = 100000
                lighting.Brightness = 3
                settings().Rendering.QualityLevel = 7
                settings().Physics.PhysicsEnvironmentalThrottle = 0
                settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
                settings().Physics.AllowSleep = false
                settings().Physics.ForceCSGv2 = true
                settings().Physics.DisableCSGv2 = false
                settings().Rendering.EagerBulkExecution = false

                game:GetService("StarterGui"):SetCore("TopbarEnabled", true)

                settings().Network.IncomingReplicationLag = 1
                settings().Rendering.MaxPartCount = 500000
            end
        end

        local function OptimizeInstances()
            for _, v in pairs(game:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CastShadow = not Optimizer.Enabled
                    v.Reflectance = Optimizer.Enabled and 0 or v.Reflectance
                    v.Material = Optimizer.Enabled and Enum.Material.SmoothPlastic or v.Material
                end
                if v:IsA("Decal") or v:IsA("Texture") then
                    v.Transparency = Optimizer.Enabled and 1 or 0
                end
                if v:IsA("MeshPart") then
                    v.RenderFidelity = Optimizer.Enabled and Enum.RenderFidelity.Performance or Enum.RenderFidelity.Precise
                end
            end

            game:GetService("Debris"):SetAutoCleanupEnabled(true)
        end

        local function CleanMemory()
            if Optimizer.Enabled then
                game:GetService("Debris"):AddItem(Instance.new("Model"), 0)
                settings().Physics.ThrottleAdjustTime = 2
                game:GetService("RunService"):Set3dRenderingEnabled(false)
            else
                game:GetService("RunService"):Set3dRenderingEnabled(true)
            end
        end

        local function ToggleOptimizer()
            Optimizer.Enabled = not Optimizer.Enabled
            DisableEffects()
            MaximizePerformance()
            OptimizeInstances()
            CleanMemory()
            print("FPS Booster: " .. (Optimizer.Enabled and "ON" or "OFF"))
        end

        game:GetService("UserInputService").InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.RightControl then
                ToggleOptimizer()
            end
        end)

        ToggleOptimizer()

        game:GetService("RunService").Heartbeat:Connect(function()
            if Optimizer.Enabled then
                CleanMemory()
            end
        end)
    end
})



local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local targetCFrame = CFrame.new(
    3648.76318, 223.552261, 2637.36719, 
    0.846323907, 7.72367986e-18, -0.532668591, 
    -1.10462046e-17, 1, -3.05065368e-18, 
    0.532668591, 8.46580728e-18, 0.846323907
)

local function tweenToPivot()
    hrp.CFrame = targetCFrame
end


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local speedValue = 16 -- Tá»‘c Ä‘á»™ di chuyá»ƒn máº·c Ä‘á»‹nh
local jumpValue = 50  -- Lá»±c nháº£y máº·c Ä‘á»‹nh
local speedEnabled = false
local jumpEnabled = false

local function updateCharacter()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        humanoid.WalkSpeed = speedEnabled and speedValue or 16
        humanoid.JumpPower = jumpEnabled and jumpValue or 50
    end
end

-- Nháº­p tá»‘c Ä‘á»™
local SpeedInput = Tabs.Player:AddInput("SpeedInput", {
    Title = "Speed",
    Default = tostring(speedValue),
    Placeholder = "Enter speed",
    Numeric = true,
    Finished = true, 
    Callback = function(Value)
        speedValue = tonumber(Value) or 16
        updateCharacter() -- Cáº­p nháº­t nhÃ¢n váº­t ngay láº­p tá»©c khi tá»‘c Ä‘á»™ thay Ä‘á»•i
    end
})

-- Nháº­p lá»±c nháº£y
local JumpInput = Tabs.Player:AddInput("JumpInput", {
    Title = "Jump Power",
    Default = tostring(jumpValue),
    Placeholder = "Enter jump power",
    Numeric = true,
    Finished = true, 
    Callback = function(Value)
        jumpValue = tonumber(Value) or 50
        updateCharacter() -- Cáº­p nháº­t nhÃ¢n váº­t ngay láº­p tá»©c khi lá»±c nháº£y thay Ä‘á»•i
    end
})

-- Báº­t/táº¯t tá»‘c Ä‘á»™
local SpeedToggle = Tabs.Player:AddToggle("SpeedToggle", {
    Title = "Enable Speed",
    Default = false
})

SpeedToggle:OnChanged(function(Value)
    speedEnabled = Value
    updateCharacter() -- Cáº­p nháº­t nhÃ¢n váº­t ngay láº­p tá»©c khi toggle thay Ä‘á»•i
end)

-- Báº­t/táº¯t lá»±c nháº£y
local JumpToggle = Tabs.Player:AddToggle("JumpToggle", {
    Title = "Enable Jump Power",
    Default = false
})

JumpToggle:OnChanged(function(Value)
    jumpEnabled = Value
    updateCharacter() -- Cáº­p nháº­t nhÃ¢n váº­t ngay láº­p tá»©c khi toggle thay Ä‘á»•i
end)

-- Cáº­p nháº­t nhÃ¢n váº­t khi há»“i sinh
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1) -- Äá»£i nhÃ¢n váº­t táº£i xong
    updateCharacter()
end)

-- Cáº­p nháº­t ban Ä‘áº§u
updateCharacter()

local player = game.Players.LocalPlayer

local function tweenCharacter(targetCFrame)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = player.Character.HumanoidRootPart
        local tweenService = game:GetService("TweenService")
        local tweenInfo = TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = tweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
        tween:Play()
    end
end

-- ThÃªm nÃºt
Tabs.tp:AddButton({
    Title = "Tween to Dedu island",
    Description = "Smoothly moves your character",
    Callback = function()
        tweenCharacter(CFrame.new(3859.06299, 60.1228409, 3081.9458, -0.987112403, 6.46206388e-07, -0.160028473, 5.63319077e-07, 1, 5.63319418e-07, 0.160028473, 4.65912507e-07, -0.987112403)) -- Alterar a posiÃ§Ã£o conforme necessÃ¡rio
    end
})



local NoClipToggle = Tabs.Player:AddToggle("NoClipToggle", {
    Title = "Enable NoClip",
    Default = false
})

-- HÃ m NoClip
local noclipEnabled = false
NoClipToggle:OnChanged(function(Value)
    noclipEnabled = Value
    if noclipEnabled then
        task.spawn(function()
            while noclipEnabled do
                for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
                task.wait()
            end
        end)
    else
        for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end)



Tabs.Player:AddButton({
    Title = "Server Hop",
    Description = "Switches to a different server",
    Callback = function()
        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        local File = pcall(function()
            AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
        end)
        if not File then
            table.insert(AllIDs, actualHour)
            writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
        end
        local function TPReturner()
            local Site
            if foundAnything == "" then
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
            else
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
            end
            for _, v in pairs(Site.data) do
                if tonumber(v.maxPlayers) > tonumber(v.playing) then
                    local ID = tostring(v.id)
                    local isNewServer = true
                    for _, existing in pairs(AllIDs) do
                        if ID == tostring(existing) then
                            isNewServer = false
                            break
                        end
                    end
                    if isNewServer then
                        table.insert(AllIDs, ID)
                        writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
                        game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                        return
                    end
                end
            end
        end
        TPReturner()
    end
})



    

        
Tabs.dungeon:AddToggle("AutoBuyDungeonTicket", {
    Title = "Auto Buy Dungeon Ticket",
    Default = false,
    Callback = function(state)
        buyTicketEnabled = state
        print("[DEBUG] Auto Buy Dungeon Ticket toggled:", state)
        
        if state then
            task.spawn(function()
                while buyTicketEnabled do
                    local args = {
                        [1] = {
                            [1] = {
                                ["Type"] = "Gems",
                                ["Event"] = "DungeonAction",
                                ["Action"] = "BuyTicket"
                            },
                            [2] = "\n"
                        }
                    }

                    game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
                    task.wait(5) -- Äá»£i 5 giÃ¢y trÆ°á»›c khi gá»­i láº¡i
                end
            end)
        end
    end
})



    local localPlayer = game:GetService("Players").LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local playerHRP = playerCharacter:WaitForChild("HumanoidRootPart")
local enemyContainer = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local networkEvent = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local autoFarmActive = false
local defeatedEnemies = {}

local function isTargetDefeated(target)
    local healthUI = target:FindFirstChild("HealthBar")
    if healthUI and healthUI:FindFirstChild("Main") and healthUI.Main:FindFirstChild("Bar") then
        local healthText = healthUI.Main.Bar:FindFirstChild("Amount")
        if healthText and healthText:IsA("TextLabel") and healthText.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function findClosestTarget()
    local closestJJ2, closestJJ3, closestJJ4 = nil, nil, nil
    local distJJ2, distJJ3, distJJ4 = math.huge, math.huge, math.huge
    local playerPos = localPlayer.Character and localPlayer.Character:GetPivot().Position

    if not playerPos then return nil end

    for _, enemy in ipairs(enemyContainer:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local enemyType = enemy:GetAttribute("ID")
            
            -- Äáº£m báº£o script bá» qua cÃ¡c káº» Ä‘á»‹ch Ä‘Ã£ cháº¿t
            if not defeatedEnemies[enemy.Name] then
                local distance = (playerPos - enemy:GetPivot().Position).Magnitude
                
                if enemyType == "JJ2" and distance < distJJ2 then
                    distJJ2 = distance
                    closestJJ2 = enemy
                elseif enemyType == "JJ3" and distance < distJJ3 then
                    distJJ3 = distance
                    closestJJ3 = enemy
                elseif enemyType == "JJ4" and distance < distJJ4 then
                    distJJ4 = distance
                    closestJJ4 = enemy
                end
            end
        end
    end

    -- Æ¯u tiÃªn: JJ2 > JJ3 > JJ4
    return closestJJ2 or closestJJ3 or closestJJ4
end

local function triggerPetVisibility()
    local arguments = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(arguments))
end

local function startAutoFarm()
    while autoFarmActive do
        local targetEnemy = findClosestTarget()
        
        while autoFarmActive and targetEnemy do
            if not targetEnemy.Parent then break end

            local targetHRP = targetEnemy:FindFirstChild("HumanoidRootPart")
            local playerHRP = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

            if targetHRP and playerHRP then
                -- Move to target enemy
                playerHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 6)

                task.wait(0.5)
                triggerPetVisibility()

                networkEvent:FireServer({
                    {
                        ["PetPos"] = {},
                        ["AttackType"] = "All",
                        ["Event"] = "Attack",
                        ["Enemy"] = targetEnemy.Name
                    },
                    "\7"
                })

                -- Wait until enemy is defeated or a higher-priority one appears
                while autoFarmActive and targetEnemy.Parent do
                    if isTargetDefeated(targetEnemy) then
                        defeatedEnemies[targetEnemy.Name] = true -- Mark it as dead immediately
                        break
                    end
                    
                    task.wait(0.1)
                    
                    -- Switch if a higher-priority target appears
                    local newTarget = findClosestTarget()
                    if newTarget and newTarget:GetAttribute("ID") == "JJ2" and newTarget ~= targetEnemy then
                        break
                    elseif newTarget and newTarget:GetAttribute("ID") == "JJ3" and targetEnemy:GetAttribute("ID") == "JJ4" then
                        break
                    end
                end
            end

            targetEnemy = findClosestTarget() -- Move to next enemy
        end

        task.wait(0.20)
    end
end

Tabs.Main:AddToggle("AutoFarmToggle", {
    Title = "auto Jeju farm",
    Default = false,
    Callback = function(state)
        autoFarmActive = state
        if state then
            task.spawn(startAutoFarm)
        end
    end
})


local AutoEnterDungeon = Tabs.dungeon:AddToggle("AutoEnterDungeon", { Title = "Auto Enter Guild Dungeon", Default = false })

local function EnterDungeon()
    while AutoEnterDungeon.Value do
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "DungeonAction",
                    ["Action"] = "TestEnter"
                },
                [2] = "\n"
            }
        }

        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
        task.wait(0.5) -- Ajustar o atraso se necessÃ¡rio
    end
end

AutoEnterDungeon:OnChanged(function(Value)
    if Value then
        task.spawn(EnterDungeon) -- Start loop when enabled
    end
end)

Tabs.Discord:AddParagraph({
    Title = "ThÃ´ng tin",
    Content = "Script Ä‘Æ°á»£c táº¡o bá»Ÿi Allan Hub"
})

Tabs.Discord:AddButton({
    Title = "Copy Discord Link",
    Description = "Join my discord",
    Callback = function()
        setclipboard("https://discord.gg/v94FqK3zH5")
        Fluent:Notify({
            Title = "ÄÃ£ sao chÃ©p!",
            Content = "ÄÆ°á»ng dáº«n Discord Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p vÃ o clipboard.",
            Duration = 3
        })
    end
})


SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Thay Ä‘á»•i cÃ¡ch lÆ°u cáº¥u hÃ¬nh Ä‘á»ƒ sá»­ dá»¥ng tÃªn ngÆ°á»i chÆ¡i
local playerName = game:GetService("Players").LocalPlayer.Name
InterfaceManager:SetFolder("Allan Hub")
SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)

-- XÃ³a Ä‘oáº¡n xÃ¢y dá»±ng pháº§n cáº¥u hÃ¬nh trong Settings tab
-- InterfaceManager:BuildInterfaceSection(Tabs.Settings)
-- SaveManager:BuildConfigSection(Tabs.Settings)

-- ThÃªm thÃ´ng tin vÃ o tab Settings
Tabs.Settings:AddParagraph({
    Title = "Cáº¥u hÃ¬nh tá»± Ä‘á»™ng",
    Content = "Cáº¥u hÃ¬nh cá»§a báº¡n Ä‘ang Ä‘Æ°á»£c tá»± Ä‘á»™ng lÆ°u theo tÃªn nhÃ¢n váº­t: " .. playerName
})

Tabs.Settings:AddParagraph({
    Title = "PhÃ­m táº¯t",
    Content = "Nháº¥n LeftControl Ä‘á»ƒ áº©n/hiá»‡n giao diá»‡n"
})

-- ThÃªm nÃºt xÃ³a cáº¥u hÃ¬nh hiá»‡n táº¡i
Tabs.Settings:AddButton({
    Title = "XÃ³a cáº¥u hÃ¬nh hiá»‡n táº¡i",
    Description = "Äáº·t láº¡i táº¥t cáº£ cÃ i Ä‘áº·t vá» máº·c Ä‘á»‹nh",
    Callback = function()
        SaveManager:Delete("AutoSave_" .. playerName)
        Fluent:Notify({
            Title = "ÄÃ£ xÃ³a cáº¥u hÃ¬nh",
            Content = "Táº¥t cáº£ cÃ i Ä‘áº·t Ä‘Ã£ Ä‘Æ°á»£c Ä‘áº·t láº¡i vá» máº·c Ä‘á»‹nh",
            Duration = 3
        })
    end
})

Window:SelectTab(1)

Fluent:Notify({
    Title = "Allan Hub",
    Content = "Script Ä‘Ã£ táº£i xong! Cáº¥u hÃ¬nh tá»± Ä‘á»™ng lÆ°u theo tÃªn ngÆ°á»i chÆ¡i: " .. playerName,
    Duration = 3
})

-- Thay Ä‘á»•i cÃ¡ch táº£i cáº¥u hÃ¬nh
local function AutoSaveConfig()
    local configName = "AutoSave_" .. playerName
    
    -- Tá»± Ä‘á»™ng lÆ°u cáº¥u hÃ¬nh hiá»‡n táº¡i
    task.spawn(function()
        while task.wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                SaveManager:Save(configName)
            end)
        end
    end)
    
    -- Táº£i cáº¥u hÃ¬nh Ä‘Ã£ lÆ°u náº¿u cÃ³
    pcall(function()
        SaveManager:Load(configName)
    end)
end

-- Thá»±c thi tá»± Ä‘á»™ng lÆ°u/táº£i cáº¥u hÃ¬nh
AutoSaveConfig()

-- ThÃªm há»— trá»£ Mobile UI
repeat task.wait(0.25) until game:IsLoaded()
getgenv().Image = "rbxassetid://13099788281" -- ID tÃ i nguyÃªn hÃ¬nh áº£nh Ä‘Ã£ sá»­a
getgenv().ToggleUI = "LeftControl" -- PhÃ­m Ä‘á»ƒ báº­t/táº¯t giao diá»‡n

-- Táº¡o giao diá»‡n mobile cho ngÆ°á»i dÃ¹ng Ä‘iá»‡n thoáº¡i
task.spawn(function()
    local success, errorMsg = pcall(function()
        if not getgenv().LoadedMobileUI == true then 
            getgenv().LoadedMobileUI = true
            local OpenUI = Instance.new("ScreenGui")
            local ImageButton = Instance.new("ImageButton")
            local UICorner = Instance.new("UICorner")
            
            -- Kiá»ƒm tra thiáº¿t bá»‹
            if syn and syn.protect_gui then
                syn.protect_gui(OpenUI)
                OpenUI.Parent = game:GetService("CoreGui")
            elseif gethui then
                OpenUI.Parent = gethui()
            else
                OpenUI.Parent = game:GetService("CoreGui")
            end
            
            OpenUI.Name = "OpenUI"
            OpenUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            
            ImageButton.Parent = OpenUI
            ImageButton.BackgroundColor3 = Color3.fromRGB(105,105,105)
            ImageButton.BackgroundTransparency = 0.8
            ImageButton.Position = UDim2.new(0.9,0,0.1,0)
            ImageButton.Size = UDim2.new(0,50,0,50)
            ImageButton.Image = getgenv().Image
            ImageButton.Draggable = true
            ImageButton.Transparency = 0.2
            
            UICorner.CornerRadius = UDim.new(0,200)
            UICorner.Parent = ImageButton
            
            ImageButton.MouseButton1Click:Connect(function()
                game:GetService("VirtualInputManager"):SendKeyEvent(true,getgenv().ToggleUI,false,game)
            end)
        end
    end)
    
    if not success then
        warn("Erro ao criar botÃ£o da UI Mobile: " .. tostring(errorMsg))
    end
end)

-- Kiá»ƒm tra script Ä‘Ã£ táº£i thÃ nh cÃ´ng
local scriptSuccess, scriptError = pcall(function()
    Fluent:Notify({
        Title = "Script iniciado com sucesso",
        Content = "Allan Hub | Arise Crossover estÃ¡ ativo",
        Duration = 5
    })
end)

if not scriptSuccess then
    warn("Lá»—i khi khá»Ÿi Ä‘á»™ng script: " .. tostring(scriptError))
    -- Thá»­ cÃ¡ch khÃ¡c Ä‘á»ƒ thÃ´ng bÃ¡o ngÆ°á»i dÃ¹ng
    if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui") then
        local screenGui = Instance.new("ScreenGui")
        screenGui.Parent = game:GetService("Players").LocalPlayer.PlayerGui
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(0.3, 0, 0.1, 0)
        textLabel.Position = UDim2.new(0.35, 0, 0.45, 0)
        textLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.Text = "Allan Hub Ä‘Ã£ khá»Ÿi Ä‘á»™ng nhÆ°ng gáº·p lá»—i. HÃ£y thá»­ láº¡i."
        textLabel.Parent = screenGui
        
        local uiCorner = Instance.new("UICorner")
        uiCorner.CornerRadius = UDim.new(0, 8)
        uiCorner.Parent = textLabel
        
        game:GetService("Debris"):AddItem(screenGui, 5)
    end
end

-- ThÃªm event listener Ä‘á»ƒ lÆ°u ngay khi thay Ä‘á»•i giÃ¡ trá»‹
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then -- Kiá»ƒm tra tab vÃ  tab._components cÃ³ tá»“n táº¡i khÃ´ng
        for _, element in pairs(tab._components) do
                if element and element.OnChanged then -- Kiá»ƒm tra element vÃ  element.OnChanged cÃ³ tá»“n táº¡i khÃ´ng
                element.OnChanged:Connect(function()
                    pcall(function()
                        SaveManager:Save("AutoSave_" .. playerName)
                    end)
                end)
                end
            end
        end
    end
end

-- Thá»±c thi tá»± Ä‘á»™ng lÆ°u/táº£i cáº¥u hÃ¬nh
AutoSaveConfig()
setupSaveEvents() -- ThÃªm dÃ²ng nÃ y

local BuyWeaponSection = Tabs.shop:AddSection("Buy Weapon")
-- Mapping giá»¯a shops vÃ  weapons
local weaponsByShop = {
    ["WeaponShop1"] = {"SpikeMace", "GemStaff", "DualKando", "CrystalScepter", "DualBoneMace", "DualSteelNaginata"},
    ["WeaponShop2"] = {"MonsterSlayer", "DualBasicStaffs", "PirateSaber", "BronzeGreatAxe", "MixedBattleAxe", "DualAncientMace"},
    ["WeaponShop3"] = {"DualPirateSaber", "DualSteelSabers", "DualSteelButterfly", "SteelSaber", "SteelButterfly", "SteelKando"},
    ["WeaponShop4"] = {"SteelNaginata", "GreatKopesh", "BoneMace", "CrimsonStaff", "AncientMace", "GreatSaber"},
    ["WeaponShop5"] = {"DualGreatSaber", "BasicStaff", "StellKopesh", "GreatTrident", "DualCrystalScepter", "DualTrident"},
    ["WeaponShop6"] = {"OzSword2", "CrystalSword2", "ObsidianDualAxe2", "SilverSpear2", "DragonAxe2", "DualDivineAxe2"},
    ["WeaponShop7"] = {"BloodStaff2", "DualCrimsonStaff2", "DualGemStaffs2", "GreatScythe2", "TwinObsidianDualStaff2", "SlayerScythe2"},
    ["WeaponShop8"] = {"BeholderStaff2", "TwinMixedAxe2", "TwinTrollSlayer2", "RuneAxe2", "DualSilverSpear2", "DualDragonAxe2"},
    ["WeaponShop9"] = {"SteelSword2", "SteelSpear2", "StarSpear2", "BoneStaff2", "SunGreatAxe2", "EnergyGreatSword2"},
}

local selectedShop = "WeaponShop1" -- Shop máº·c Ä‘á»‹nh
local selectedWeapon = "" -- Weapon máº·c Ä‘á»‹nh
local autoBuyEnabled = false -- Tráº¡ng thÃ¡i Auto Buy

-- Cáº­p nháº­t ConfigSystem Ä‘á»ƒ lÆ°u cÃ¡c biáº¿n má»›i
ConfigSystem.DefaultConfig.SelectedShop = selectedShop
ConfigSystem.DefaultConfig.SelectedWeapon = selectedWeapon
ConfigSystem.DefaultConfig.AutoBuyEnabled = autoBuyEnabled

-- Dropdown Ä‘á»ƒ chá»n Shop
Tabs.shop:AddDropdown("ShopDropdown", {
    Title = "Select Shop",
    Values = {"WeaponShop1", "WeaponShop2", "WeaponShop3", "WeaponShop4", "WeaponShop5", "WeaponShop6", "WeaponShop7", "WeaponShop8", "WeaponShop9"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedShop or selectedShop,
    Callback = function(shop)
        selectedShop = shop
        ConfigSystem.CurrentConfig.SelectedShop = shop
        
        -- Cáº­p nháº­t danh sÃ¡ch weapon dá»±a trÃªn shop Ä‘Æ°á»£c chá»n
        local weaponDropdown = Fluent.Options.WeaponDropdown
        if weaponDropdown then
            weaponDropdown:SetValues(weaponsByShop[shop] or {})
            -- Äáº·t giÃ¡ trá»‹ máº·c Ä‘á»‹nh náº¿u cÃ³ weapon
            if #weaponsByShop[shop] > 0 then
                selectedWeapon = weaponsByShop[shop][1]
                weaponDropdown:SetValue(selectedWeapon)
                ConfigSystem.CurrentConfig.SelectedWeapon = selectedWeapon
            else
                selectedWeapon = ""
            end
        end
        
        ConfigSystem.SaveConfig()
    end
})

-- Dropdown Ä‘á»ƒ chá»n Weapon trong shop Ä‘Ã£ chá»n
Tabs.shop:AddDropdown("WeaponDropdown", {
    Title = "Select Weapon",
    Values = weaponsByShop[selectedShop] or {},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeapon or (weaponsByShop[selectedShop] and weaponsByShop[selectedShop][1] or ""),
    Callback = function(weapon)
        selectedWeapon = weapon
        ConfigSystem.CurrentConfig.SelectedWeapon = weapon
        ConfigSystem.SaveConfig()
        print("Selected Weapon:", selectedWeapon) -- Debug
    end
})
-- â³ Äá»“ng bá»™ láº¡i danh sÃ¡ch vÅ© khÃ­ sau khi GUI Ä‘Ã£ khá»Ÿi táº¡o
task.defer(function()
    local currentShop = ConfigSystem.CurrentConfig.SelectedShop
    local currentWeapon = ConfigSystem.CurrentConfig.SelectedWeapon
    local weaponDropdown = Fluent.Options.WeaponDropdown

    if currentShop and weaponsByShop[currentShop] and weaponDropdown then
        weaponDropdown:SetValues(weaponsByShop[currentShop])
        if table.find(weaponsByShop[currentShop], currentWeapon) then
            weaponDropdown:SetValue(currentWeapon)
        else
            local defaultWeapon = weaponsByShop[currentShop][1]
            selectedWeapon = defaultWeapon
            weaponDropdown:SetValue(defaultWeapon)
            ConfigSystem.CurrentConfig.SelectedWeapon = defaultWeapon
            ConfigSystem.SaveConfig()
        end
    end
end)


-- HÃ m Ä‘á»ƒ mua weapon
local function buyWeapon()
    if selectedShop and selectedWeapon and selectedWeapon ~= "" then
        local args = {
            [1] = {
                [1] = {
                    ["Action"] = "Buy",
                    ["Shop"] = selectedShop,
                    ["Item"] = selectedWeapon,
                    ["Event"] = "ItemShopAction"
                },
                [2] = "\n"
            }
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
        print("Comprado:", selectedWeapon, "da loja:", selectedShop)
    else
        print("Por favor, selecione uma loja e uma arma!")
    end
end

-- Toggle Ä‘á»ƒ báº­t/táº¯t Auto Buy
Tabs.shop:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy Weapon",
    Default = ConfigSystem.CurrentConfig.AutoBuyEnabled or false,
    Callback = function(state)
        autoBuyEnabled = state
        ConfigSystem.CurrentConfig.AutoBuyEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            task.spawn(function()
                while autoBuyEnabled do
                    buyWeapon()
                    task.wait(1) -- Chá» 1 giÃ¢y giá»¯a má»—i láº§n mua
                end
            end)
        end
    end
})
local UpdateWeaponSection = Tabs.shop:AddSection("Update Weapon")
-- ThÃªm code cho tab Update sau pháº§n mÃ£ cá»§a tab Buy
-- HÃ m Ä‘á»ƒ láº¥y danh sÃ¡ch tÃªn vÅ© khÃ­ duy nháº¥t tá»« inventory
local function getUniqueWeaponNames()
    local weapons = {}
    local seenNames = {} -- Äá»ƒ theo dÃµi tÃªn duy nháº¥t

    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    print("Obtendo lista de armas...") -- Gá»  Lá»–I

    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name") -- Láº¥y thuá»™c tÃ­nh "Name"
        if weaponName then
            print("Arma encontrada:", weaponName) -- Gá»  Lá»–I
            if not seenNames[weaponName] then
                table.insert(weapons, weaponName)
                seenNames[weaponName] = true -- ÄÃ¡nh dáº¥u tÃªn Ä‘Ã£ tháº¥y
            end
        end
    end
    return weapons
end

-- HÃ m Ä‘á»ƒ láº¥y danh sÃ¡ch ID cá»§a táº¥t cáº£ vÅ© khÃ­ cÃ¹ng loáº¡i
local function getWeaponIDs(weaponType)
    local weaponIDs = {}
    
    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name")
        -- Kiá»ƒm tra xem vÅ© khÃ­ cÃ³ pháº£i lÃ  loáº¡i Ä‘ang tÃ¬m kiáº¿m khÃ´ng
        if weaponName == weaponType then
            table.insert(weaponIDs, weapon.Name) -- ThÃªm ID cá»§a vÅ© khÃ­ vÃ o danh sÃ¡ch
            print("ID da arma encontrado:", weapon.Name) -- Gá»  Lá»–I
        end
    end
    
    return weaponIDs
end

-- Láº¥y danh sÃ¡ch tÃªn vÅ© khÃ­ ban Ä‘áº§u
local weaponTypes = getUniqueWeaponNames()
local selectedWeaponType = weaponTypes[1] or "" -- Loáº¡i vÅ© khÃ­ máº·c Ä‘á»‹nh
local autoUpdateEnabled = false -- Tráº¡ng thÃ¡i Auto Update
local autoSelectedEnabled = false -- Tráº¡ng thÃ¡i Auto Update cho vÅ© khÃ­ Ä‘Ã£ chá»n

-- Cáº­p nháº­t ConfigSystem
ConfigSystem.DefaultConfig.SelectedWeaponType = selectedWeaponType
ConfigSystem.DefaultConfig.AutoUpdateEnabled = autoUpdateEnabled
ConfigSystem.DefaultConfig.AutoSelectedEnabled = autoSelectedEnabled

-- Dropdown Ä‘á»ƒ chá»n loáº¡i vÅ© khÃ­ muá»‘n nÃ¢ng cáº¥p
Tabs.shop:AddDropdown("WeaponTypeDropdown", {
    Title = "Select Weapon",
    Values = weaponTypes,
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeaponType or selectedWeaponType,
    Callback = function(weaponType)
        selectedWeaponType = weaponType
        ConfigSystem.CurrentConfig.SelectedWeaponType = weaponType
        ConfigSystem.SaveConfig()
        print("Selected Weapon Type:", selectedWeaponType) -- Gá»  Lá»–I
    end
})

-- HÃ m Ä‘á»ƒ láº¥y táº¥t cáº£ vÅ© khÃ­ theo level
local function getWeaponsByLevel(weaponType)
    local weaponsByLevel = {}
    
    -- Khá»Ÿi táº¡o máº£ng Ä‘á»ƒ lÆ°u trá»¯ vÅ© khÃ­ theo level
    for i = 1, 7 do
        weaponsByLevel[i] = {}
    end
    
    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name")
        local weaponLevel = weapon:GetAttribute("Level") or 1
        
        -- Náº¿u khÃ´ng chá»n loáº¡i vÅ© khÃ­ cá»¥ thá»ƒ hoáº·c vÅ© khÃ­ thuá»™c loáº¡i Ä‘Ã£ chá»n
        if (not weaponType or weaponType == "" or weaponName == weaponType) and weaponLevel >= 1 and weaponLevel <= 7 then
            table.insert(weaponsByLevel[weaponLevel], weapon.Name)
            print("Arma encontrada:", weaponName, "Level:", weaponLevel, "ID:", weapon.Name)
        end
    end
    
    return weaponsByLevel
end

-- HÃ m Ä‘á»ƒ nÃ¢ng cáº¥p vÅ© khÃ­ theo level
local function upgradeWeaponsByLevel(weaponType)
    local weaponsByLevel = getWeaponsByLevel(weaponType)
    local anyUpgraded = false
    
    -- Duyá»‡t qua tá»«ng level, báº¯t Ä‘áº§u tá»« level tháº¥p nháº¥t
    for level = 1, 6 do
        local weapons = weaponsByLevel[level]
        
        -- Náº¿u cÃ³ Ã­t nháº¥t 3 vÅ© khÃ­ cÃ¹ng level, thá»±c hiá»‡n nÃ¢ng cáº¥p
        while #weapons >= 3 do
            -- Láº¥y 3 vÅ© khÃ­ Ä‘áº§u tiÃªn Ä‘á»ƒ nÃ¢ng cáº¥p
            local upgradeWeapons = {
                weapons[1],
                weapons[2],
                weapons[3]
            }
            
            -- XÃ³a 3 vÅ© khÃ­ nÃ y khá»i danh sÃ¡ch
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            
            -- Thá»±c hiá»‡n nÃ¢ng cáº¥p
            local weaponName = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:FindFirstChild(upgradeWeapons[1]):GetAttribute("Name")
            
            local args = {
                [1] = {
                    [1] = {
                        ["Type"] = weaponName,
                        ["BuyType"] = "Gems",
                        ["Weapons"] = upgradeWeapons,
                        ["Event"] = "UpgradeWeapon",
                        ["Level"] = level + 1
                    },
                    [2] = "\n"
                }
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("Äang nÃ¢ng cáº¥p", #upgradeWeapons, "vÅ© khÃ­", weaponName, "tá»« level", level, "lÃªn level", level + 1)
            
            Fluent:Notify({
                Title = "Äang nÃ¢ng cáº¥p",
                Content = "Äang nÃ¢ng cáº¥p " .. weaponName .. " tá»« level " .. level .. " lÃªn level " .. (level + 1),
                Duration = 3
            })
            
            anyUpgraded = true
            task.wait(1) -- Äá»£i 1 giÃ¢y Ä‘á»ƒ trÃ¡nh spam server
        end
    end
    
    if not anyUpgraded then
        Fluent:Notify({
            Title = "ThÃ´ng bÃ¡o",
            Content = "KhÃ´ng cÃ³ vÅ© khÃ­ nÃ o Ä‘á»§ sá»‘ lÆ°á»£ng Ä‘á»ƒ nÃ¢ng cáº¥p",
            Duration = 3
        })
    end
    
    return anyUpgraded
end

-- NÃºt Ä‘á»ƒ lÃ m má»›i danh sÃ¡ch vÅ© khÃ­
Tabs.shop:AddButton({
    Title = "Refresh Weapon List",
    Description = "Refresh the list of available weapons",
    Callback = function()
        weaponTypes = getUniqueWeaponNames()
        local weaponTypeDropdown = Fluent.Options.WeaponTypeDropdown
        if weaponTypeDropdown then
            weaponTypeDropdown:SetValues(weaponTypes)
            if #weaponTypes > 0 and not table.find(weaponTypes, selectedWeaponType) then
                selectedWeaponType = weaponTypes[1]
                weaponTypeDropdown:SetValue(selectedWeaponType)
                ConfigSystem.CurrentConfig.SelectedWeaponType = selectedWeaponType
                ConfigSystem.SaveConfig()
            end
        end
        
        Fluent:Notify({
            Title = "Danh sÃ¡ch Ä‘Ã£ lÃ m má»›i",
            Content = "ÄÃ£ cáº­p nháº­t danh sÃ¡ch vÅ© khÃ­ cÃ³ sáºµn",
            Duration = 3
        })
    end
})

-- Toggle Ä‘á»ƒ báº­t/táº¯t nÃ¢ng cáº¥p vÅ© khÃ­ Ä‘Ã£ chá»n
Tabs.shop:AddToggle("AutoSelectToggle", {
    Title = "Upgrade Selected Weapon",
    Default = ConfigSystem.CurrentConfig.AutoSelectedEnabled or false,
    Callback = function(state)
        autoSelectedEnabled = state
        ConfigSystem.CurrentConfig.AutoSelectedEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if not selectedWeaponType or selectedWeaponType == "" then
                Fluent:Notify({
                    Title = "Lá»—i",
                    Content = "Vui lÃ²ng chá»n loáº¡i vÅ© khÃ­ trÆ°á»›c khi nÃ¢ng cáº¥p",
                    Duration = 3
                })
                return
            end
            
            task.spawn(function()
                while autoSelectedEnabled do
                    local upgraded = upgradeWeaponsByLevel(selectedWeaponType)
                    if not upgraded then
                        task.wait(5) -- Äá»£i lÃ¢u hÆ¡n náº¿u khÃ´ng cÃ³ vÅ© khÃ­ nÃ o Ä‘Æ°á»£c nÃ¢ng cáº¥p
                    else
                        task.wait(1) -- Äá»£i ngáº¯n hÆ¡n náº¿u cÃ³ vÅ© khÃ­ Ä‘Æ°á»£c nÃ¢ng cáº¥p
                    end
                end
            end)
        end
    end
})

-- ThÃªm section sell pet vÃ o tab shop
local SellPetSection = Tabs.shop:AddSection("Sell Pet")
-- Ãnh xáº¡ cÃ¡c rank sá»‘ sang chá»¯ cÃ¡i
local rankMapping = {
    [1] = "E",
    [2] = "D",
    [3] = "C",
    [4] = "B",
    [5] = "A",
    [6] = "S",
    [7] = "SS",
    [8] = "G",
    [9] = "N"
}

-- Táº¡o máº£ng giÃ¡ trá»‹ Ä‘á»ƒ hiá»ƒn thá»‹ trong dropdown
local rankValues = {}
for i = 1, 9 do
    table.insert(rankValues, rankMapping[i] .. " (Rank " .. i .. ")")
end

-- Biáº¿n Ä‘á»ƒ lÆ°u tráº¡ng thÃ¡i
local selectedRanks = {}
local autoSellEnabled = false

-- Cáº­p nháº­t ConfigSystem Ä‘á»ƒ lÆ°u cÃ¡c biáº¿n má»›i
ConfigSystem.DefaultConfig.SelectedRanks = {}
ConfigSystem.DefaultConfig.AutoSellEnabled = false

-- Dropdown Ä‘á»ƒ chá»n Rank
Tabs.shop:AddDropdown("RankDropdown", {
    Title = "Choose Ranks",
    Values = rankValues,
    Multi = true,
    Default = ConfigSystem.CurrentConfig.SelectedRanks or {},
    Callback = function(selections)
        selectedRanks = {}
        -- Kiá»ƒm tra xem selections cÃ³ pháº£i lÃ  table hay khÃ´ng
        if type(selections) == "table" then
            for selection, isSelected in pairs(selections) do
                -- Chá»‰ xá»­ lÃ½ cÃ¡c má»¥c Ä‘Ã£ chá»n (boolean = true)
                if isSelected == true then
                    -- TrÃ­ch xuáº¥t sá»‘ rank tá»« chuá»—i (vd: tá»« "E (Rank 1)" láº¥y ra 1)
                    local rankStr = selection:match("Rank (%d+)")
                    if rankStr then
                        local rank = tonumber(rankStr)
                        if rank then
                            table.insert(selectedRanks, rank)
                        end
                    end
                end
            end
        end
        ConfigSystem.CurrentConfig.SelectedRanks = selections
        ConfigSystem.SaveConfig()
        print("Selected Ranks:", table.concat(selectedRanks, ", "))
    end
})

-- HÃ m Ä‘á»ƒ bÃ¡n pet theo rank
local function sellPetsByRank()
    local petFolder = player.leaderstats.Inventory:WaitForChild("Pets")
    local petsToSell = {}
    
    for _, pet in ipairs(petFolder:GetChildren()) do
        local rankVal = pet:GetAttribute("Rank")
        if typeof(rankVal) == "number" and table.find(selectedRanks, rankVal) then
            table.insert(petsToSell, pet.Name)
            
            -- Náº¿u Ä‘áº¡t Ä‘á»§ 20 pet hoáº·c Ä‘Ã¢y lÃ  pet cuá»‘i cÃ¹ng, tiáº¿n hÃ nh bÃ¡n
            if #petsToSell >= 20 then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "SellPet",
                            ["Pets"] = petsToSell
                        },
                        [2] = "\t"
                    }
                }
                remote:FireServer(unpack(args))
                print("ÄÃ£ bÃ¡n", #petsToSell, "pet vá»›i rank Ä‘Ã£ chá»n")
                
                -- Äá»£i má»™t khoáº£ng thá»i gian ngáº¯n Ä‘á»ƒ trÃ¡nh spam
                task.wait(0.3)
                
                -- Äáº·t láº¡i danh sÃ¡ch
                petsToSell = {}
            end
        end
    end
    
    -- BÃ¡n ná»‘t nhá»¯ng pet cÃ²n láº¡i (náº¿u cÃ³)
    if #petsToSell > 0 then
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "SellPet",
                    ["Pets"] = petsToSell
                },
                [2] = "\t"
            }
        }
        remote:FireServer(unpack(args))
        print("ÄÃ£ bÃ¡n", #petsToSell, "pet cÃ²n láº¡i vá»›i rank Ä‘Ã£ chá»n")
    end
end

-- NÃºt Ä‘á»ƒ bÃ¡n ngay
Tabs.shop:AddButton({
    Title = "Sell Now",
    Description = "Sell all pets with selected ranks immediately",
    Callback = function()
        if #selectedRanks > 0 then
            sellPetsByRank()
        else
            Fluent:Notify({
                Title = "ChÆ°a chá»n rank",
                Content = "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t rank Ä‘á»ƒ bÃ¡n pet",
                Duration = 3
            })
        end
    end
})

-- Toggle Ä‘á»ƒ báº­t/táº¯t Auto Sell
Tabs.shop:AddToggle("AutoSellToggle", {
    Title = "Auto Sell Pets",
    Default = ConfigSystem.CurrentConfig.AutoSellEnabled or false,
    Callback = function(state)
        autoSellEnabled = state
        ConfigSystem.CurrentConfig.AutoSellEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if #selectedRanks > 0 then
                Fluent:Notify({
                    Title = "Auto Sell Ä‘Ã£ báº­t",
                    Content = "Sáº½ tá»± Ä‘á»™ng bÃ¡n pet vá»›i cÃ¡c rank: " .. table.concat(selectedRanks, ", "),
                    Duration = 3
                })
                
                task.spawn(function()
                    while autoSellEnabled do
                        sellPetsByRank()
                        task.wait(5) -- Äá»£i 5 giÃ¢y giá»¯a má»—i láº§n kiá»ƒm tra vÃ  bÃ¡n
                    end
                end)
            else
                Fluent:Notify({
                    Title = "ChÆ°a chá»n rank",
                    Content = "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t rank Ä‘á»ƒ bÃ¡n pet",
                    Duration = 3
                })
            end
        end
    end
})
-- ==========================
-- FunÃ§Ãµes auxiliares compartilhadas
-- ==========================
local function createDungeon()
    print("[DEBUG] Tentando criar dungeon...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("âœ” Dungeon criada.")
    task.wait(3)

    -- Iniciar a dungeon
    local iniciarArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(iniciarArgs))
    print("â–¶ Dungeon iniciada.")
end

local function leaveDungeon()
    print("[AUTO-EXIT] Saindo da dungeon...")
    local args = {
        [1] = {
            [1] = { ["Event"] = "LeaveDungeon" },
            [2] = "\12"
        }
    }
    pcall(function()
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    end)
end

local function getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function getClosestEnemy()
    local enemiesFolder = workspace.__Main.__Enemies.Server
    local closestEnemy = nil
    local closestDistance = math.huge
    local player = game.Players.LocalPlayer
    local playerCharacter = player.Character

    if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") then 
        return nil 
    end
    local playerPosition = playerCharacter.HumanoidRootPart.Position

    for _, enemy in pairs(enemiesFolder:GetChildren()) do
        local hp = enemy:GetAttribute("HP")
        if hp and hp > 0 and enemy.Position then
            local distance = getDistance(playerPosition, enemy.Position)
            if distance < closestDistance then
                closestDistance = distance
                closestEnemy = enemy
            end
        end
    end

    return closestEnemy
end

local function moveToEnemy(enemy, currentTween)
    local tweenService = game:GetService("TweenService")
    local player = game.Players.LocalPlayer
    local playerCharacter = player.Character
    if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") or not enemy.Position then
        return false, currentTween
    end

    if currentTween then
        currentTween:Cancel()
    end

    playerCharacter.PrimaryPart = playerCharacter.HumanoidRootPart
    playerCharacter.HumanoidRootPart.Anchored = false

    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    currentTween = tweenService:Create(playerCharacter.PrimaryPart, tweenInfo, {CFrame = enemy.CFrame})

    currentTween:Play()

    task.spawn(function()
        currentTween.Completed:Wait()
        currentTween = nil
    end)

    return true, currentTween
end

-- ==========================
-- SISTEMA 1: Auto Farm Dungeon INF
-- ==========================
ConfigSystem.DefaultConfig.AutoFarmDungeonINF = ConfigSystem.DefaultConfig.AutoFarmDungeonINF or false
ConfigSystem.CurrentConfig.AutoFarmDungeonINF = ConfigSystem.CurrentConfig.AutoFarmDungeonINF or ConfigSystem.DefaultConfig.AutoFarmDungeonINF

-- VariÃ¡veis especÃ­ficas do sistema INF
local teleportINFEnabled = ConfigSystem.CurrentConfig.AutoFarmDungeonINF
local currentTweenINF = nil
local lastEnemyCheckINF = tick()
local maxTimeWithoutEnemiesINF = 5

local function monitorEnemiesINF()
    print("[AUTO-FARM INF] Iniciando auto farm (sair da dungeon apÃ³s 5s sem mobs).")

    while teleportINFEnabled do
        pcall(function()
            -- â° Checa horÃ¡rio do Castle Infernal
            local hora = os.date("*t")
            local minuto = hora.min

            if (minuto >= 15 and minuto < 30) or (minuto >= 45 and minuto < 55) then
                leaveDungeon()
                print(string.format("[AUTO-EXIT INF] Saiu da dungeon Ã s %02d:%02d (horÃ¡rio Castle)", hora.hour, hora.min))
                task.wait(60) -- espera 1 min antes de verificar de novo
            else
                if not workspace:FindFirstChild("__Main") then
                    -- nÃ£o estÃ¡ dentro da dungeon -> cria e inicia
                    createDungeon()
                    task.wait(5)
                else
                    local closestEnemy = getClosestEnemy()
                    local currentTime = tick()

                    if closestEnemy then
                        lastEnemyCheckINF = currentTime
                        print("[AUTO-FARM INF] Movendo para inimigo:", closestEnemy.Name)

                        local success
                        success, currentTweenINF = moveToEnemy(closestEnemy, currentTweenINF)
                        
                        if success then
                            local attempts = 0
                            while teleportINFEnabled 
                                  and closestEnemy.Parent 
                                  and closestEnemy:GetAttribute("HP") 
                                  and closestEnemy:GetAttribute("HP") > 0 
                                  and attempts < 100 do
                                task.wait(0.1)
                                attempts += 1
                            end
                            print("[AUTO-FARM INF] Inimigo eliminado!")
                        end
                    else
                        local timeWithoutEnemies = currentTime - lastEnemyCheckINF
                        if timeWithoutEnemies >= maxTimeWithoutEnemiesINF then
                            print("[AUTO-EXIT INF] Nenhum inimigo encontrado em 5s. Saindo da dungeon...")
                            leaveDungeon()
                            task.wait(10) -- espera 10s fora antes de tentar recriar
                        else
                            task.wait(1)
                        end
                    end
                end
            end
        end)

        task.wait(0.1)
    end

    if currentTweenINF then
        currentTweenINF:Cancel()
        currentTweenINF = nil
    end
    print("[AUTO-FARM INF] Auto farm desativado.")
end

-- ==========================
-- SISTEMA 2: Auto Farm Dungeon (RecriaÃ§Ã£o)
-- ==========================
ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate = ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate or false
ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate or ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate

-- VariÃ¡veis especÃ­ficas do sistema Recreate
local teleportRecreateEnabled = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate
local currentTweenRecreate = nil
local lastEnemyCheckRecreate = tick()
local maxTimeWithoutEnemiesRecreate = 5

local function recreateDungeon()
    print("[AUTO-RECREATE] Sem inimigos por muito tempo. Recriando dungeon...")

    if currentTweenRecreate then
        currentTweenRecreate:Cancel()
        currentTweenRecreate = nil
    end

    createDungeon()
    lastEnemyCheckRecreate = tick()
    task.wait(5)
end

local function monitorEnemiesRecreate()
    print("[AUTO-FARM RECREATE] Iniciando auto farm com recriaÃ§Ã£o automÃ¡tica (5s sem mobs).")

    while teleportRecreateEnabled do
        pcall(function()
            -- â° Checa horÃ¡rio
            local hora = os.date("*t")
            local minuto = hora.min

            if (minuto >= 15 and minuto < 30) or (minuto >= 45 and minuto < 55) then
                leaveDungeon()
                print(string.format("[AUTO-EXIT RECREATE] Saiu da dungeon Ã s %02d:%02d (horÃ¡rio bloqueado)", hora.hour, hora.min))
                task.wait(60)
            else
                if not workspace:FindFirstChild("__Main") then
                    createDungeon()
                    task.wait(5)
                end

                local closestEnemy = getClosestEnemy()
                local currentTime = tick()

                if closestEnemy then
                    lastEnemyCheckRecreate = currentTime
                    print("[AUTO-FARM RECREATE] Movendo para inimigo:", closestEnemy.Name)

                    local success
                    success, currentTweenRecreate = moveToEnemy(closestEnemy, currentTweenRecreate)
                    
                    if success then
                        local attempts = 0
                        while teleportRecreateEnabled 
                              and closestEnemy.Parent 
                              and closestEnemy:GetAttribute("HP") 
                              and closestEnemy:GetAttribute("HP") > 0 
                              and attempts < 100 do
                            task.wait(0.1)
                            attempts += 1
                        end
                        print("[AUTO-FARM RECREATE] Inimigo eliminado!")
                    end
                else
                    local timeWithoutEnemies = currentTime - lastEnemyCheckRecreate
                    if timeWithoutEnemies >= maxTimeWithoutEnemiesRecreate then
                        recreateDungeon()
                    else
                        local remainingTime = maxTimeWithoutEnemiesRecreate - timeWithoutEnemies
                        if math.floor(remainingTime) % 5 == 0 then
                            print(string.format("[AUTO-FARM RECREATE] Sem inimigos hÃ¡ %.1fs. Recriando em %.1fs...", 
                                timeWithoutEnemies, remainingTime))
                        end
                    end
                    task.wait(1)
                end
            end
        end)

        task.wait(0.1)
    end

    if currentTweenRecreate then
        currentTweenRecreate:Cancel()
        currentTweenRecreate = nil
    end
    print("[AUTO-FARM RECREATE] Auto farm desativado.")
end

-- ==========================
-- Toggles separados
-- ==========================

-- Toggle para Dungeon INF
Tabs.dungeon:AddToggle("DungeonINF", {
    Title = "Dungeon INF",
    Default = ConfigSystem.CurrentConfig.AutoFarmDungeonINF,
    Flag = "AutoFarmDungeonINF",
    Callback = function(state)
        teleportINFEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmDungeonINF = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(monitorEnemiesINF)
        else
            if currentTweenINF then
                currentTweenINF:Cancel()
                currentTweenINF = nil
            end
            print("[AUTO-FARM INF] Desativado pelo usuÃ¡rio.")
        end
    end
})

-- Toggle para Auto Farm Dungeon (com recriaÃ§Ã£o)
Tabs.dungeon:AddToggle("AutoFarmDungeon", {
    Title = "Auto Farm Dungeon",
    Default = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate,
    Flag = "AutoFarmDungeonRecreate",
    Callback = function(state)
        teleportRecreateEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(monitorEnemiesRecreate)
        else
            if currentTweenRecreate then
                currentTweenRecreate:Cancel()
                currentTweenRecreate = nil
            end
            print("[AUTO-FARM RECREATE] Desativado pelo usuÃ¡rio.")
        end
    end
})

-- Sistema de Castelo - Auto Castle atualizado
local castleEnabled = false
local autoLeaveEnabled = false
local targetFloor = 10 -- Andar para sair automaticamente

-- FunÃ§Ã£o para detectar o andar atual
local function getCurrentFloor()
    local main = workspace.__Main
    local world = main.__World
    
    for i = 1, 200 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local foundPortal = room:FindFirstChild("FirePortal")
            if foundPortal then
                return i
            end
        end
    end
    return nil
end

-- FunÃ§Ã£o para teleportar para FirePortal
local function teleportToFirePortal()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local hrp = char.HumanoidRootPart
    local main = workspace.__Main
    local world = main.__World
    local portal = nil
    local currentFloor = nil
    
    for i = 1, 200 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local foundPortal = room:FindFirstChild("FirePortal")
            if foundPortal then
                portal = foundPortal
                currentFloor = i
                break
            end
        end
    end
    
    if not portal then
        warn("FirePortal nÃ£o encontrado!")
        return false
    end
    
    hrp.CFrame = portal.CFrame
    hrp.Velocity = Vector3.zero
    
    print("Teleportado para o portal do andar " .. currentFloor)
    return true, currentFloor
end

-- FunÃ§Ã£o para ativar o FirePortal
local function activateFirePortal()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local main = workspace.__Main
    local world = main.__World
    local portal = nil
    local currentFloor = nil
    
    for i = 1, 200 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local foundPortal = room:FindFirstChild("FirePortal")
            if foundPortal then
                portal = foundPortal
                currentFloor = i
                break
            end
        end
    end
    
    if not portal then
        return false
    end
    
    local prompt = portal:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        for _, obj in ipairs(portal:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                prompt = obj
                break
            end
        end
    end
    
    if not prompt and portal.Parent then
        prompt = portal.Parent:FindFirstChildOfClass("ProximityPrompt")
    end
    
    if prompt then
        for i = 1, 3 do
            fireproximityprompt(prompt)
            task.wait(0.05)
        end
        print("Portal ativado! Subindo do andar " .. currentFloor .. " para o andar " .. (currentFloor + 1))
        return true
    else
        warn("ProximityPrompt nÃ£o encontrado!")
        return false
    end
end

-- FunÃ§Ã£o principal do auto castle
local function autoCastle()
    while castleEnabled do
        local currentFloor = getCurrentFloor()
        
        if currentFloor then
            print("Andar atual: " .. currentFloor)
            
            if autoLeaveEnabled and currentFloor >= targetFloor then
                Fluent:Notify({
                    Title = "Auto Leave",
                    Content = "Atingiu o andar " .. currentFloor .. ". Saindo do castle...",
                    Duration = 3
                })
                
                SetSpawnAndReset("SoloWorld")
                castleEnabled = false
                break
            end
            
            local teleported, floor = teleportToFirePortal()
            if teleported then
                task.wait(0.5)
                if activateFirePortal() then
                    task.wait(2)
                else
                    task.wait(1)
                end
            else
                task.wait(2)
            end
        else
            print("NÃ£o foi possÃ­vel detectar o andar atual")
            task.wait(3)
        end
        
        task.wait(1)
    end
end

Tabs.dungeon:AddSection("Castle Functions")

Tabs.dungeon:AddInput("TargetFloorInput", {
    Title = "Target Floor (Auto Leave)",
    Default = tostring(targetFloor),
    Placeholder = "Enter floor number",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            targetFloor = floor
            print("Andar alvo definido para: " .. targetFloor)
        end
    end
})

Tabs.dungeon:AddToggle("AutoLeave", {
    Title = "Auto Leave at Target Floor",
    Default = false,
    Callback = function(state)
        autoLeaveEnabled = state
        if state then
            print("Auto Leave ativado para o andar: " .. targetFloor)
        else
            print("Auto Leave desativado")
        end
    end
})

Tabs.dungeon:AddButton({
    Title = "Teleport to Fire Portal",
    Description = "Instantly teleport to the current floor's fire portal",
    Callback = function()
        local success, floor = teleportToFirePortal()
        if success then
            Fluent:Notify({
                Title = "Teleportado",
                Content = "Teleportado para o portal do andar " .. floor,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Erro",
                Content = "NÃ£o foi possÃ­vel encontrar o FirePortal",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddButton({
    Title = "Activate Fire Portal",
    Description = "Activate the fire portal to go to next floor",
    Callback = function()
        if activateFirePortal() then
            Fluent:Notify({
                Title = "Portal Ativado",
                Content = "Portal foi ativado com sucesso",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Erro",
                Content = "NÃ£o foi possÃ­vel ativar o portal",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddButton({
    Title = "Show Current Floor",
    Description = "Display the current floor number",
    Callback = function()
        local floor = getCurrentFloor()
        if floor then
            Fluent:Notify({
                Title = "Andar Atual",
                Content = "VocÃª estÃ¡ no andar: " .. floor,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Erro",
                Content = "NÃ£o foi possÃ­vel detectar o andar atual",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddToggle("AutoCastle", {
    Title = "Auto Castle (Portal Climber)",
    Default = false,
    Callback = function(state)
        castleEnabled = state
        if state then
            Fluent:Notify({
                Title = "Auto Castle Ativado",
                Content = "Subindo andares automaticamente" .. (autoLeaveEnabled and " (sairÃ¡ no andar " .. targetFloor .. ")" or ""),
                Duration = 3
            })
            task.spawn(autoCastle)
        else
            Fluent:Notify({
                Title = "Auto Castle Desativado",
                Content = "Parou de subir andares automaticamente",
                Duration = 3
            })
        end
    end
})

-- ==========================
-- Auto INF (Castle Farm) com salvamento, auto-boot, 3 tentativas e cooldown por andar
-- ==========================

-- 1) Garantir chaves no ConfigSystem (usa "CastleToggle" que vocÃª jÃ¡ usa e persiste)
if ConfigSystem.DefaultConfig.CastleToggle == nil then
    ConfigSystem.DefaultConfig.CastleToggle = false
end
if ConfigSystem.CurrentConfig.CastleToggle == nil then
    ConfigSystem.CurrentConfig.CastleToggle = ConfigSystem.DefaultConfig.CastleToggle
end

-- 2) VariÃ¡veis de controle
local castleEnabled = false
local lastUsedFloor = nil
local floorCooldown = {} -- salva tick() do Ãºltimo fail por andar

-- 3) FunÃ§Ãµes auxiliares
local function startAutoCastle()
    if castleEnabled then return end
    castleEnabled = true

    task.spawn(function()
        local tweenService = game:GetService("TweenService")
        local player = game.Players.LocalPlayer
        local enemiesFolder = workspace.__Main.__Enemies.Server
        local main = workspace.__Main
        local world = main.__World

        local function getClosestEnemy()
            local closestEnemy, closestDistance = nil, math.huge
            local playerCharacter = player.Character
            if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") then 
                return nil 
            end
            local playerPosition = playerCharacter.HumanoidRootPart.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy.Position then
                    local d = (playerPosition - enemy.Position).Magnitude
                    if d < closestDistance then
                        closestDistance = d
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            local playerCharacter = player.Character
            if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") or not enemy or not enemy.CFrame then
                return false
            end
            playerCharacter.PrimaryPart = playerCharacter.HumanoidRootPart
            playerCharacter.HumanoidRootPart.Anchored = false
            local tweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
            local tween = tweenService:Create(playerCharacter.PrimaryPart, tweenInfo, {CFrame = enemy.CFrame})
            tween:Play()
            tween.Completed:Wait()
            return true
        end

        local function findFirePortal()
            for i = 1, 200 do
                local room = world:FindFirstChild("Room_" .. i)
                if room then
                    local foundPortal = room:FindFirstChild("FirePortal")
                    if foundPortal then
                        return foundPortal, i
                    end
                end
            end
            return nil, nil
        end

        local function teleportToPortal(portal)
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:WaitForChild("HumanoidRootPart")
            -- levemente Ã  frente/alto pra evitar clip
            local target = portal.CFrame * CFrame.new(0, 2, -2)
            hrp.CFrame = target
            hrp.Velocity = Vector3.zero
            task.wait(0.1)
        end

        -- Tenta ativar o portal atÃ© 3 vezes; se falhar, cooldown de 10s
        local function activatePortal(portal, currentFloor)
            if lastUsedFloor == currentFloor then
                return false
            end

            -- checa cooldown
            local now = tick()
            if floorCooldown[currentFloor] and now - floorCooldown[currentFloor] < 10 then
                return false
            end

            local function getPrompt(p)
                if not p then return nil end
                local prompt = p:FindFirstChildOfClass("ProximityPrompt")
                if prompt then return prompt end
                for _, obj in ipairs(p:GetDescendants()) do
                    if obj:IsA("ProximityPrompt") then
                        return obj
                    end
                end
                if p.Parent then
                    return p.Parent:FindFirstChildOfClass("ProximityPrompt")
                end
                return nil
            end

            local success = false
            for attempt = 1, 3 do
                if not castleEnabled then break end
                local prompt = getPrompt(portal)
                if prompt then
                    -- dispara algumas vezes no mesmo attempt pra garantir
                    for _ = 1, 3 do
                        pcall(function()
                            if prompt.HoldDuration and prompt.HoldDuration > 0 then
                                fireproximityprompt(prompt, 1)
                            else
                                fireproximityprompt(prompt)
                            end
                        end)
                        task.wait(0.1)
                    end
                    print(("ðŸš€ [Tentativa %d/3] Ativando portal do andar %d"):format(attempt, currentFloor))
                    lastUsedFloor = currentFloor
                    success = true
                    break
                else
                    warn(("âš ï¸ Prompt nÃ£o encontrado (tentativa %d/3)."):format(attempt))
                end
                task.wait(0.75)
            end

            if success then
                print("âœ… Portal ativado! Indo para o andar " .. (currentFloor + 1))
            else
                floorCooldown[currentFloor] = tick() -- cooldown de 10s
                warn("â¹ï¸ NÃ£o foi possÃ­vel ativar apÃ³s 3 tentativas. Cooldown iniciado para este andar.")
            end

            return success
        end

        -- loop principal
        while castleEnabled do
            local enemy = getClosestEnemy()
            if enemy then
                moveToEnemy(enemy)
                while enemy.Parent and (enemy:GetAttribute("HP") or 1) > 0 and castleEnabled do
                    task.wait(0.2)
                end
            else
                local portal, floor = findFirePortal()
                if portal and floor and lastUsedFloor ~= floor then
                    print("ðŸ“ Andar atual: " .. floor)
                    teleportToPortal(portal)
                    activatePortal(portal, floor) -- tenta 3x e respeita cooldown
                    task.wait(2)
                end
            end
            task.wait(0.2)
        end
    end)
end

local function stopAutoCastle()
    castleEnabled = false
end

-- 4) Toggle (usa a mesma chave que persiste: CastleToggle)
Tabs.dungeon:AddToggle("AutoCastle", {
    Title = "Auto INF (Castle Farm)",
    Default = ConfigSystem.CurrentConfig.CastleToggle or false,
    Callback = function(state)
        ConfigSystem.CurrentConfig.CastleToggle = state
        ConfigSystem.SaveConfig()

        if state then
            Fluent:Notify({ Title = "Auto Castle", Content = "Ativado", Duration = 3 })
            startAutoCastle()
        else
            Fluent:Notify({ Title = "Auto Castle", Content = "Desativado", Duration = 3 })
            stopAutoCastle()
        end
    end
})

-- 5) Auto-boot (pra UIs que nÃ£o disparam o Callback na carga)
if ConfigSystem.CurrentConfig.CastleToggle then
    startAutoCastle()
end

-- Auto Castle (com failsafe de saÃ­da e entrada configurÃ¡vel)

castleEnabled = false
local castleSessionActive = false

-- =======================
-- ConfiguraÃ§Ã£o do andar de saÃ­da (padrÃ£o 101)
ConfigSystem.DefaultConfig.CastleExitFloor = ConfigSystem.DefaultConfig.CastleExitFloor or 101
ConfigSystem.CurrentConfig.CastleExitFloor = ConfigSystem.CurrentConfig.CastleExitFloor or ConfigSystem.DefaultConfig.CastleExitFloor
local exitFloor = ConfigSystem.CurrentConfig.CastleExitFloor

Tabs.dungeon:AddInput("CastleExitFloor", {
    Title = "Castle Exit Floor",
    Default = tostring(exitFloor),
    Placeholder = "Andar para sair",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            exitFloor = floor
            ConfigSystem.CurrentConfig.CastleExitFloor = floor
            ConfigSystem.SaveConfig()
            warn("[Castle] Andar de saÃ­da atualizado para:", floor)
        end
    end
})

-- ConfiguraÃ§Ã£o do andar de entrada (padrÃ£o 1)
ConfigSystem.DefaultConfig.CastleEntryFloor = ConfigSystem.DefaultConfig.CastleEntryFloor or 1
ConfigSystem.CurrentConfig.CastleEntryFloor = ConfigSystem.CurrentConfig.CastleEntryFloor or ConfigSystem.DefaultConfig.CastleEntryFloor
local entryFloor = ConfigSystem.CurrentConfig.CastleEntryFloor

Tabs.dungeon:AddInput("CastleEntryFloor", {
    Title = "Castle Entry Floor",
    Default = tostring(entryFloor),
    Placeholder = "Andar de entrada",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            entryFloor = floor
            ConfigSystem.CurrentConfig.CastleEntryFloor = floor
            ConfigSystem.SaveConfig()
            warn("[Castle] Andar de entrada atualizado para:", floor)
        end
    end
})

-- Detectar andar atual (pega sÃ³ o maior Room ativo)
local function getCurrentCastleFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    local current = nil
    for i = 1, 200 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end

    if current then
        warn("[Castle] Andar atual detectado:", current)
    else
        warn("[Castle] Fora do castelo (nenhuma Room encontrada).")
    end
    return current
end

-- Comprar ticket com gems
local function buyCastleTicket()
    warn("[Castle] Tentando comprar ticket com Gems...")
    local args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "CastleAction",
                ["Action"] = "BuyTicket"
            },
            [2] = "\12"
        }
    }
    local ok, err = pcall(function() remote:FireServer(unpack(args)) end)
    if ok then
        warn("[Castle] Ticket comprado com sucesso.")
    else
        warn("[Castle] Erro ao comprar ticket:", err)
    end
end

-- Entrar no castelo
local function joinCastle()
    warn("[Castle] Tentando entrar no andar " .. tostring(entryFloor) .. "...")
    local joinArgs = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(entryFloor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\12"
        }
    }
    local ok, err = pcall(function() remote:FireServer(unpack(joinArgs)) end)
    if ok then
        warn("[Castle] Join enviado com sucesso.")
    else
        warn("[Castle] Erro ao entrar:", err)
    end
end

-- Sair do castelo
local function leaveCastle()
    warn("[Castle] Tentando sair...")
    local leaveArgs = {
        [1] = {
            [1] = { ["Event"] = "LeaveDungeon" },
            [2] = "\12"
        }
    }
    local ok, err = pcall(function() remote:FireServer(unpack(leaveArgs)) end)
    if ok then
        warn("[Castle] Leave enviado com sucesso.")
    else
        warn("[Castle] Erro ao sair:", err)
    end
end

-- Failsafe: tenta sair repetidamente atÃ© estar fora
local function forceLeaveUntilOut()
    task.spawn(function()
        while castleEnabled do
            local floor = getCurrentCastleFloor()
            if not floor then
                warn("[Castle] Confirmado fora do castelo (failsafe concluÃ­do).")
                break
            end
            warn("[Castle] Ainda dentro do castelo â†’ Tentando sair novamente (failsafe).")
            leaveCastle()
            task.wait(10)
        end
    end)
end

-- Loop principal
function autoCastle()
    task.spawn(function()
        warn("[Castle] Loop iniciado!")
        while castleEnabled do
            local currentFloor = getCurrentCastleFloor()

            if not currentFloor then
                -- Fora do castelo â†’ compra ticket e entra
                buyCastleTicket()
                task.wait(1)
                joinCastle()
                task.wait(5)
            else
                if currentFloor >= exitFloor then
                    warn("[Castle] AlcanÃ§ou o andar de saÃ­da (" .. currentFloor .. ") â†’ Saindo...")
                    leaveCastle()

                    Fluent:Notify({
                        Title = "Castle",
                        Content = "Saiu no andar " .. tostring(exitFloor) .. ", reiniciando...",
                        Duration = 3
                    })

                    -- Inicia failsafe atÃ© sair realmente
                    forceLeaveUntilOut()

                    -- Aguarda, compra ticket e reinicia
                    task.wait(5)
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle()
                    task.wait(3)
                end

                -- Farm de mobs
                local mobsFolder = workspace:FindFirstChild("Enemies") or workspace:FindFirstChild("Mobs")
                if mobsFolder then
                    for _, mob in pairs(mobsFolder:GetChildren()) do
                        if not castleEnabled then break end
                        local hrp = mob:FindFirstChild("HumanoidRootPart")
                        local hum = mob:FindFirstChild("Humanoid")
                        if hrp and hum and hum.Health > 0 then
                            local plr = game.Players.LocalPlayer
                            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                                plr.Character.HumanoidRootPart.CFrame = hrp.CFrame * CFrame.new(0, 3, 0)
                            end
                            pcall(function()
                                remote:FireServer("Attack", mob)
                            end)
                            warn("[Castle] Atacando mob:", mob.Name)
                            task.wait(0.25)
                        end
                    end
                end
            end

            task.wait(0.5)
        end
        warn("[Castle] Loop encerrado.")
    end)
end

-- Toggle do Auto Castle
Tabs.dungeon:AddToggle("CastleToggle", {
    Title = "Auto Castle",
    Default = ConfigSystem.CurrentConfig.CastleToggle or false,
    Callback = function(state)
        castleEnabled = state
        ConfigSystem.CurrentConfig.CastleToggle = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(function()
                warn("[Castle] Ativado â†’ Entrando...")
                buyCastleTicket()
                task.wait(1)
                joinCastle()
                task.wait(2)

                castleSessionActive = true
                autoCastle()

                pcall(function()
                    Fluent:Notify({
                        Title = "Castle Ativado",
                        Content = "Castle iniciado no andar " .. tostring(entryFloor) .. " (sairÃ¡ no " .. tostring(exitFloor) .. ")",
                        Duration = 3
                    })
                end)
            end)
        else
            if castleSessionActive then
                leaveCastle()
                castleSessionActive = false
            end

            pcall(function()
                Fluent:Notify({
                    Title = "Castle Desativado",
                    Content = "Saiu do Castle.",
                    Duration = 3
                })
            end)
        end
    end
})
-- ==========================
-- ConfiguraÃ§Ã£o Deserto Infinito (VERSÃƒO CORRIGIDA)
-- ==========================

if ConfigSystem.DefaultConfig.DesertInfiniteToggle == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteToggle = false
end
if ConfigSystem.CurrentConfig.DesertInfiniteToggle == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteToggle = ConfigSystem.DefaultConfig.DesertInfiniteToggle
end

if ConfigSystem.DefaultConfig.DesertInfiniteSpeed == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteSpeed = 2
end
if ConfigSystem.CurrentConfig.DesertInfiniteSpeed == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteSpeed = ConfigSystem.DefaultConfig.DesertInfiniteSpeed
end

if ConfigSystem.DefaultConfig.DesertInfiniteTeleport == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteTeleport = false
end
if ConfigSystem.CurrentConfig.DesertInfiniteTeleport == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteTeleport = ConfigSystem.DefaultConfig.DesertInfiniteTeleport
end

-- Nova configuraÃ§Ã£o para auto velocidade
if ConfigSystem.DefaultConfig.DesertAutoSpeed == nil then
    ConfigSystem.DefaultConfig.DesertAutoSpeed = false
end
if ConfigSystem.CurrentConfig.DesertAutoSpeed == nil then
    ConfigSystem.CurrentConfig.DesertAutoSpeed = ConfigSystem.DefaultConfig.DesertAutoSpeed
end

local desertEnabled = ConfigSystem.CurrentConfig.DesertInfiniteToggle
local teleportEnabled = ConfigSystem.CurrentConfig.DesertInfiniteTeleport
local speedValue = ConfigSystem.CurrentConfig.DesertInfiniteSpeed
local autoSpeedEnabled = ConfigSystem.CurrentConfig.DesertAutoSpeed

local teleportPosition = CFrame.new(474.099365, 4454.42578, -1875.93811, 0, 0, -1, 1, 0, 0, 0, -1, 0)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2").dataRemoteEvent
local player = game.Players.LocalPlayer

-- ==========================
-- Controle de SessÃ£o Melhorado
-- ==========================
local desertSessionActive = false
local lastDesertCheck = 0
local CHECK_INTERVAL = 2 -- segundos entre verificaÃ§Ãµes
local autoSpeedLoop = false

-- MÃºltiplas formas de detectar se estÃ¡ no deserto
local function estaNoDeserto()
    local currentTime = tick()
    
    -- Evita verificaÃ§Ãµes muito frequentes
    if currentTime - lastDesertCheck < CHECK_INTERVAL then
        return desertSessionActive
    end
    
    lastDesertCheck = currentTime
    
    -- MÃ©todo 1: Verificar workspace.__Main.__World
    local main = workspace:FindFirstChild("__Main")
    if main then
        local world = main:FindFirstChild("__World")
        if world and world.Name == "InfiniteDesert" then
            warn("[Deserto Infinito] Detectado pelo nome do mundo: InfiniteDesert")
            return true
        end
    end
    
    -- MÃ©todo 2: Verificar posiÃ§Ã£o do jogador (coordenadas tÃ­picas do deserto)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        -- Verificar se estÃ¡ em coordenadas altas (tÃ­picas do deserto infinito)
        if pos.Y > 4000 then
            warn("[Deserto Infinito] Detectado pela posiÃ§Ã£o Y alta:", pos.Y)
            return true
        end
    end
    
    -- MÃ©todo 3: Verificar por objetos especÃ­ficos do deserto
    local lighting = game:GetService("Lighting")
    if lighting:FindFirstChild("DesertAmbient") or lighting:FindFirstChild("InfiniteDesert") then
        warn("[Deserto Infinito] Detectado por lighting especÃ­fico")
        return true
    end
    
    -- MÃ©todo 4: Verificar ReplicatedStorage por dados do deserto
    if ReplicatedStorage:FindFirstChild("InfiniteMode") then
        local infiniteMode = ReplicatedStorage.InfiniteMode
        if infiniteMode:FindFirstChild("Active") and infiniteMode.Active.Value == true then
            warn("[Deserto Infinito] Detectado por ReplicatedStorage.InfiniteMode")
            return true
        end
    end
    
    -- MÃ©todo 5: Verificar pela existÃªncia de modelos especÃ­ficos do deserto
    for _, obj in pairs(workspace:GetChildren()) do
        if string.find(string.lower(obj.Name), "desert") or 
           string.find(string.lower(obj.Name), "infinite") or
           string.find(string.lower(obj.Name), "sand") then
            warn("[Deserto Infinito] Detectado por objeto no workspace:", obj.Name)
            return true
        end
    end
    
    return false
end

-- FunÃ§Ã£o para resetar o estado da sessÃ£o
local function resetarEstadoSessao()
    desertSessionActive = false
    pararAutoVelocidade()
    warn("[Deserto Infinito] Estado da sessÃ£o resetado")
end

-- Monitorar saÃ­da do deserto
local function monitorarSaidaDeserto()
    task.spawn(function()
        while desertSessionActive do
            task.wait(5) -- Verificar a cada 5 segundos
            if not estaNoDeserto() then
                warn("[Deserto Infinito] Saiu do deserto, resetando sessÃ£o")
                resetarEstadoSessao()
                break
            end
        end
    end)
end

-- ==========================
-- FunÃ§Ãµes principais
-- ==========================
local function iniciarDesertoInfinito()
    -- VerificaÃ§Ã£o tripla antes de criar
    if desertSessionActive then
        warn("[Deserto Infinito] SessÃ£o jÃ¡ ativa, cancelando criaÃ§Ã£o")
        return
    end
    
    if estaNoDeserto() then
        warn("[Deserto Infinito] JÃ¡ estÃ¡ no deserto, cancelando criaÃ§Ã£o")
        desertSessionActive = true
        monitorarSaidaDeserto()
        -- Aplicar velocidade mesmo se jÃ¡ estiver no deserto
        aplicarVelocidade(speedValue)
        return
    end

    warn("[Deserto Infinito] Iniciando nova sessÃ£o...")
    desertSessionActive = true

    -- Criar com delay para evitar spam
    task.spawn(function()
        local argsCreate = {
            [1] = {
                [1] = {
                    ["Event"] = "InfiniteModeAction",
                    ["Action"] = "Create"
                },
                [2] = "\12"
            }
        }
        remote:FireServer(unpack(argsCreate))
        warn("[Deserto Infinito] Comando Create enviado")

        task.wait(3) -- Aguardar mais tempo

        -- Verificar novamente antes de enviar Start
        if not estaNoDeserto() then
            local argsStart = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = 7368292297,
                        ["Event"] = "InfiniteModeAction",
                        ["Action"] = "Start"
                    },
                    [2] = "\12"
                }
            }
            remote:FireServer(unpack(argsStart))
            warn("[Deserto Infinito] Comando Start enviado")
        else
            warn("[Deserto Infinito] JÃ¡ no deserto, pulando comando Start")
        end
        
        -- Aguardar um pouco mais e aplicar velocidade
        task.wait(2)
        aplicarVelocidade(speedValue)
        
        -- Iniciar auto velocidade se estiver ativada
        if autoSpeedEnabled then
            iniciarAutoVelocidade()
        end
        
        -- Iniciar monitoramento
        monitorarSaidaDeserto()
    end)
end

local function aplicarVelocidade(valor)
    -- SÃ³ aplicar se estivermos realmente no deserto
    if not estaNoDeserto() then
        warn("[Deserto Infinito] NÃ£o estÃ¡ no deserto, nÃ£o aplicando velocidade")
        return
    end
    
    local argsSpeed = {
        [1] = {
            [1] = {
                ["Speed"] = valor,
                ["Event"] = "InfiniteModeAction",
                ["Action"] = "SpeedUp"
            },
            [2] = "\12"
        }
    }
    remote:FireServer(unpack(argsSpeed))
    warn("[Deserto Infinito] Velocidade ajustada para:", valor)
end

-- Nova funÃ§Ã£o para auto velocidade contÃ­nua
local function iniciarAutoVelocidade()
    if autoSpeedLoop then
        warn("[Deserto Infinito] Auto velocidade jÃ¡ estÃ¡ rodando")
        return
    end
    
    autoSpeedLoop = true
    warn("[Deserto Infinito] Auto velocidade ativada")
    
    task.spawn(function()
        while autoSpeedEnabled and autoSpeedLoop do
            if estaNoDeserto() then
                aplicarVelocidade(speedValue)
                task.wait(3) -- Aplicar velocidade a cada 3 segundos
            else
                task.wait(1)
            end
        end
        autoSpeedLoop = false
        warn("[Deserto Infinito] Auto velocidade desativada")
    end)
end

local function pararAutoVelocidade()
    autoSpeedEnabled = false
    autoSpeedLoop = false
    warn("[Deserto Infinito] Auto velocidade parada")
end

local function manterTeleport()
    task.spawn(function()
        while teleportEnabled do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and estaNoDeserto() then
                -- Teleportar para a posiÃ§Ã£o
                player.Character.HumanoidRootPart.CFrame = teleportPosition
                
                -- Parar completamente o personagem
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                    humanoid.PlatformStand = true
                end
                
                -- Zerar velocidade
                local rootPart = player.Character.HumanoidRootPart
                if rootPart then
                    rootPart.Velocity = Vector3.new(0, 0, 0)
                    rootPart.AngularVelocity = Vector3.new(0, 0, 0)
                end
            end
            task.wait(0.1) -- VerificaÃ§Ã£o mais frequente para manter parado
        end
        
        -- Quando desativar teleport, liberar o personagem
        if player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid:ChangeState(Enum.HumanoidStateType.Running)
            end
        end
    end)
end

-- Detectar mudanÃ§as no workspace para resetar estado se necessÃ¡rio
workspace.ChildAdded:Connect(function(child)
    task.wait(1) -- Pequeno delay
    if desertSessionActive and not estaNoDeserto() then
        resetarEstadoSessao()
    end
end)

workspace.ChildRemoved:Connect(function(child)
    task.wait(1) -- Pequeno delay
    if desertSessionActive and not estaNoDeserto() then
        resetarEstadoSessao()
    end
end)

-- ==========================
-- CriaÃ§Ã£o da Aba GUI
-- ==========================
Tabs.desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" })

Tabs.desert:AddToggle("DesertInfiniteToggle", {
    Title = "Ativar Deserto Infinito",
    Default = desertEnabled,
    Callback = function(state)
        desertEnabled = state
        ConfigSystem.CurrentConfig.DesertInfiniteToggle = state
        ConfigSystem.SaveConfig()
        if state then
            iniciarDesertoInfinito()
        else
            -- Quando desativar, resetar estado
            resetarEstadoSessao()
        end
    end
})

Tabs.desert:AddInput("DesertInfiniteSpeed", {
    Title = "Velocidade",
    Default = tostring(speedValue),
    Placeholder = "Ex: 2",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            speedValue = num
            ConfigSystem.CurrentConfig.DesertInfiniteSpeed = num
            ConfigSystem.SaveConfig()
            aplicarVelocidade(num)
        end
    end
})

Tabs.desert:AddToggle("DesertAutoSpeed", {
    Title = "Auto Velocidade",
    Description = "Aplica velocidade automaticamente a cada 3 segundos",
    Default = autoSpeedEnabled,
    Callback = function(state)
        autoSpeedEnabled = state
        ConfigSystem.CurrentConfig.DesertAutoSpeed = state
        ConfigSystem.SaveConfig()
        
        if state then
            if estaNoDeserto() then
                iniciarAutoVelocidade()
            else
                warn("[Deserto Infinito] Entre no deserto para ativar auto velocidade")
            end
        else
            pararAutoVelocidade()
        end
    end
})

Tabs.desert:AddButton({
    Title = "Aplicar Velocidade Agora",
    Description = "Aplica a velocidade imediatamente",
    Callback = function()
        aplicarVelocidade(speedValue)
    end
})

Tabs.desert:AddToggle("DesertInfiniteTeleport", {
    Title = "Teleport Fixo + Parar",
    Description = "Teleporta e mantÃ©m o personagem parado",
    Default = teleportEnabled,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.DesertInfiniteTeleport = state
        ConfigSystem.SaveConfig()
        if state then
            manterTeleport()
            warn("[Deserto Infinito] Teleport fixo + parar ativado.")
        else
            warn("[Deserto Infinito] Teleport fixo + parar desativado.")
            -- Liberar personagem quando desativar
            if player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end
            end
        end
    end
})

-- Adicionar botÃ£o para resetar manualmente se necessÃ¡rio
Tabs.desert:AddButton({
    Title = "Resetar Estado",
    Description = "Use se o script nÃ£o detectar que vocÃª saiu do deserto",
    Callback = function()
        resetarEstadoSessao()
        warn("[Deserto Infinito] Estado resetado manualmente")
    end
})

-- Debug: Mostrar status atual
Tabs.desert:AddButton({
    Title = "Verificar Status",
    Description = "Mostrar se estÃ¡ no deserto e estado da sessÃ£o",
    Callback = function()
        warn("[DEBUG] No deserto:", estaNoDeserto())
        warn("[DEBUG] SessÃ£o ativa:", desertSessionActive)
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            warn("[DEBUG] PosiÃ§Ã£o:", player.Character.HumanoidRootPart.Position)
        end
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2").dataRemoteEvent
local player = game.Players.LocalPlayer

-- ==========================
-- ConfiguraÃ§Ã£o Castelo Infinito
-- ==========================
if ConfigSystem.DefaultConfig.CastleInfiniteToggle == nil then
    ConfigSystem.DefaultConfig.CastleInfiniteToggle = false
end
if ConfigSystem.CurrentConfig.CastleInfiniteToggle == nil then
    ConfigSystem.CurrentConfig.CastleInfiniteToggle = ConfigSystem.DefaultConfig.CastleInfiniteToggle
end

if ConfigSystem.DefaultConfig.CastleInfiniteSpeed == nil then
    ConfigSystem.DefaultConfig.CastleInfiniteSpeed = 2
end
if ConfigSystem.CurrentConfig.CastleInfiniteSpeed == nil then
    ConfigSystem.CurrentConfig.CastleInfiniteSpeed = ConfigSystem.DefaultConfig.CastleInfiniteSpeed
end

if ConfigSystem.DefaultConfig.CastleAutoSpeed == nil then
    ConfigSystem.DefaultConfig.CastleAutoSpeed = false
end
if ConfigSystem.CurrentConfig.CastleAutoSpeed == nil then
    ConfigSystem.CurrentConfig.CastleAutoSpeed = ConfigSystem.DefaultConfig.CastleAutoSpeed
end

local castleEnabled = ConfigSystem.CurrentConfig.CastleInfiniteToggle
local castleSpeedValue = ConfigSystem.CurrentConfig.CastleInfiniteSpeed
local castleAutoSpeedEnabled = ConfigSystem.CurrentConfig.CastleAutoSpeed

local castleSessionActive = false
local castleAutoSpeedLoop = false

-- FunÃ§Ãµes Castelo
local function aplicarVelocidadeCastelo(valor)
    if not castleSessionActive then return end
    local argsSpeed = {
        [1] = {
            [1] = {
                ["Speed"] = valor,
                ["Event"] = "InfiniteCastleAction",
                ["Action"] = "SpeedUp"
            },
            [2] = "\13"
        }
    }
    remote:FireServer(unpack(argsSpeed))
end

local function iniciarAutoVelocidadeCastelo()
    if castleAutoSpeedLoop then return end
    castleAutoSpeedLoop = true
    task.spawn(function()
        while castleAutoSpeedEnabled and castleAutoSpeedLoop do
            aplicarVelocidadeCastelo(castleSpeedValue)
            task.wait(3)
        end
        castleAutoSpeedLoop = false
    end)
end

local function pararAutoVelocidadeCastelo()
    castleAutoSpeedEnabled = false
    castleAutoSpeedLoop = false
end

local function resetarEstadoCastelo()
    castleSessionActive = false
    pararAutoVelocidadeCastelo()
end

local function iniciarCasteloInfinito()
    if castleSessionActive then return end
    castleSessionActive = true
    task.spawn(function()
        local argsCreate = {
            [1] = {
                [1] = {["Event"] = "InfiniteCastleAction", ["Action"] = "Create"},
                [2] = "\13"
            }
        }
        remote:FireServer(unpack(argsCreate))
        task.wait(3)
        local argsStart = {
            [1] = {
                [1] = {["Dungeon"] = 5116548088, ["Event"] = "InfiniteCastleAction", ["Action"] = "Start"},
                [2] = "\13"
            }
        }
        remote:FireServer(unpack(argsStart))
        task.wait(2)
        aplicarVelocidadeCastelo(castleSpeedValue)
        if castleAutoSpeedEnabled then iniciarAutoVelocidadeCastelo() end
    end)
end

-- GUI Castelo
Tabs.castle:AddToggle("CastleInfiniteToggle", {
    Title = "Ativar Castelo Infinito",
    Default = castleEnabled,
    Callback = function(state)
        castleEnabled = state
        ConfigSystem.CurrentConfig.CastleInfiniteToggle = state
        ConfigSystem.SaveConfig()
        if state then iniciarCasteloInfinito() else resetarEstadoCastelo() end
    end
})
Tabs.castle:AddInput("CastleInfiniteSpeed", {
    Title = "Velocidade",
    Default = tostring(castleSpeedValue),
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            castleSpeedValue = num
            ConfigSystem.CurrentConfig.CastleInfiniteSpeed = num
            ConfigSystem.SaveConfig()
            aplicarVelocidadeCastelo(num)
        end
    end
})
Tabs.castle:AddToggle("CastleAutoSpeed", {
    Title = "Auto Velocidade",
    Default = castleAutoSpeedEnabled,
    Callback = function(state)
        castleAutoSpeedEnabled = state
        ConfigSystem.CurrentConfig.CastleAutoSpeed = state
        ConfigSystem.SaveConfig()
        if state then iniciarAutoVelocidadeCastelo() else pararAutoVelocidadeCastelo() end
    end
})
