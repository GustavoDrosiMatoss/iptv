--[=[
    Script: Allan Hub - Arise (Vers√£o Corrigida)
    Descri√ß√£o: Vers√£o final com detec√ß√£o autom√°tica de mobs e sistema de voo robusto.
    Data da Atualiza√ß√£o: 19/08/2025
--]=]

-- ===== Servi√ßos e Vari√°veis Globais =====
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Vari√°veis de controle de estado
local ativarEvento = false
local ativarDungeon = false
local ativarGems = false
local andarEntrada = 10
local andarSaida = 1
local dungeonActive = false

-- Nomes de arquivos de configura√ß√£o
local configFile = "allan_hub_corrigido.json"
local tempFile = "temp_dungeon_corrigido.json"

---------------------------------------------------------------------
--- NOVO SISTEMA DE VOO CORRIGIDO ---
---------------------------------------------------------------------

-- Configura√ß√µes de Voo
local FLIGHT_SPEED = 180 -- Velocidade para BodyVelocity. Ajuste se necess√°rio.
local FLIGHT_HEIGHT = 10 -- Altura acima do mob.

-- Vari√°veis de estado para o sistema de voo
local visitedPositions = {}
local flyConnection = nil -- Ser√° a BodyVelocity
local cachedEnemiesFolder = nil -- Guarda a pasta de inimigos para n√£o procurar toda hora

-- **NOVO: Fun√ß√£o para encontrar a pasta de inimigos automaticamente**
local function findEnemiesFolder()
    if cachedEnemiesFolder and cachedEnemiesFolder.Parent then
        return cachedEnemiesFolder -- Retorna a pasta se j√° foi encontrada
    end
    print("üîé Procurando pasta de inimigos em 'workspace'...")
    for _, item in ipairs(workspace:GetChildren()) do
        if item:IsA("Folder") or item:IsA("Model") then
            local mobCount = 0
            for _, child in ipairs(item:GetChildren()) do
                if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") and child:FindFirstChild("HumanoidRootPart") then
                    mobCount = mobCount + 1
                end
            end
            -- Considera uma pasta de inimigos se tiver pelo menos 2 mobs
            if mobCount >= 2 then
                print("‚úÖ Pasta de inimigos encontrada:", item:GetFullName())
                cachedEnemiesFolder = item
                return item
            end
        end
    end
    print("‚ùå Nenhuma pasta de inimigos foi detectada.")
    return nil -- Retorna nulo se n√£o encontrar
end

local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do if (position - visitedPos).Magnitude < 15 then return true end end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position); if #visitedPositions > 10 then table.remove(visitedPositions, 1) end
end

local function enableFlight()
    if flyConnection then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    flyConnection = Instance.new("BodyVelocity", hrp)
    flyConnection.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    flyConnection.Velocity = Vector3.new(0, 0, 0)
end

local function disableFlight()
    if flyConnection then flyConnection:Destroy(); flyConnection = nil; end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
    cachedEnemiesFolder = nil -- Limpa o cache ao sair da dungeon
end

local function getClosestUnvisitedMob()
    local enemiesFolder = findEnemiesFolder()
    if not enemiesFolder then return nil end

    local allMobs, closestMob, shortestDistance = {}, nil, math.huge
    for _, mobFolder in ipairs(enemiesFolder:GetChildren()) do
        if mobFolder:IsA("Model") then
            local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
            local mobHRP = mobFolder:FindFirstChild("HumanoidRootPart")
            if humanoid and humanoid.Health > 0 and mobHRP then
                table.insert(allMobs, {mob = mobHRP, distance = (hrp.Position - mobHRP.Position).Magnitude})
            end
        end
    end

    if #allMobs == 0 then return nil end

    for _, data in pairs(allMobs) do
        if not isPositionVisited(data.mob.Position) and data.distance < shortestDistance then
            shortestDistance = data.distance; closestMob = data.mob
        end
    end
    
    if not closestMob then
        print("üîç Todos os mobs j√° foram visitados. Resetando a lista.")
        visitedPositions = {}
        for _, data in pairs(allMobs) do
            if data.distance < shortestDistance then shortestDistance = data.distance; closestMob = data.mob end
        end
    end
    return closestMob
end

-- ===== FUN√á√ÉO PRINCIPAL DE VOO (Usa BodyVelocity) =====
local function flyToAllMobs()
    print("‚úàÔ∏è Iniciando modo de voo autom√°tico...")
    visitedPositions = {}
    enableFlight()
    
    local combatTimeout = tick() + 300 -- Timeout de 5 minutos
    while tick() < combatTimeout do
        local mob = getClosestUnvisitedMob()
        if not mob or not mob.Parent then
            print("üéâ Nenhum mob encontrado ou todos foram derrotados. Finalizando.")
            break -- Sai do loop se n√£o houver mais mobs
        end

        print("üéØ Pr√≥ximo alvo:", mob.Parent.Name)
        local targetPos = mob.Position + Vector3.new(0, FLIGHT_HEIGHT, 0)
        
        local flightTimeout = tick() + 10 -- Timeout de 10 segundos para chegar em cada mob
        while tick() < flightTimeout and mob.Parent and (hrp.Position - targetPos).Magnitude > 20 do
            local direction = (targetPos - hrp.Position).Unit
            flyConnection.Velocity = direction * FLIGHT_SPEED
            task.wait()
        end
        
        print("‚úÖ Chegou pr√≥ximo ao alvo.")
        addVisitedPosition(mob.Position)
        flyConnection.Velocity = Vector3.new(0, 0, 0) -- Para de se mover
        task.wait(1.5) -- Espera um pouco antes de ir para o pr√≥ximo
    end
    
    disableFlight()
    print("‚úàÔ∏è Sequ√™ncia de voo finalizada.")
end

-- Fun√ß√µes de Salvar/Carregar e A√ß√µes da Dungeon (sem altera√ß√µes)
local function salvarConfig() local data = {entrada=andarEntrada, saida=andarSaida, evento=ativarEvento, dungeon=ativarDungeon, gems=ativarGems, dungeonActive=dungeonActive}; writefile(configFile, HttpService:JSONEncode(data)) end
local function carregarConfig() if isfile and isfile(configFile) then local s, d = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end) if s and type(d)=="table" then andarEntrada=tonumber(d.entrada) or andarEntrada; andarSaida=tonumber(d.saida) or andarSaida; ativarEvento=d.evento or false; ativarDungeon=d.dungeon or false; ativarGems=d.gems or false; dungeonActive=d.dungeonActive or false else salvarConfig() end else salvarConfig() end end; carregarConfig()
local function entrarCastelo() print("üè∞ Entrando no castelo - Andar:", andarEntrada); local args = {[1]={[1]={Check=true,Floor=tostring(andarEntrada),Event="CastleAction",Action="Join"},[2]="\12"}}; game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args)) end
local function sairCastelo() print("üö™ Saindo do castelo"); disableFlight(); local args = {[1]={[1]={Check=true,Floor=tostring(andarSaida),Event="CastleAction",Action="LeaveDungeon"},[2]="\12"}}; game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args)); dungeonActive=false; salvarConfig() end
local function iniciarDungeon() print("‚ñ∂Ô∏è Iniciando dungeon..."); local args = {[1]={[1]={Event="DungeonAction",Action="Start"},[2]="\12"}}; game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args)) end
local function criarDungeon() if dungeonActive then return end; if workspace:FindFirstChild("__Enemies") or workspace:FindFirstChild("Dungeon") then dungeonActive=true; salvarConfig(); return end; print("üÜï Criando nova dungeon..."); local args = {[1]={[1]={Event="DungeonAction",Action="Create"},[2]="\12"}}; game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args)); dungeonActive=true; salvarConfig(); task.wait(5); iniciarDungeon() end
local function resetarDungeon() print("üíé Resetando dungeon com gems..."); disableFlight(); local args = {[1]={[1]={Type="Gems",Event="DungeonAction",Action="BuyTicket"},[2]="\12"}}; game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args)); dungeonActive=false; salvarConfig() end

-- ===== Loop Principal =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    while ativarDungeon do
        task.wait(5)
        local inDungeon = workspace:FindFirstChild("__Enemies") or workspace:FindFirstChild("Dungeon")
        if not inDungeon and not dungeonActive then
            if ativarEvento then entrarCastelo(); task.wait(5); end
            criarDungeon()
            task.wait(8)
        end
        inDungeon = workspace:FindFirstChild("__Enemies") or workspace:FindFirstChild("Dungeon")
        if inDungeon then
            flyToAllMobs()
            task.wait(3)
            if ativarGems then resetarDungeon() else sairCastelo(); task.wait(5); if ativarEvento then entrarCastelo() end end
            task.wait(5)
        end
    end
    print("üõë Loop de auto dungeon parado"); disableFlight()
end

-- ===== Interface Gr√°fica (GUI) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({Title = "Allan Hub (Vers√£o Corrigida)", SubTitle = "Voo Autom√°tico Otimizado", TabWidth = 160, Size = UDim2.fromOffset(580, 400), Acrylic = true, Theme = "dark", MinimizeKey = Enum.KeyCode.End})
local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
t:AddToggle("ToggleAutoDungeon", {Title = "Auto Dungeon (Ativa o Voo)", Description = "Cria/Inicia a dungeon e voa at√© os mobs", Default = ativarDungeon, Callback = function(state) ativarDungeon = state; salvarConfig(); if state then task.spawn(autoDungeonLoop) else disableFlight() end end})
t:AddToggle("ToggleAutoCastelo", {Title = "Auto Castelo", Description = "Entra e sai do castelo automaticamente", Default = ativarEvento, Callback = function(state) ativarEvento = state; salvarConfig(); if state then entrarCastelo() end end})
t:AddToggle("ToggleUseGems", {Title = "Usar Gems para Reset", Description = "Compra ticket com gems para resetar a dungeon", Default = ativarGems, Callback = function(state) ativarGems = state; salvarConfig() end})
local andaresEntrada, andaresSaida = {}, {}; for i=10,110,10 do table.insert(andaresEntrada, tostring(i)) end; for i=1,117 do table.insert(andaresSaida, tostring(i)) end
t:AddDropdown("AndarEntrada", {Title = "Andar de Entrada", Values = andaresEntrada, Default = tostring(andarEntrada), Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end})
t:AddDropdown("AndarSaida", {Title = "Andar de Sa√≠da", Values = andaresSaida, Default = tostring(andarSaida), Callback = function(v) andarSaida = tonumber(v); salvarConfig() end})
t:AddButton({Title = "üîÑ Reset Dungeon Status", Description = "Limpa o status da dungeon se bugar", Callback = function() dungeonActive = false; salvarConfig(); print("üîÑ Status da dungeon resetado!") end})
if ativarDungeon then task.spawn(autoDungeonLoop) end
print("‚úÖ Allan Hub (Vers√£o Corrigida) carregado!")
