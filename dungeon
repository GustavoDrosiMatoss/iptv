local ativarEvento = false
local ativarDungeon = false
local ativarGems = false  -- Nova vari√°vel para ativar o reset com gems
local andarEntrada = 10
local andarSaida = 1
local currentFloor = 0
local configFile = "allan_hub_castelo.json"
local tempFile = "temp_dungeon.json"

-- Detectar se acabou de teleportar
local justTeleported = false
if isfile(tempFile) then
    justTeleported = true
    print("üìå Detectado teleporte para dungeon, n√£o criar outra.")
end

-- Fun√ß√£o para salvar configura√ß√£o
local function salvarConfig()
    local data = {
        entrada = andarEntrada,
        saida = andarSaida,
        evento = ativarEvento,
        dungeon = ativarDungeon,
        gems = ativarGems
    }
    writefile(configFile, game:GetService("HttpService"):JSONEncode(data))
    print("üíæ Configura√ß√£o salva!")
end

-- Fun√ß√£o para carregar configura√ß√£o
local function carregarConfig()
    if isfile(configFile) then
        local content = readfile(configFile)
        local data = game:GetService("HttpService"):JSONDecode(content)
        andarEntrada = tonumber(data.entrada) or andarEntrada
        andarSaida = tonumber(data.saida) or andarSaida
        ativarEvento = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems = data.gems or false
        print("üìÇ Configura√ß√£o carregada! Entrada: " .. andarEntrada .. " | Sa√≠da: " .. andarSaida .. " | Evento: " .. tostring(ativarEvento) .. " | Dungeon: " .. tostring(ativarDungeon) .. " | Gems: " .. tostring(ativarGems))
    else
        salvarConfig()
    end
end

carregarConfig()

-- Fun√ß√µes de Castelo/Dungeon
local function entrarCastelo()
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(andarEntrada),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("Entrando no andar " .. andarEntrada)
end

local function sairCastelo()
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(andarSaida),
                ["Event"] = "CastleAction",
                ["Action"] = "LeaveDungeon"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("Saindo no andar " .. andarSaida)

    -- Apaga o arquivo de teleporte ao sair
    if isfile(tempFile) then
        delfile(tempFile)
    end
end

local function iniciarDungeon()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("‚ñ∂ Tentando iniciar a dungeon.")
end

local function criarDungeon()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("‚úî Dungeon criada.")

    -- Marca que foi criado para evitar recriar no outro servidor
    writefile(tempFile, "1")

    -- Espera 3 segundos para garantir que o servidor processe a cria√ß√£o antes de iniciar
    task.wait(3)
    iniciarDungeon()
end

local function resetarDungeon()
    local args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "DungeonAction",
                ["Action"] = "BuyTicket"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("‚ôªÔ∏è Dungeon resetada (ticket comprado).")

    -- Apaga o arquivo de teleporte ao resetar
    if isfile(tempFile) then
        delfile(tempFile)
    end
end

-- Fun√ß√µes de mobs
local function detectarInimigosProximos()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return {} end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return {} end
    local mobsFolder = workspace:FindFirstChild("__Enemies")
    if not mobsFolder then return {} end
    local inimigos = {}
    for _, mob in pairs(mobsFolder:GetChildren()) do
        if mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            local mobRoot = mob:FindFirstChild("HumanoidRootPart")
            if mobRoot then
                local dist = (root.Position - mobRoot.Position).Magnitude
                if dist <= 20 then
                    table.insert(inimigos, mob.Name)
                end
            end
        end
    end
    return inimigos
end

local function atacarInimigos()
    local inimigos = detectarInimigosProximos()
    if #inimigos > 0 then
        for _, enemyId in ipairs(inimigos) do
            print("Atacando inimigo com ID:", enemyId)
            local args = {
                [1] = {
                    [1] = {
                        ["PetPos"] = {},
                        ["AttackType"] = "All",
                        ["Event"] = "Attack",
                        ["Enemy"] = enemyId
                    },
                    [2] = "\5"
                }
            }
            game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
        end
    else
        print("Nenhum inimigo a menos de 20 metros para atacar.")
    end
end

local function teleportToNearestMob()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local mobsFolder = workspace:FindFirstChild("__Enemies")
    if not mobsFolder then return end
    local closestMob = nil
    local minDist = math.huge
    for _, mob in pairs(mobsFolder:GetChildren()) do
        if mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            local mobRoot = mob:FindFirstChild("HumanoidRootPart")
            if mobRoot then
                local dist = (root.Position - mobRoot.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closestMob = mobRoot
                end
            end
        end
    end
    if closestMob and minDist > 5 then
        root.CFrame = closestMob.CFrame * CFrame.new(0, 0, 5)
        print("Teletransportado para o mob mais pr√≥ximo.")
    end
end

local function mobsVivos()
    local mobsFolder = workspace:FindFirstChild("__Enemies")
    if mobsFolder then
        for _, mob in pairs(mobsFolder:GetChildren()) do
            if mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
                return true
            end
        end
    end
    return false
end

local function isInDungeon()
    if workspace:FindFirstChild("__Enemies") then return true end
    return false
end

local function autoDungeonLoop()
    while ativarDungeon do
        task.wait(5)

        if not justTeleported and not isInDungeon() then
            if ativarEvento then
                entrarCastelo()
                task.wait(5)
            end
            criarDungeon()
            task.wait(5)
        end
        justTeleported = false

        print("‚è≥ Aguardando mobs serem eliminados...")

        local startTime = tick()
        while not mobsVivos() and tick() - startTime < 30 do
            task.wait(1)
            print("Aguardando spawn de mobs...")
        end

        if mobsVivos() then
            repeat
                teleportToNearestMob()
                atacarInimigos()
                task.wait(0.5)
            until not mobsVivos()
            print("‚úî Todos os mobs mortos...")
        else
            print("‚ö†Ô∏è Nenhum mob spawnou ap√≥s espera, verificando configura√ß√£o...")
            continue
        end

        if ativarGems then
            resetarDungeon()
            task.wait(3)
        else
            sairCastelo()
            task.wait(3)
            entrarCastelo()
            task.wait(3)
        end
    end
end