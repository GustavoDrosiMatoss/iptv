local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local ativarAutoFly  = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== FUN√á√ÉO DE AUTO FARM COM VOO (CORRIGIDA) =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil
local autoFlyRunning = false
local autoFlyCoroutine = nil

local FLIGHT_SPEED = 500
local FLIGHT_HEIGHT = 5

local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function enableFlight()
    if flyConnection then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    flyConnection = bodyVelocity
end

local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

local function flyToPosition(targetPosition)
    enableFlight()
    if currentTween then currentTween:Cancel(); currentTween = nil end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    
    print("Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    return currentTween
end

-- FUN√á√ÉO CORRIGIDA BASEADA NA SUA FUN√á√ÉO QUE FUNCIONA
local function getClosestUnvisitedMob(enemiesFolder)
    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    -- Lista de nomes espec√≠ficos das dungeons para buscar inimigos
    local dungeonNames = {
        "DarkDungeon", "TrainStation", "ImpelDown", "SnakeLab", "SoulSociety", 
        "Hotel", "MagicDungeon", "Prison", "Namek", "Spaceship", "Tunnel", 
        "OrcDungeon", "HunterTest", "SlimeDungeon", "CursedFactory", 
        "InfiniteCastle", "Airship", "TitanChurch", "SummerDungeon"
    }
    
    -- Se n√£o foi especificada uma pasta, tenta encontrar automaticamente
    if not enemiesFolder then
        -- Primeiro tenta pasta __Enemies no workspace (dungeon ativa)
        enemiesFolder = workspace:FindFirstChild("__Enemies")
        
        -- Se n√£o encontrou, tenta nas dungeons espec√≠ficas
        if not enemiesFolder then
            for _, dungeonName in pairs(dungeonNames) do
                local dungeon = workspace:FindFirstChild(dungeonName)
                if dungeon then
                    enemiesFolder = dungeon:FindFirstChild("__Enemies") or dungeon:FindFirstChild("Enemies")
                    if enemiesFolder then
                        print("üìÇ Encontrou inimigos na dungeon:", dungeonName)
                        break
                    end
                end
            end
        end
        
        -- Se ainda n√£o encontrou, usa a pasta padr√£o do mundo aberto
        if not enemiesFolder then
            local mainFolder = workspace:FindFirstChild("__Main")
            if mainFolder then
                enemiesFolder = mainFolder:FindFirstChild("__Enemies")
            end
        end
    end
    
    if not enemiesFolder then
        print("‚ùå Nenhuma pasta de inimigos encontrada")
        return nil
    end
    
    print("üîç Procurando mobs na pasta:", enemiesFolder.Name, "| Filhos:", #enemiesFolder:GetChildren())
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            
            if mob and mob:IsA("BasePart") and mob.Parent then
                local dist = (hrp.Position - mob.Position).Magnitude
                
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    local isAlive = true
                    
                    if humanoid then
                        isAlive = humanoid.Health > 0
                    end
                    
                    if isAlive then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    print("üìä Mobs encontrados no alcance:", #allMobs)
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        local mob = mobData.mob
        if not isPositionVisited(mob.Position) then
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    -- Se n√£o encontrar mobs n√£o visitados, limpa a lista e pega qualquer um
    if not closestMob and #allMobs > 0 then
        print("üîÑ Limpando lista de posi√ß√µes visitadas...")
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            local mob = mobData.mob
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    if closestMob then
        print("üéØ Mob mais pr√≥ximo encontrado! Dist√¢ncia:", math.floor(shortestDistance))
    else
        print("‚ùå Nenhum mob v√°lido encontrado")
    end
    
    return closestMob
end

local function flyToMobLoop(enemiesFolder)
    enableFlight()
    
    while autoFlyRunning do
        local mob = getClosestUnvisitedMob(enemiesFolder)
        
        if mob and mob.Parent then
            -- Verifica se √© o mesmo alvo da vez anterior
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    print("‚ö†Ô∏è Parece que estou preso no mesmo mob, marcando como visitado...")
                    addVisitedPosition(mob.Position)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end
            
            -- Voa at√© o mob
            local flyTween = flyToPosition(mob.Position)
            local startTime = tick()
            local maxWaitTime = 10
            
            repeat
                task.wait(0.1)
                if not autoFlyRunning then break end
                local distance = (hrp.Position - mob.Position).Magnitude
                
                -- Se chegou perto o suficiente, para o tween
                if distance < 15 then break end
                
                -- Se o mob morreu ou sumiu, para o tween
                if not mob.Parent then break end
                
            until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
            
            -- Para o tween se ainda estiver rodando
            if currentTween then currentTween:Cancel(); currentTween = nil end
            
            print("‚úÖ Chegou pr√≥ximo ao mob!")
            task.wait(3) -- Aumenta tempo para atacar o mob
            addVisitedPosition(mob.Position)
        else
            print("‚ùå Nenhum mob encontrado na varredura atual")
            
            -- Limpa lista de visitados e tenta novamente
            if #visitedPositions > 0 then
                print("üîÑ Limpando lista de visitados para nova varredura...")
                visitedPositions = {}
                task.wait(2)
                continue
            end
            
            -- Se mesmo assim n√£o encontrar, para o loop
            print("‚ùå Nenhum mob encontrado ap√≥s limpar lista - parando Auto Fly")
            autoFlyRunning = false
            break
        end
        
        if autoFlyRunning then
            task.wait(1) -- Aumenta intervalo entre mobs
        end
    end
    
    disableFlight()
    print("üõë Loop de voo finalizado")
end

local function startAutoFly(targetFolder)
    if autoFlyRunning then 
        print("‚ö†Ô∏è Auto Fly j√° est√° rodando!")
        return 
    end
    
    print("üöÄ Iniciando Auto Fly...")
    autoFlyRunning = true
    
    autoFlyCoroutine = coroutine.create(function()
        pcall(flyToMobLoop, targetFolder)
        autoFlyRunning = false
    end)
    
    coroutine.resume(autoFlyCoroutine)
end

local function stopAutoFly()
    if not autoFlyRunning and not flyConnection then return end
    print("üõë Parando Auto Fly...")
    autoFlyRunning = false
    if currentTween then currentTween:Cancel(); currentTween = nil end
    disableFlight()
    visitedPositions = {}
    currentTarget = nil
    stuckCounter = 0
    print("‚úÖ Auto Fly parado!")
end

-- ===== FUN√á√ïES DE CONTROLE (CORRIGIDAS) =====

local function safeDelete(path)
    if isfile and isfile(path) then
        pcall(function() writefile(path, "") end)
    end
end

local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        autofly = ativarAutoFly, dungeonActive = dungeonActive
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local success, data = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end)
        if success and type(data) == "table" then
            andarEntrada  = tonumber(data.entrada) or andarEntrada
            andarSaida    = tonumber(data.saida) or andarSaida
            ativarEvento  = data.evento or false
            ativarDungeon = data.dungeon or false
            ativarGems    = data.gems or false
            ativarAutoFly = data.autofly or false
            dungeonActive = data.dungeonActive or false
        end
    else
        salvarConfig()
    end
end
carregarConfig()

-- FUN√á√ÉO CORRIGIDA DE DETEC√á√ÉO DE DUNGEON (USANDO NOMES ESPEC√çFICOS)
local function isInDungeon()
    -- Lista de nomes espec√≠ficos das dungeons
    local dungeonNames = {
        "DarkDungeon", "TrainStation", "ImpelDown", "SnakeLab", "SoulSociety", 
        "Hotel", "MagicDungeon", "Prison", "Namek", "Spaceship", "Tunnel", 
        "OrcDungeon", "HunterTest", "SlimeDungeon", "CursedFactory", 
        "InfiniteCastle", "Airship", "TitanChurch", "SummerDungeon"
    }
    
    -- Verifica se existe pasta __Enemies diretamente no workspace (m√©todo antigo)
    local dungeonEnemies = workspace:FindFirstChild("__Enemies")
    
    -- Verifica se existe alguma das dungeons espec√≠ficas
    local foundDungeon = nil
    for _, dungeonName in pairs(dungeonNames) do
        local dungeon = workspace:FindFirstChild(dungeonName)
        if dungeon then
            foundDungeon = dungeonName
            break
        end
    end
    
    -- Verifica tamb√©m a pasta Dungeon gen√©rica
    local genericDungeon = workspace:FindFirstChild("Dungeon")
    
    local isDungeon = dungeonEnemies ~= nil or foundDungeon ~= nil or genericDungeon ~= nil
    
    if isDungeon then
        if foundDungeon then
            print("üè∞ Detectado em dungeon espec√≠fica:", foundDungeon)
        elseif dungeonEnemies then
            print("üè∞ Detectado em dungeon (pasta __Enemies encontrada)")
        elseif genericDungeon then
            print("üè∞ Detectado em dungeon (pasta Dungeon encontrada)")
        end
    else
        print("üåç N√£o est√° em nenhuma dungeon conhecida")
    end
    
    return isDungeon
end

-- FUN√á√ÉO CORRIGIDA DE DETEC√á√ÉO DE MOBS VIVOS
local function mobsVivos()
    -- Lista de nomes espec√≠ficos das dungeons
    local dungeonNames = {
        "DarkDungeon", "TrainStation", "ImpelDown", "SnakeLab", "SoulSociety", 
        "Hotel", "MagicDungeon", "Prison", "Namek", "Spaceship", "Tunnel", 
        "OrcDungeon", "HunterTest", "SlimeDungeon", "CursedFactory", 
        "InfiniteCastle", "Airship", "TitanChurch", "SummerDungeon"
    }
    
    local folder = nil
    
    -- Primeiro verifica pasta __Enemies no workspace (dungeon ativa)
    folder = workspace:FindFirstChild("__Enemies")
    
    -- Se n√£o encontrou, procura nas dungeons espec√≠ficas
    if not folder then
        for _, dungeonName in pairs(dungeonNames) do
            local dungeon = workspace:FindFirstChild(dungeonName)
            if dungeon then
                folder = dungeon:FindFirstChild("__Enemies") or dungeon:FindFirstChild("Enemies")
                if folder then
                    print("üìÇ Verificando mobs na dungeon:", dungeonName)
                    break
                end
            end
        end
    end
    
    -- Se ainda n√£o encontrou, verifica a pasta padr√£o do mundo aberto
    if not folder then
        local mainFolder = workspace:FindFirstChild("__Main")
        if mainFolder then
            folder = mainFolder:FindFirstChild("__Enemies")
        end
    end
    
    if not folder then 
        print("‚ùå Nenhuma pasta de inimigos encontrada para verificar mobs vivos")
        return false 
    end
    
    local mobsCount = 0
    local aliveCount = 0
    
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") and mob.Parent then
            mobsCount = mobsCount + 1
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 and humanoid.Parent then
                aliveCount = aliveCount + 1
                -- Debug: mostra quais mobs ainda est√£o vivos
                print("üëπ Mob vivo encontrado:", mob.Name, "| HP:", math.floor(humanoid.Health))
            end
        end
    end
    
    print("üìä Mobs encontrados:", mobsCount, "| Vivos:", aliveCount, "| Pasta:", folder.Name)
    return aliveCount > 0
end

local function entrarCastelo()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join"}, [2] = "\12"})
end

local function sairCastelo()
    print("üö™ Saindo do castelo")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon"}, [2] = "\12"})
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local function iniciarDungeon()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Start"}, [2] = "\12"})
end

local function criarDungeon()
    if dungeonActive or isInDungeon() then 
        print("‚ö†Ô∏è Dungeon j√° est√° ativa ou j√° est√° em uma dungeon")
        return 
    end
    print("üÜï Criando nova dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Create"}, [2] = "\12"})
    dungeonActive = true
    salvarConfig()
    task.wait(8)
    iniciarDungeon()
    
    -- Aguarda a dungeon ser realmente criada antes de continuar
    local attempts = 0
    while not isInDungeon() and attempts < 10 and ativarDungeon do
        print("‚è≥ Aguardando dungeon ser criada... Tentativa", attempts + 1)
        task.wait(3)
        attempts = attempts + 1
    end
    
    if isInDungeon() then
        print("‚úÖ Dungeon criada com sucesso!")
    else
        print("‚ö†Ô∏è Dungeon pode n√£o ter sido criada corretamente")
        dungeonActive = false -- Reset status se n√£o conseguiu criar
        salvarConfig()
    end
end

-- FUN√á√ÉO CORRIGIDA DE RESET COM GEMS
local function resetarDungeon()
    print("üíé Iniciando reset da dungeon com gems...")
    
    -- Para o auto fly antes de resetar
    if autoFlyRunning then
        print("üõë Parando Auto Fly para reset...")
        autoFlyRunning = false
        disableFlight()
        task.wait(3)
    end
    
    -- Tenta resetar com gems
    local success, error = pcall(function()
        game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({
            [1] = {Type = "Gems", Event = "DungeonAction", Action = "BuyTicket"}, 
            [2] = "\12"
        })
    end)
    
    if success then
        print("‚úÖ Comando de reset enviado com sucesso")
    else
        print("‚ùå Erro ao enviar comando de reset:", error)
    end
    
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
    
    -- Aguarda o reset processar
    print("‚è≥ Aguardando reset processar...")
    task.wait(10)
    
    -- Verifica se saiu da dungeon - aguarda at√© sair ou timeout
    local attempts = 0
    local maxAttempts = 15
    while isInDungeon() and attempts < maxAttempts do
        print("‚è≥ Aguardando sair da dungeon... Tentativa", attempts + 1, "de", maxAttempts)
        task.wait(2)
        attempts = attempts + 1
    end
    
    if not isInDungeon() then
        print("‚úÖ Reset com gems conclu√≠do - saiu da dungeon!")
        return true
    else
        print("‚ö†Ô∏è Ainda em dungeon ap√≥s reset - pode precisar de mais tempo")
        return false
    end
end

-- FUN√á√ÉO CORRIGIDA DE VERIFICA√á√ÉO E RESET
local function verificarEresetarSeNecessario()
    print("üîé Verificando se a dungeon foi conclu√≠da...")
    
    -- Para qualquer auto fly ativo antes de verificar
    if autoFlyRunning then
        print("üõë Parando Auto Fly para verifica√ß√£o...")
        autoFlyRunning = false
        disableFlight()
        task.wait(3)
    end
    
    -- Aguarda um pouco para garantir que tudo foi processado
    task.wait(3)
    
    -- Faz m√∫ltiplas verifica√ß√µes para ter certeza
    print("üîç Primeira verifica√ß√£o de mobs...")
    local mobCheck1 = mobsVivos()
    task.wait(3)
    print("üîç Segunda verifica√ß√£o de mobs...")
    local mobCheck2 = mobsVivos()
    
    if not mobCheck1 and not mobCheck2 then
        print("‚úÖ DUNGEON CONFIRMADA COMO LIMPA!")
        print("üîÑ Iniciando processo de reset...")
        
        local resetSuccess = false
        
        if ativarGems then
            print("üíé Resetando com gems...")
            resetSuccess = resetarDungeon()
        else
            print("üö™ Resetando saindo e entrando novamente...")
            sairCastelo()
            task.wait(8)
            if ativarEvento then 
                entrarCastelo()
                task.wait(5)
            end
            resetSuccess = true
        end
        
        if resetSuccess then
            print("‚úÖ Reset conclu√≠do com sucesso - aguardando nova dungeon...")
            -- Aguarda um tempo antes de continuar o loop para evitar reset infinito
            task.wait(15)
            return true
        else
            print("‚ö†Ô∏è Reset n√£o foi bem sucedido")
            return false
        end
    else
        print("‚ö†Ô∏è AINDA EXISTEM MOBS VIVOS - N√ÉO RESETANDO")
        print("üîÑ Primeira verifica√ß√£o:", mobCheck1 and "‚ùå MOBS VIVOS" or "‚úÖ LIMPO")
        print("üîÑ Segunda verifica√ß√£o:", mobCheck2 and "‚ùå MOBS VIVOS" or "‚úÖ LIMPO")
        return false
    end
end

-- FUN√á√ÉO CORRIGIDA DE LIMPEZA COM VOO
local function solarDungeonComVoo()
    print("üåü Iniciando limpeza da dungeon com Auto Voo...")
    
    -- Lista de nomes espec√≠ficos das dungeons
    local dungeonNames = {
        "DarkDungeon", "TrainStation", "ImpelDown", "SnakeLab", "SoulSociety", 
        "Hotel", "MagicDungeon", "Prison", "Namek", "Spaceship", "Tunnel", 
        "OrcDungeon", "HunterTest", "SlimeDungeon", "CursedFactory", 
        "InfiniteCastle", "Airship", "TitanChurch", "SummerDungeon"
    }
    
    local dungeonEnemiesFolder = nil
    
    -- Procura pasta de inimigos da dungeon - primeiro __Enemies no workspace
    dungeonEnemiesFolder = workspace:FindFirstChild("__Enemies")
    
    -- Se n√£o encontrou, procura nas dungeons espec√≠ficas
    if not dungeonEnemiesFolder then
        for _, dungeonName in pairs(dungeonNames) do
            local dungeon = workspace:FindFirstChild(dungeonName)
            if dungeon then
                dungeonEnemiesFolder = dungeon:FindFirstChild("__Enemies") or dungeon:FindFirstChild("Enemies")
                if dungeonEnemiesFolder then
                    print("üìÇ Encontrou pasta de inimigos na dungeon:", dungeonName)
                    break
                end
            end
        end
    end
    
    if not dungeonEnemiesFolder then
        print("‚ùå Pasta de inimigos da dungeon n√£o encontrada.")
        return false
    end
    
    print("üìÇ Pasta de inimigos encontrada:", dungeonEnemiesFolder.Name, "| Filhos:", #dungeonEnemiesFolder:GetChildren())
    
    -- Se n√£o h√° mobs, j√° retorna
    if #dungeonEnemiesFolder:GetChildren() == 0 then
        print("‚úÖ Nenhum mob encontrado - dungeon j√° est√° limpa")
        return true
    end
    
    -- FOR√áA o in√≠cio do Auto Fly mesmo que n√£o esteja ativo globalmente
    print("üöÅ FOR√áANDO in√≠cio do Auto Fly para dungeon...")
    autoFlyRunning = true
    
    -- Inicia o voo focado apenas na pasta da dungeon
    autoFlyCoroutine = coroutine.create(function()
        pcall(flyToMobLoop, dungeonEnemiesFolder)
        autoFlyRunning = false
    end)
    coroutine.resume(autoFlyCoroutine)
    
    local startTime = tick()
    local maxTimeout = 300 -- 5 minutos m√°ximo
    local lastMobCheck = tick()
    local noMobCounter = 0
    
    -- Espera at√© que o voo pare ou d√™ timeout
    while autoFlyRunning and (tick() - startTime < maxTimeout) and ativarDungeon do
        task.wait(3)
        
        -- Verifica se ainda existem mobs a cada 10 segundos
        if tick() - lastMobCheck > 10 then
            lastMobCheck = tick()
            local hasMobs = mobsVivos()
            
            if not hasMobs then
                noMobCounter = noMobCounter + 1
                print("üéØ Verifica√ß√£o", noMobCounter, "- Nenhum mob vivo encontrado")
                
                -- Se n√£o encontrou mobs vivos 2 vezes seguidas, considera limpo
                if noMobCounter >= 2 then
                    print("üéâ Dungeon confirmadamente limpa!")
                    autoFlyRunning = false -- Para o auto fly
                    break
                end
            else
                noMobCounter = 0 -- Reset counter se ainda h√° mobs
            end
        end
        
        print("‚úàÔ∏è Limpando dungeon... Auto Voo ativo h√°", math.floor(tick() - startTime), "segundos")
    end
    
    -- Garante que o voo seja parado ao final
    if autoFlyRunning then
        autoFlyRunning = false
        disableFlight()
        task.wait(2)
    end
    
    local finalCheck = mobsVivos()
    
    if tick() - startTime >= maxTimeout then
        print("‚è∞ Timeout na limpeza da dungeon.")
        return false
    elseif not finalCheck then
        print("‚úÖ Limpeza da dungeon finalizada com sucesso!")
        return true
    else
        print("‚ö†Ô∏è Ainda restam mobs ap√≥s a limpeza")
        return false
    end
end

-- LOOP PRINCIPAL CORRIGIDO
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(3)
        
        -- For√ßa verifica√ß√£o detalhada do estado
        local inDungeon = isInDungeon()
        local hasMobs = mobsVivos()
        
        print("üîç ESTADO ATUAL:")
        print("   üìç Em Dungeon:", inDungeon and "‚úÖ SIM" or "‚ùå N√ÉO") 
        print("   üéØ Dungeon Ativa:", dungeonActive and "‚úÖ SIM" or "‚ùå N√ÉO")
        print("   üëπ Mobs Vivos:", hasMobs and "‚úÖ SIM" or "‚ùå N√ÉO")
        
        if not inDungeon and not dungeonActive then
            print("üèóÔ∏è CRIANDO NOVA DUNGEON...")
            if ativarEvento then 
                print("üè∞ Entrando no castelo primeiro...")
                entrarCastelo()
                task.wait(8) 
            end
            criarDungeon()
            task.wait(15) -- Aguarda mais tempo para dungeon ser criada
            continue
        end

        if inDungeon or dungeonActive then
            if hasMobs then
                print("üéÆ INICIANDO LIMPEZA DA DUNGEON...")
                local limpezaSucesso = solarDungeonComVoo()
                
                if limpezaSucesso then
                    print("‚úÖ Limpeza bem sucedida - verificando reset...")
                    local resetSucesso = verificarEresetarSeNecessario()
                    if resetSucesso then
                        print("üéâ Ciclo completo! Aguardando pr√≥xima dungeon...")
                        task.wait(10)
                    end
                else
                    print("‚ö†Ô∏è Limpeza n√£o foi bem sucedida, aguardando...")
                    task.wait(10)
                end
            else
                print("‚úÖ NENHUM MOB DETECTADO - VERIFICANDO RESET...")
                verificarEresetarSeNecessario()
            end
        else
            print("‚ö†Ô∏è Estado indefinido - aguardando...")
            task.wait(15)
        end
        
        task.wait(5)
    end
    
    -- Para qualquer auto fly ativo ao sair do loop
    if autoFlyRunning then
        autoFlyRunning = false
        disableFlight()
    end
    
    print("üõë Loop de auto dungeon parado")
end

-- ===== GUI (CORRIGIDA) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (CORRIGIDO)",
    SubTitle = "Dungeon com Auto Voo + Farm Voador",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
local autoFarmTab = Window:AddTab({ Title = "Auto Farm", Icon = "zap" })
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({Title = "Status Atual",Content = "Aguardando..."})

local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
‚úàÔ∏è Auto Farm Voador: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå",
        autoFlyRunning and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

task.spawn(function()
    while true do
        pcall(updateStatus)
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state
        salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Usa o Auto Voo para limpar a dungeon",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state
        salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        else
            -- Para o auto fly quando desativar auto dungeon
            if autoFlyRunning then stopAutoFly() end
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Se ativado, usa gems para resetar, sen√£o sai e entra novamente",
    Default = ativarGems,
    Callback = function(state) 
        ativarGems = state
        salvarConfig() 
    end
})

autoFarmTab:AddToggle("ToggleAutoFly", {
    Title = "Auto Farm Voador (Mundo Aberto)",
    Description = "Ativa/Desativa o farm no mundo principal",
    Default = ativarAutoFly,
    Callback = function(state)
        ativarAutoFly = state
        salvarConfig()
        if state then
            -- Usa a pasta padr√£o do mundo aberto
            local mainFolder = workspace:FindFirstChild("__Main")
            if mainFolder then
                local enemiesFolder = mainFolder:FindFirstChild("__Enemies")
                if enemiesFolder then
                    startAutoFly(enemiesFolder)
                else
                    print("‚ùå Pasta __Enemies n√£o encontrada em __Main")
                end
            else
                print("‚ùå Pasta __Main n√£o encontrada")
            end
        else
            stopAutoFly()
        end
    end
})

autoFarmTab:AddButton({
    Title = "üîÑ For√ßar Parar Auto Fly",
    Description = "Para for√ßadamente o Auto Fly se estiver com problema",
    Callback = function()
        stopAutoFly()
        print("üõë Auto Fly for√ßadamente parado!")
    end
})

autoFarmTab:AddParagraph({
    Title = "Informa√ß√µes do Auto Farm",
    Content = "O Auto Farm Voador ir√° voar automaticamente at√© os mobs. Use o toggle 'Auto Dungeon' na outra aba para farmar dungeons, e este para farmar no mundo aberto."
})

t:AddButton({
    Title = "üîÑ Reset Dungeon Status",
    Description = "Reseta o status interno da dungeon",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        if autoFlyRunning then stopAutoFly() end
        print("üîÑ Status da dungeon resetado!")
    end
})

t:AddButton({
    Title = "üíé Resetar Dungeon Agora",
    Description = "For√ßa o reset da dungeon atual com gems",
    Callback = function()
        if ativarGems then
            print("üîß RESET MANUAL INICIADO...")
            resetarDungeon()
        else
            print("‚ö†Ô∏è Op√ß√£o de usar gems n√£o est√° ativada!")
            print("üîß Tentando reset manual sem gems...")
            sairCastelo()
            task.wait(5)
            if ativarEvento then entrarCastelo() end
        end
    end
})

t:AddButton({
    Title = "üß™ Testar Detec√ß√£o de Mobs",
    Description = "Testa a detec√ß√£o de mobs vivos atual",
    Callback = function()
        print("üß™ TESTE DE DETEC√á√ÉO INICIADO...")
        print("üîç Testando isInDungeon():", isInDungeon())
        print("üîç Testando mobsVivos():", mobsVivos())
        print("üìÇ Pasta __Enemies existe:", workspace:FindFirstChild("__Enemies") and "‚úÖ SIM" or "‚ùå N√ÉO")
        
        local mainEnemies = workspace:FindFirstChild("__Main")
        if mainEnemies then mainEnemies = mainEnemies:FindFirstChild("__Enemies") end
        print("üìÇ Pasta __Main.__Enemies existe:", mainEnemies and "‚úÖ SIM" or "‚ùå N√ÉO")
        
        -- Verifica dungeons espec√≠ficas
        local dungeonNames = {
            "DarkDungeon", "TrainStation", "ImpelDown", "SnakeLab", "SoulSociety", 
            "Hotel", "MagicDungeon", "Prison", "Namek", "Spaceship", "Tunnel", 
            "OrcDungeon", "HunterTest", "SlimeDungeon", "CursedFactory", 
            "InfiniteCastle", "Airship", "TitanChurch", "SummerDungeon"
        }
        
        print("üîç Verificando dungeons espec√≠ficas...")
        for _, dungeonName in pairs(dungeonNames) do
            local dungeon = workspace:FindFirstChild(dungeonName)
            if dungeon then
                print("‚úÖ Dungeon encontrada:", dungeonName)
                local enemies = dungeon:FindFirstChild("__Enemies") or dungeon:FindFirstChild("Enemies")
                if enemies then
                    print("   üìÇ Pasta de inimigos:", enemies.Name, "| Filhos:", #enemies:GetChildren())
                end
            end
        end
    end
})

t:AddButton({
    Title = "üöÅ Testar Auto Fly Dungeon", 
    Description = "For√ßa in√≠cio do Auto Fly na dungeon atual",
    Callback = function()
        local dungeonFolder = workspace:FindFirstChild("__Enemies")
        if dungeonFolder then
            print("üöÅ TESTE DE AUTO FLY DUNGEON...")
            solarDungeonComVoo()
        else
            print("‚ùå Nenhuma pasta __Enemies encontrada para teste")
        end
    end
})

-- GUI flutuante
local floatingGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
floatingGui.Name = "AllanHubFloating"
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton", floatingGui)
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "‚öô"
toggleButton.TextScaled = true
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    Window.Frame.Visible = hubVisivel
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Sistema de monitoramento do andar
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üìç Andar atual:", currentFloor)
                if currentFloor == andarSaida then 
                    print("üö™ Chegou ao andar de sa√≠da, saindo do castelo...")
                    sairCastelo() 
                end
            end
        end
    end
end)

-- Inicializa√ß√£o
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end
if ativarAutoFly then 
    task.wait(2) -- Aguarda um pouco antes de iniciar
    local mainFolder = workspace:FindFirstChild("__Main")
    if mainFolder then
        local enemiesFolder = mainFolder:FindFirstChild("__Enemies")
        if enemiesFolder then
            startAutoFly(enemiesFolder)
        end
    end
end

print("‚úÖ Allan Hub carregado com corre√ß√µes!")
print("üéÆ Auto Fly corrigido para detectar mobs corretamente")
print("üíé Sistema de reset com gems corrigido") 
print("üîß Para parar manualmente: _G.stopAutoFly()")

_G.stopAutoFly = stopAutoFly
