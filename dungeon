--[=[
    Script: Allan Hub - Arise (Fly Only Mode)
    Descri√ß√£o: Vers√£o simplificada para focar apenas em voar at√© os mobs na dungeon.
               Todas as fun√ß√µes de combate foram removidas.
    Data da Atualiza√ß√£o: 19/08/2025
--]=]

-- ===== Servi√ßos e Vari√°veis Globais =====
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Vari√°veis de controle de estado
local ativarEvento = false
local ativarDungeon = false
local ativarGems = false
local andarEntrada = 10
local andarSaida = 1
local currentFloor = 0
local dungeonActive = false

-- Nomes de arquivos de configura√ß√£o
local configFile = "allan_hub_castelo.json"
local tempFile = "temp_dungeon.json"

-- ===== Fun√ß√µes de Arquivo =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Fun√ß√µes de Configura√ß√£o (Salvar/Carregar) =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        dungeonActive = dungeonActive
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local success, data = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end)
        if success and type(data) == "table" then
            andarEntrada = tonumber(data.entrada) or andarEntrada
            andarSaida = tonumber(data.saida) or andarSaida
            ativarEvento = data.evento or false
            ativarDungeon = data.dungeon or false
            ativarGems = data.gems or false
            dungeonActive = data.dungeonActive or false
        else
            salvarConfig()
        end
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Fun√ß√µes de Verifica√ß√£o de Estado =====
local function isInDungeon()
    return workspace:FindFirstChild("__Enemies") or workspace:FindFirstChild("Dungeon")
end

local function mobsVivos()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true
            end
        end
    end
    return false
end

-- ===== A√ß√µes da Dungeon =====
local function entrarCastelo()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = { [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local function sairCastelo()
    print("üö™ Saindo do castelo")
    local args = { [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local function iniciarDungeon()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local function criarDungeon()
    if dungeonActive then print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o."); return end
    if isInDungeon() then print("‚ö†Ô∏è J√° est√° em uma dungeon."); dungeonActive = true; salvarConfig(); return end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5)
    iniciarDungeon()
end

local function resetarDungeon()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end


---------------------------------------------------------------------
--- SISTEMA DE VOO (Copiado 1:1 e ajustado para funcionar) ---
---------------------------------------------------------------------

-- Vari√°veis de estado para o sistema de voo
local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil

-- Configura√ß√µes de voo
local FLIGHT_SPEED = 500 -- Velocidade de voo
local FLIGHT_HEIGHT = 5 -- Altura acima do mob

-- Fun√ß√£o para verificar se uma posi√ß√£o j√° foi visitada recentemente
local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

-- Fun√ß√£o para adicionar posi√ß√£o √† lista de visitadas
local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

-- Fun√ß√£o para ativar o voo
local function enableFlight()
    if flyConnection then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    flyConnection = bodyVelocity
end

-- Fun√ß√£o para desativar o voo
local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

-- Fun√ß√£o para voar at√© uma posi√ß√£o usando Tween
local function flyToPosition(targetPosition)
    if currentTween then currentTween:Cancel(); currentTween = nil; end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    
    print("‚úàÔ∏è Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    return currentTween
end

-- Fun√ß√£o para encontrar o mob mais pr√≥ximo
local function getClosestUnvisitedMob()
    -- CORRE√á√ÉO IMPORTANTE: Procura a pasta de inimigos no local correto
    local enemiesFolder = workspace:FindFirstChild("__Enemies")
    if not enemiesFolder then 
        print("‚ùå Pasta '__Enemies' n√£o encontrada em workspace.")
        return nil 
    end

    local closestMob, shortestDistance = nil, math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in ipairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder:IsA("Model") then
            local mobHRP = mobFolder:FindFirstChild("HumanoidRootPart")
            if mobHRP and mobHRP.Parent then
                local dist = (hrp.Position - mobHRP.Position).Magnitude
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        table.insert(allMobs, {mob = mobHRP, distance = dist})
                    end
                end
            end
        end
    end
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        if not isPositionVisited(mobData.mob.Position) then
            if mobData.distance < shortestDistance then
                shortestDistance = dist
                closestMob = mobData.mob
            end
        end
    end
    
    -- Se n√£o encontrar, limpa a lista de visitados e pega o mais pr√≥ximo
    if not closestMob and #allMobs > 0 then
        print("üîç Nenhum mob novo encontrado. Resetando lista de visitados.")
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            if mobData.distance < shortestDistance then
                shortestDistance = mobData.distance
                closestMob = mobData.mob
            end
        end
    end
    
    if #allMobs > 0 then
     print("üéØ Mobs encontrados:", #allMobs, "| Dist√¢ncia do pr√≥ximo alvo:", math.floor(shortestDistance))
    end
    return closestMob
end

-- ===== NOVA FUN√á√ÉO PRINCIPAL (APENAS VOO) =====
local function flyToAllMobs()
    print("‚úàÔ∏è Iniciando modo 'Voar at√© Mobs'...")
    
    -- Reseta o estado do voo para cada nova dungeon
    visitedPositions = {}
    currentTarget = nil
    stuckCounter = 0
    
    enableFlight()
    
    local combatStart = tick()
    -- O loop continua enquanto houver mobs vivos (ou por no m√°ximo 5 minutos)
    while mobsVivos() and (tick() - combatStart < 300) do
        local mob = getClosestUnvisitedMob()
        
        if mob and mob.Parent then
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    print("‚ö†Ô∏è Parece que estou preso no mesmo mob. Adicionando √† lista de visitados.")
                    addVisitedPosition(mob.Position)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue -- Pula para a pr√≥xima itera√ß√£o do loop
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end
            
            local flyTween = flyToPosition(mob.Position)
            local startTime = tick()
            
            repeat
                task.wait(0.1)
                if not mob.Parent then break end -- Mob morreu ou sumiu
                if (hrp.Position - mob.Position).Magnitude < 15 then break end -- Chegou perto
            until (tick() - startTime) > 10 or flyTween.PlaybackState == Enum.PlaybackState.Completed
            
            if currentTween then currentTween:Cancel(); currentTween = nil; end
            
            print("‚úÖ Chegou pr√≥ximo ao mob!")
            addVisitedPosition(mob.Position)
            task.wait(2) -- Espera um pouco antes de ir para o pr√≥ximo
            
        else
            print("ü§∑ Nenhum mob encontrado para voar. Aguardando...")
            task.wait(2)
        end
        task.wait(0.5)
    end
    
    disableFlight()
    print("‚úàÔ∏è Sequ√™ncia de voo finalizada.")
end


-- ===== Loop Principal (controla entrada e sa√≠da da dungeon) =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5)
        
        if not isInDungeon() and not dungeonActive then
            print("üèóÔ∏è Preparando para criar dungeon...")
            if ativarEvento then entrarCastelo(); task.wait(5); end
            criarDungeon()
            task.wait(8)
        end

        if isInDungeon() then
            print("üéÆ Executando dungeon...")
            flyToAllMobs() -- A √∫nica a√ß√£o agora √© voar at√© os mobs
            task.wait(3)
            
            if ativarGems then
                resetarDungeon()
            else
                sairCastelo()
                task.wait(5)
                if ativarEvento then entrarCastelo() end
            end
            task.wait(5)
        end
    end
    
    print("üõë Loop de auto dungeon parado")
    disableFlight() -- Garante que o voo pare se o loop for desativado
end

-- ===== Interface Gr√°fica (GUI) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (Fly Only)",
    SubTitle = "Apenas Voa at√© os Mobs",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })

-- Painel de Status
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

task.spawn(function()
    while task.wait(2) do
        local statusContent = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
]], 
            ativarEvento and "‚úÖ" or "‚ùå",
            isInDungeon() and "‚úÖ" or "‚ùå", 
            mobsVivos() and "‚úÖ" or "‚ùå", 
            dungeonActive and "‚úÖ" or "‚ùå",
            ativarDungeon and "‚úÖ" or "‚ùå"
        )
        statusParagraph:SetDesc(statusContent)
    end
end)

-- Controles na Aba Principal
local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon (Ativa o Voo)", 
    Description = "Cria/Inicia a dungeon e voa at√© os mobs",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        else
            disableFlight() -- Desativa o voo ao desligar o toggle
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

t:AddButton({
    Title = "üîÑ Reset Dungeon Status",
    Description = "Limpa flags de dungeon se algo der errado",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("üîÑ Status da dungeon resetado!")
    end
})

-- Bot√£o Flutuante
local floatingGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
floatingGui.Name = "AllanHubFloating"
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton", floatingGui)
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
toggleButton.Text = "üîº"
toggleButton.TextScaled = true
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    Window.Visible = hubVisivel
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Monitoramento do andar do jogador
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üè¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Inicializa√ß√£o Autom√°tica
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("‚úÖ Allan Hub (Modo Apenas Voo) carregado com sucesso!")
