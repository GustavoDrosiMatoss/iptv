local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local dungeonInfinita = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false
local dungeonCompleted = false

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== Vari√°veis do sistema de voo =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil
local autoFlyActive = false

-- Configura√ß√µes de voo
local FLIGHT_SPEED = 500
local FLIGHT_HEIGHT = 5

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Salvar/Carregar =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        dungeonInfinita = dungeonInfinita,
        dungeonActive = dungeonActive,
        dungeonCompleted = dungeonCompleted
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
        dungeonInfinita = data.dungeonInfinita or false
        dungeonActive = data.dungeonActive or false
        dungeonCompleted = data.dungeonCompleted or false
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Sistema de voo (√öNICO SISTEMA DE MOVIMENTO) =====
local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function enableFlight()
    if flyConnection then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    flyConnection = bodyVelocity
end

local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function flyToPosition(targetPosition)
    -- Verifica√ß√µes de seguran√ßa
    if not char or not char.Parent or not hrp or not hrp.Parent then
        print("‚ùå Personagem inv√°lido, n√£o √© poss√≠vel voar")
        return nil
    end
    
    if not targetPosition then
        print("‚ùå Posi√ß√£o alvo inv√°lida")
        return nil
    end
    
    enableFlight()
    
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    
    -- Verifica√ß√£o de seguran√ßa para posi√ß√µes
    local success, result = pcall(function()
        local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
        local distance = (hrp.Position - targetPosition).Magnitude
        local duration = math.max(distance / FLIGHT_SPEED, 0.1) -- M√≠nimo 0.1 segundos
        
        local tweenInfo = TweenInfo.new(
            duration,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.InOut,
            0,
            false,
            0
        )
        
        return TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    end)
    
    if not success then
        print("‚ùå Erro ao criar tween de voo:", result)
        return nil
    end
    
    currentTween = result
    currentTween:Play()
    
    print("üöÅ Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    
    return currentTween
end

local function getClosestUnvisitedMob()
    local enemiesFolder = workspace:FindFirstChild("__Enemies")
    if not enemiesFolder then 
        print("‚ùå Pasta __Enemies n√£o encontrada")
        return nil, 0 
    end
    
    -- Verificar se o personagem ainda existe
    if not char or not char.Parent or not hrp or not hrp.Parent then
        print("‚ùå Personagem ou HumanoidRootPart inv√°lido")
        return nil, 0
    end
    
    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            
            if mob and mob:IsA("BasePart") and mob.Parent then
                -- Verifica√ß√£o de seguran√ßa para posi√ß√£o
                local success, dist = pcall(function()
                    return (hrp.Position - mob.Position).Magnitude
                end)
                
                if success and dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    local isAlive = true
                    
                    if humanoid then
                        isAlive = humanoid.Health > 0
                    end
                    
                    if isAlive then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        local mob = mobData.mob
        if mob and mob.Parent and not isPositionVisited(mob.Position) then
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    -- Se n√£o encontrar mobs n√£o visitados, limpa a lista e pega qualquer um
    if not closestMob and #allMobs > 0 then
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            local mob = mobData.mob
            if mob and mob.Parent then
                local dist = mobData.distance
                if dist < shortestDistance then
                    shortestDistance = dist
                    closestMob = mob
                end
            end
        end
    end
    
    print("üéØ Mobs encontrados:", #allMobs, "| Dist√¢ncia do mais pr√≥ximo:", shortestDistance < math.huge and math.floor(shortestDistance) or "N/A")
    return closestMob, #allMobs
end

local function stopAutoFly()
    autoFlyActive = false
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    disableFlight()
    print("üõë Sistema de voo parado!")
end

-- ===== Verifica√ß√µes =====
local isInDungeon = function()
    local enemies = workspace:FindFirstChild("__Enemies")
    local dungeonFolder = workspace:FindFirstChild("Dungeon")
    return enemies ~= nil or dungeonFolder ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    local count = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                count = count + 1
            end
        end
    end
    print("üéØ Mobs vivos encontrados:", count)
    return count > 0
end

local function resetDungeonStatus()
    print("üîÑ Limpando status da dungeon automaticamente...")
    dungeonActive = false
    dungeonCompleted = false
    salvarConfig()
    safeDelete(tempFile)
end

-- ===== A√ß√µes =====
local entrarCastelo = function()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    task.wait(3)
end

local sairCastelo = function()
    print("üö™ Saindo do castelo")
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    task.wait(2)
    resetDungeonStatus()
end

local iniciarDungeon = function()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    task.wait(3)
end

local criarDungeon = function()
    if dungeonActive and not dungeonCompleted then 
        print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o")
        return 
    end
    
    if isInDungeon() then 
        print("‚ö†Ô∏è J√° est√° em uma dungeon")
        dungeonActive = true
        dungeonCompleted = false
        salvarConfig()
        return 
    end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    dungeonCompleted = false
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5)
    iniciarDungeon()
end

local resetarDungeon = function()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    task.wait(3)
    resetDungeonStatus()
end

local atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    if attacked > 0 then
        print("‚öîÔ∏è Atacou", attacked, "inimigos")
    end
    return attacked
end

-- ===== Sistema de combate com voo (√öNICO SISTEMA) =====
local function startCombatSystem()
    if autoFlyActive then return end
    autoFlyActive = true
    
    task.spawn(function()
        -- Verifica√ß√£o inicial do personagem
        if not char or not char.Parent or not hrp or not hrp.Parent then
            print("‚ùå Personagem inv√°lido, n√£o √© poss√≠vel iniciar combate")
            autoFlyActive = false
            return
        end
        
        enableFlight()
        print("üöÅ Sistema de voo e combate iniciado!")
        
        local consecutiveNoMobChecks = 0
        local maxConsecutiveChecks = 20
        local mobsKilled = 0
        local combatStarted = false
        
        while autoFlyActive and (ativarDungeon and isInDungeon()) do
            -- Verificar se personagem ainda √© v√°lido
            if not char or not char.Parent or not hrp or not hrp.Parent then
                print("‚ùå Personagem perdido durante combate, parando sistema")
                break
            end
            
            local mob, mobCount = getClosestUnvisitedMob()
            
            if mob and mob.Parent then
                consecutiveNoMobChecks = 0
                
                if not combatStarted then
                    combatStarted = true
                    print("‚öîÔ∏è Combate iniciado - Mobs detectados!")
                end
                
                -- Verifica se √© o mesmo alvo da vez anterior
                if currentTarget and currentTarget == mob then
                    stuckCounter = stuckCounter + 1
                    if stuckCounter > 3 then
                        print("‚ö†Ô∏è Preso no mesmo mob, marcando como visitado...")
                        addVisitedPosition(mob.Position)
                        stuckCounter = 0
                        currentTarget = nil
                        task.wait(1)
                        continue
                    end
                else
                    stuckCounter = 0
                    currentTarget = mob
                end
                
                -- Voa at√© o mob com prote√ß√£o contra erro
                local flyTween = flyToPosition(mob.Position)
                
                if flyTween then
                    -- Espera o voo completar
                    local startTime = tick()
                    local maxWaitTime = 15
                    
                    repeat
                        task.wait(0.1)
                        
                        -- Verifica√ß√µes de seguran√ßa
                        if not mob.Parent or not hrp.Parent then break end
                        
                        local success, distance = pcall(function()
                            return (hrp.Position - mob.Position).Magnitude
                        end)
                        
                        if not success or distance < 15 then break end
                        
                    until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
                    
                    if currentTween then
                        currentTween:Cancel()
                        currentTween = nil
                    end
                    
                    print("üìç Chegou pr√≥ximo ao mob!")
                    
                    -- Ataca o mob atual v√°rias vezes
                    for i = 1, 3 do
                        local attacked = atacarInimigos()
                        mobsKilled = mobsKilled + attacked
                        task.wait(0.5)
                    end
                    
                    print("üéØ Mobs eliminados nesta sess√£o:", mobsKilled)
                    addVisitedPosition(mob.Position)
                else
                    print("‚ùå Falha ao iniciar voo, tentando pr√≥ximo mob...")
                    task.wait(1)
                end
                
            else
                consecutiveNoMobChecks = consecutiveNoMobChecks + 1
                print("‚ùå Verifica√ß√£o", consecutiveNoMobChecks, "/", maxConsecutiveChecks, "- Nenhum mob encontrado")
                
                -- S√≥ considera completada se j√° come√ßou combate E passou tempo suficiente sem mobs
                if combatStarted and consecutiveNoMobChecks >= maxConsecutiveChecks then
                    print("‚úÖ Dungeon completada! Mobs eliminados:", mobsKilled)
                    
                    -- Limpar cache
                    visitedPositions = {}
                    currentTarget = nil
                    stuckCounter = 0
                    mobsKilled = 0
                    combatStarted = false
                    
                    if dungeonInfinita then
                        print("üîÑ Dungeon INF - Resetando com gems...")
                        stopAutoFly()
                        task.wait(2)
                        resetarDungeon()
                        task.wait(5)
                        
                        -- Recriar dungeon
                        criarDungeon()
                        task.wait(8)
                        
                        -- Reativar sistema de combate se ainda em dungeon
                        if isInDungeon() then
                            startCombatSystem()
                        end
                        return
                    else
                        dungeonCompleted = true
                        salvarConfig()
                        print("‚úÖ Dungeon normal completada!")
                        break
                    end
                else
                    if not combatStarted then
                        print("‚è≥ Aguardando mobs aparecerem...")
                    end
                    task.wait(0.5)
                end
            end
            
            task.wait(0.5)
        end
        
        print("üõë Sistema de combate finalizado")
        autoFlyActive = false
        disableFlight()
    end)
end

-- ===== Loop principal CORRIGIDO =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(3)
        
        -- Se n√£o est√° em dungeon E (n√£o est√° ativa OU foi completada)
        if not isInDungeon() and (not dungeonActive or dungeonCompleted) then
            print("üèóÔ∏è Preparando para criar nova dungeon...")
            
            -- Reset status para nova dungeon
            resetDungeonStatus()
            
            if ativarEvento then 
                entrarCastelo()
                task.wait(3) 
            end
            
            criarDungeon()
            task.wait(8)
        end

        -- Se est√° em dungeon e dungeon est√° ativa
        if isInDungeon() and dungeonActive and not dungeonCompleted then
            print("üéÆ Executando dungeon...")
            solarDungeon()
            task.wait(3)
            
            -- Ap√≥s completar, decidir pr√≥ximo passo
            if dungeonCompleted then
                if ativarGems then
                    print("üíé Usando gems para reset...")
                    resetarDungeon()
                    task.wait(5)
                else
                    print("üö™ Saindo para recriar...")
                    sairCastelo()
                    task.wait(5)
                    if ativarEvento then 
                        entrarCastelo()
                        task.wait(3)
                    end
                end
            end
        end
        
        -- Verifica√ß√£o de seguran√ßa: se est√° h√° muito tempo sem fazer nada
        if dungeonActive and not isInDungeon() then
            print("‚ö†Ô∏è Dungeon ativa mas n√£o est√° em dungeon - resetando status")
            resetDungeonStatus()
        end
    end
    
    print("üõë Loop de auto dungeon parado")
end

-- ===== GUI =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (AUTO FIXED)",
    SubTitle = "Reset Autom√°tico de Dungeon",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

-- Status Tab
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

-- Fun√ß√£o para atualizar status
local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
‚úÖ Dungeon Completada: %s
üîÑ Auto Dungeon: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        dungeonCompleted and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

-- Atualizar status a cada 2 segundos
task.spawn(function()
    while true do
        updateStatus()
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Cria/Inicia/Reseta automaticamente",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

-- Bot√µes de controle manual (agora desnecess√°rio, mas mantido para debug)
t:AddButton({
    Title = "üîÑ Force Reset Status",
    Description = "For√ßa limpeza manual (apenas debug)",
    Callback = function()
        resetDungeonStatus()
        print("üîÑ Status for√ßado manualmente!")
    end
})

-- Bot√£o flutuante
local floatingGui = Instance.new("ScreenGui")
floatingGui.Name = "AllanHubFloating"
floatingGui.Parent = player:WaitForChild("PlayerGui")
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "‚öô"
toggleButton.TextScaled = true
toggleButton.Parent = floatingGui
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    if Window and Window.Frame then
        Window.Frame.Visible = hubVisivel
    end
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Watch do andar
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üè¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Autostart se estiver ativo no config
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("‚úÖ Allan Hub carregado com reset autom√°tico!")