local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local ativarAutoFly  = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== FUNÇÃO DE AUTO FARM COM VOO (MODIFICADA PARA SER MAIS FLEXÍVEL) =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- << MODIFICADO >>: Esta agora é a pasta padrão, mas podemos usar outras.
local defaultEnemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies")

local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil
local autoFlyRunning = false
local autoFlyCoroutine = nil

local FLIGHT_SPEED = 500
local FLIGHT_HEIGHT = 5

local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function enableFlight()
    if flyConnection then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    flyConnection = bodyVelocity
end

local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

local function flyToPosition(targetPosition)
    enableFlight()
    if currentTween then currentTween:Cancel(); currentTween = nil end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    return currentTween
end

-- << MODIFICADO >>: Agora aceita uma pasta de inimigos como argumento.
local function getClosestUnvisitedMob(enemiesFolder)
    if not enemiesFolder or not enemiesFolder:IsA("Folder") then
        print("Pasta de inimigos inválida ou não encontrada.")
        return nil
    end

    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            if mob and mob:IsA("BasePart") and mob.Parent then
                local dist = (hrp.Position - mob.Position).Magnitude
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    for _, mobData in pairs(allMobs) do
        if not isPositionVisited(mobData.mob.Position) then
            if mobData.distance < shortestDistance then
                shortestDistance = mobData.distance
                closestMob = mobData.mob
            end
        end
    end
    
    if not closestMob and #allMobs > 0 then
        visitedPositions = {} -- Limpa a lista se não achar um não visitado, para tentar de novo
        shortestDistance = allMobs[1].distance
        closestMob = allMobs[1].mob
    end
    
    return closestMob
end

-- << MODIFICADO >>: Passa a pasta para a função getClosestUnvisitedMob.
local function flyToMobLoop(enemiesFolder)
    enableFlight()
    
    while autoFlyRunning do
        local mob = getClosestUnvisitedMob(enemiesFolder)
        
        if mob and mob.Parent then
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    addVisitedPosition(mob.Position)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end
            
            local flyTween = flyToPosition(mob.Position)
            local startTime = tick()
            local maxWaitTime = 10
            
            repeat
                task.wait(0.1)
                if not autoFlyRunning then break end
                local distance = (hrp.Position - mob.Position).Magnitude
                if distance < 15 or not mob.Parent then break end
            until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
            
            if currentTween then currentTween:Cancel(); currentTween = nil end
            
            task.wait(2) -- Tempo para seu personagem atacar o mob
            addVisitedPosition(mob.Position)
        else
            -- Se não encontrar mais mobs, para o loop para que a dungeon possa ser resetada.
            print("Nenhum mob encontrado na pasta especificada. Parando o voo.")
            autoFlyRunning = false -- Para o loop while
            break
        end
        
        if autoFlyRunning then
            task.wait(0.5)
        end
    end
    -- Ao sair do loop, garante que o voo seja desativado
    disableFlight()
end

-- << MODIFICADO >>: Aceita um argumento para a pasta de inimigos.
local function startAutoFly(targetFolder)
    if autoFlyRunning then return end
    
    local folderToScan = targetFolder or defaultEnemiesFolder
    print("Iniciando voo automático para mobs na pasta:", folderToScan.Name)
    autoFlyRunning = true
    
    autoFlyCoroutine = coroutine.create(function()
        pcall(flyToMobLoop, folderToScan)
        -- Quando o loop termina, chama stopAutoFly para garantir a limpeza
        stopAutoFly()
    end)
    
    coroutine.resume(autoFlyCoroutine)
end

local function stopAutoFly()
    if not autoFlyRunning and not flyConnection then return end -- Evita prints desnecessários
    autoFlyRunning = false
    if currentTween then currentTween:Cancel(); currentTween = nil end
    disableFlight()
    visitedPositions = {}
    currentTarget = nil
    stuckCounter = 0
    print("Script de voo automático parado!")
end

-- ===== FIM DA FUNÇÃO DE AUTO FARM COM VOO =====

local function safeDelete(path)
    if isfile and isfile(path) then
        pcall(function() writefile(path, "") end)
    end
end

local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        autofly = ativarAutoFly, dungeonActive = dungeonActive
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local success, data = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end)
        if success and type(data) == "table" then
            andarEntrada  = tonumber(data.entrada) or andarEntrada
            andarSaida    = tonumber(data.saida) or andarSaida
            ativarEvento  = data.evento or false
            ativarDungeon = data.dungeon or false
            ativarGems    = data.gems or false
            ativarAutoFly = data.autofly or false
            dungeonActive = data.dungeonActive or false
        end
    else
        salvarConfig()
    end
end
carregarConfig()

local isInDungeon = function()
    return workspace:FindFirstChild("__Enemies") ~= nil or workspace:FindFirstChild("Dungeon") ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true -- Se encontrar pelo menos um vivo, já retorna
            end
        end
    end
    return false
end

local entrarCastelo = function()
    print("🏰 Entrando no castelo - Andar:", andarEntrada)
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join"}, [2] = "\12"})
end

local sairCastelo = function()
    print("🚪 Saindo do castelo")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon"}, [2] = "\12"})
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local iniciarDungeon = function()
    print("▶️ Iniciando dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Start"}, [2] = "\12"})
end

local criarDungeon = function()
    if dungeonActive or isInDungeon() then return end
    print("🆕 Criando nova dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Create"}, [2] = "\12"})
    dungeonActive = true
    salvarConfig()
    task.wait(5)
    iniciarDungeon()
end

local resetarDungeon = function()
    print("💎 Resetando dungeon com gems...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Type = "Gems", Event = "DungeonAction", Action = "BuyTicket"}, [2] = "\12"})
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local function verificarEresetarSeNecessario()
    print("🔎 Verificando se a dungeon foi concluída...")
    task.wait(3)
    if not mobsVivos() then
        print("✅ Dungeon limpa! Iniciando o processo de reset.")
        if ativarGems then
            resetarDungeon()
        else
            sairCastelo()
            task.wait(5)
            if ativarEvento then entrarCastelo() end
        end
        task.wait(3)
        return true
    else
        print("⚠️ Ainda existem mobs vivos.")
        return false
    end
end

-- << NOVA FUNÇÃO >>: Substitui a antiga 'solarDungeon'
local function solarDungeonComVoo()
    print("🌟 Iniciando limpeza da dungeon com Auto Voo...")
    local dungeonEnemiesFolder = workspace:FindFirstChild("__Enemies")
    
    if not dungeonEnemiesFolder then
        print("❌ Pasta de inimigos da dungeon não encontrada.")
        return
    end
    
    -- Inicia o voo focado apenas na pasta da dungeon
    startAutoFly(dungeonEnemiesFolder)
    
    local startTime = tick()
    -- Espera até que o voo pare (por não achar mobs) ou dê timeout
    while autoFlyRunning and (tick() - startTime < 300) and ativarDungeon do
        print("✈️ Limpando dungeon... Aguardando Auto Voo terminar.")
        task.wait(2)
    end
    
    -- Garante que o voo seja parado ao final
    stopAutoFly()
    
    if tick() - startTime >= 300 then
        print("⏰ Timeout na limpeza da dungeon.")
    else
        print("🎉 Auto Voo concluiu a limpeza da dungeon!")
    end
end


-- << MODIFICADO >>: O loop principal agora usa a nova função de combate com voo.
local function autoDungeonLoop()
    print("🔄 Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5)
        
        if not isInDungeon() and not dungeonActive then
            print("🏗️ Preparando para criar dungeon...")
            if ativarEvento then entrarCastelo(); task.wait(5) end
            criarDungeon()
            task.wait(8)
        end

        if isInDungeon() then
            print("🎮 Executando dungeon com Auto Voo...")
            -- Chama a nova função que usa o voo para limpar
            solarDungeonComVoo()
            
            -- Após a tentativa de limpeza, verifica e reseta
            verificarEresetarSeNecessario()
        end
    end
    print("🛑 Loop de auto dungeon parado")
end

-- ===== GUI (Inalterada) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED)",
    SubTitle = "Dungeon com Auto Voo + Farm Voador",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
local autoFarmTab = Window:AddTab({ Title = "Auto Farm", Icon = "zap" })
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({Title = "Status Atual",Content = "Aguardando..."})

local function updateStatus()
    local status = string.format([[
🏰 Em Castelo: %s
⚔️ Em Dungeon: %s  
👹 Mobs Vivos: %s
🎯 Dungeon Ativa: %s
🔄 Auto Dungeon: %s
✈️ Auto Farm Voador: %s
]], 
        ativarEvento and "✅" or "❌",
        isInDungeon() and "✅" or "❌",
        mobsVivos() and "✅" or "❌", 
        dungeonActive and "✅" or "❌",
        ativarDungeon and "✅" or "❌",
        autoFlyRunning and "✅" or "❌"
    )
    statusParagraph:SetDesc(status)
end

task.spawn(function()
    while true do
        pcall(updateStatus)
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Saída", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Usa o Auto Voo para limpar a dungeon",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

autoFarmTab:AddToggle("ToggleAutoFly", {
    Title = "Auto Farm Voador (Mundo Aberto)",
    Description = "Ativa/Desativa o farm no mundo principal",
    Default = ativarAutoFly,
    Callback = function(state)
        ativarAutoFly = state
        salvarConfig()
        if state then
            startAutoFly() -- Chama sem argumento para usar a pasta padrão
        else
            stopAutoFly()
        end
    end
})

autoFarmTab:AddParagraph({
    Title = "Informações do Auto Farm",
    Content = "O Auto Farm Voador irá voar automaticamente até os mobs. Use o toggle 'Auto Dungeon' na outra aba para farmar dungeons, e este para farmar no mundo aberto."
})

t:AddButton({
    Title = "🔄 Reset Dungeon Status",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("🔄 Status da dungeon resetado!")
    end
})

local floatingGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
floatingGui.Name = "AllanHubFloating"; floatingGui.ResetOnSpawn = false
local toggleButton = Instance.new("TextButton", floatingGui)
toggleButton.Size = UDim2.new(0, 50, 0, 50); toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100); toggleButton.Text = "⚙"; toggleButton.TextScaled = true
toggleButton.Active = true; toggleButton.Draggable = true
local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    Window.Frame.Visible = hubVisivel
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "🔼" or "🔽"
end)

task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end
if ativarAutoFly then startAutoFly() end

print("✅ Allan Hub carregado com sistema de Dungeon por Auto Voo!")
_G.stopAutoFly = stopAutoFly
