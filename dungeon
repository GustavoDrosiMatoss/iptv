local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false  -- Nova flag para controle

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- ===== VariÃ¡veis para debug =====
local debugMode = true

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Salvar/Carregar (incluindo flag dungeon) =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        dungeonActive = dungeonActive  -- Salvar estado da dungeon
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
        dungeonActive = data.dungeonActive or false  -- Carregar estado
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== VerificaÃ§Ãµes melhoradas =====
local isInDungeon = function()
    local enemies = workspace:FindFirstChild("__Enemies")
    local dungeonFolder = workspace:FindFirstChild("Dungeon") -- Adicionar outras verificaÃ§Ãµes se necessÃ¡rio
    return enemies ~= nil or dungeonFolder ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    local count = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                count = count + 1
            end
        end
    end
    print("ğŸ¯ Mobs vivos encontrados:", count)
    return count > 0
end

-- ===== AÃ§Ãµes corrigidas =====
local entrarCastelo = function()
    print("ğŸ° Entrando no castelo - Andar:", andarEntrada)
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local sairCastelo = function()
    print("ğŸšª Saindo do castelo")
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local iniciarDungeon = function()
    print("â–¶ï¸ Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local criarDungeon = function()
    if dungeonActive then 
        print("âš ï¸ Dungeon jÃ¡ estÃ¡ ativa, pulando criaÃ§Ã£o")
        return 
    end
    
    if isInDungeon() then 
        print("âš ï¸ JÃ¡ estÃ¡ em uma dungeon")
        dungeonActive = true
        salvarConfig()
        return 
    end
    
    print("ğŸ†• Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5) -- Esperar mais tempo para criar
    iniciarDungeon()
end

local resetarDungeon = function()
    print("ğŸ’ Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

-- ===== Sistema de teleporte simplificado =====

local teleportToNearestMob = function()
    local char = player.Character
    if not char then 
        print("âŒ Personagem nÃ£o encontrado")
        return false 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then 
        print("âŒ HumanoidRootPart nÃ£o encontrado")
        return false 
    end
    
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then 
        print("âŒ Pasta __Enemies nÃ£o encontrada")
        return false 
    end

    local closest, bestDistance = nil, math.huge
    local mobCount = 0
    
    print("ğŸ” Procurando mobs...")
    
    for _, mob in pairs(folder:GetChildren()) do
        if mob and mob:IsA("Model") and mob.Parent then
            mobCount = mobCount + 1
            print("ğŸ“‹ Verificando mob:", mob.Name)
            
            local humanoid = mob:FindFirstChild("Humanoid")
            local hrp = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChildWhichIsA("BasePart", true)
            
            if hrp and hrp:IsA("BasePart") then
                local isAlive = true
                if humanoid then
                    isAlive = humanoid.Health > 0
                    print("â¤ï¸ Vida do mob:", humanoid.Health)
                end
                
                if isAlive then
                    local distance = (root.Position - hrp.Position).Magnitude
                    print("ğŸ“ DistÃ¢ncia:", math.floor(distance))
                    
                    if distance < bestDistance then
                        bestDistance = distance
                        closest = hrp
                        print("âœ… Novo mob mais prÃ³ximo encontrado!")
                    end
                end
            else
                print("âŒ Mob sem HumanoidRootPart vÃ¡lido")
            end
        end
    end
    
    print("ğŸ“Š Total de mobs verificados:", mobCount)
    
    if closest then
        root.CFrame = closest.CFrame + Vector3.new(0, 5, 0)
        print("ğŸ“ Teleportado para mob! DistÃ¢ncia:", math.floor(bestDistance))
        return true
    else
        print("âŒ Nenhum mob vÃ¡lido encontrado para teleporte")
        return false
    end
end

local atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    print("âš”ï¸ Atacou", attacked, "inimigos")
    return attacked
end

-- ===== FunÃ§Ã£o principal corrigida =====
local solarDungeon = function()
    print("ğŸŒŸ Iniciando combate na dungeon...")
    
    -- Esperar mobs aparecerem (atÃ© 30 segundos)
    local waitStart = tick()
    while tick() - waitStart < 30 do
        if mobsVivos() then
            print("âœ… Mobs detectados, iniciando combate!")
            break
        end
        print("â³ Aguardando mobs aparecerem...")
        task.wait(2)
    end
    
    if not mobsVivos() then
        print("âŒ Nenhum mob encontrado apÃ³s 30 segundos")
        return
    end

    -- Loop de combate
    local combatStart = tick()
    while mobsVivos() and tick() - combatStart < 300 do -- MÃ¡ximo 5 minutos
        teleportToNearestMob()
        task.wait(0.5)
        atacarInimigos()
        task.wait(1)
    end
    
    if mobsVivos() then
        print("â° Timeout no combate apÃ³s 5 minutos")
    else
        print("ğŸ‰ Todos os mobs foram derrotados!")
    end
end

-- ===== Loop principal corrigido =====
local function autoDungeonLoop()
    print("ğŸ”„ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5) -- Espera maior entre ciclos
        
        if not isInDungeon() and not dungeonActive then
            print("ğŸ—ï¸ Preparando para criar dungeon...")
            
            if ativarEvento then 
                entrarCastelo()
                task.wait(5) 
            end
            
            criarDungeon()
            task.wait(8) -- Mais tempo para processar
        end

        if isInDungeon() then
            print("ğŸ® Executando dungeon...")
            solarDungeon()
            task.wait(3)
            
            if ativarGems then
                resetarDungeon()
                task.wait(5)
            else
                sairCastelo()
                task.wait(5)
                if ativarEvento then entrarCastelo() end
                task.wait(3)
            end
        end
    end
    
    print("ğŸ›‘ Loop de auto dungeon parado")
end

-- ===== GUI (mantida igual) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED)",
    SubTitle = "Dungeon AutomÃ¡tica Corrigida",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

-- Status Tab
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

-- FunÃ§Ã£o para atualizar status
local function updateStatus()
    local status = string.format([[
ğŸ° Em Castelo: %s
âš”ï¸ Em Dungeon: %s  
ğŸ‘¹ Mobs Vivos: %s
ğŸ¯ Dungeon Ativa: %s
ğŸ”„ Auto Dungeon: %s
]], 
        ativarEvento and "âœ…" or "âŒ",
        isInDungeon() and "âœ…" or "âŒ",
        mobsVivos() and "âœ…" or "âŒ", 
        dungeonActive and "âœ…" or "âŒ",
        ativarDungeon and "âœ…" or "âŒ"
    )
    statusParagraph:SetDesc(status)
end

-- Atualizar status a cada 2 segundos
task.spawn(function()
    while true do
        updateStatus()
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de SaÃ­da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Cria/Inicia/Reseta automaticamente",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

-- BotÃµes de controle manual
t:AddButton({
    Title = "ğŸ”„ Reset Dungeon Status",
    Description = "Limpa flags de dungeon",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("ğŸ”„ Status da dungeon resetado!")
    end
})

-- BotÃ£o flutuante (mantido igual)
local floatingGui = Instance.new("ScreenGui")
floatingGui.Name = "AllanHubFloating"
floatingGui.Parent = player:WaitForChild("PlayerGui")
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "âš™"
toggleButton.TextScaled = true
toggleButton.Parent = floatingGui
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    if Window and Window.Frame then
        Window.Frame.Visible = hubVisivel
    end
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "ğŸ”¼" or "ğŸ”½"
end)

-- Watch do andar (mantido)
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("ğŸ¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Autostart se estiver ativo no config
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("âœ… Allan Hub carregado com correÃ§Ãµes!")