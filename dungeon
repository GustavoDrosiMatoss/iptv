local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local dungeonInfinita = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false
local dungeonCompleted = false

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== Vari√°veis do sistema de voo =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil
local autoFlyActive = false

-- Configura√ß√µes de voo
local FLIGHT_SPEED = 500
local FLIGHT_HEIGHT = 5

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Salvar/Carregar =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        dungeonInfinita = dungeonInfinita,
        dungeonActive = dungeonActive,
        dungeonCompleted = dungeonCompleted
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
        dungeonInfinita = data.dungeonInfinita or false
        dungeonActive = data.dungeonActive or false
        dungeonCompleted = data.dungeonCompleted or false
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Sistema de voo (√öNICO SISTEMA DE MOVIMENTO) =====
local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function enableFlight()
    if flyConnection then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    flyConnection = bodyVelocity
end

local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function flyToPosition(targetPosition)
    enableFlight()
    
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut,
        0,
        false,
        0
    )
    
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    
    print("üöÅ Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    
    return currentTween
end

local function getClosestUnvisitedMob()
    local enemiesFolder = workspace:FindFirstChild("__Enemies")
    if not enemiesFolder then return nil, 0 end
    
    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            
            if mob and mob:IsA("BasePart") and mob.Parent then
                local dist = (hrp.Position - mob.Position).Magnitude
                
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    local isAlive = true
                    
                    if humanoid then
                        isAlive = humanoid.Health > 0
                    end
                    
                    if isAlive then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        local mob = mobData.mob
        if not isPositionVisited(mob.Position) then
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    -- Se n√£o encontrar mobs n√£o visitados, limpa a lista e pega qualquer um
    if not closestMob and #allMobs > 0 then
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            local mob = mobData.mob
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    print("üéØ Mobs encontrados:", #allMobs, "| Dist√¢ncia do mais pr√≥ximo:", shortestDistance < math.huge and math.floor(shortestDistance) or "N/A")
    return closestMob, #allMobs
end

local function stopAutoFly()
    autoFlyActive = false
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    disableFlight()
    print("üõë Sistema de voo parado!")
end

-- ===== Verifica√ß√µes =====
local isInDungeon = function()
    local enemies = workspace:FindFirstChild("__Enemies")
    local dungeonFolder = workspace:FindFirstChild("Dungeon")
    return enemies ~= nil or dungeonFolder ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    local count = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                count = count + 1
            end
        end
    end
    print("üéØ Mobs vivos encontrados:", count)
    return count > 0
end

local function resetDungeonStatus()
    print("üîÑ Limpando status da dungeon automaticamente...")
    dungeonActive = false
    dungeonCompleted = false
    salvarConfig()
    safeDelete(tempFile)
end

-- ===== A√ß√µes =====
local entrarCastelo = function()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    task.wait(3)
end

local sairCastelo = function()
    print("üö™ Saindo do castelo")
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    task.wait(2)
    resetDungeonStatus()
end

local iniciarDungeon = function()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    task.wait(3)
end

local criarDungeon = function()
    if dungeonActive and not dungeonCompleted then 
        print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o")
        return 
    end
    
    if isInDungeon() then 
        print("‚ö†Ô∏è J√° est√° em uma dungeon")
        dungeonActive = true
        dungeonCompleted = false
        salvarConfig()
        return 
    end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    dungeonCompleted = false
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5)
    iniciarDungeon()
end

local resetarDungeon = function()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    task.wait(3)
    resetDungeonStatus()
end

local atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    if attacked > 0 then
        print("‚öîÔ∏è Atacou", attacked, "inimigos")
    end
    return attacked
end

-- ===== Sistema de combate com voo (√öNICO SISTEMA) =====
local function startCombatSystem()
    if autoFlyActive then return end
    autoFlyActive = true
    
    task.spawn(function()
        enableFlight()
        print("üöÅ Sistema de voo e combate iniciado!")
        
        while autoFlyActive and (ativarDungeon and isInDungeon()) do
            local mob, mobCount = getClosestUnvisitedMob()
            
            if mob and mob.Parent then
                -- Verifica se √© o mesmo alvo da vez anterior
                if currentTarget and currentTarget == mob then
                    stuckCounter = stuckCounter + 1
                    if stuckCounter > 3 then
                        print("‚ö†Ô∏è Preso no mesmo mob, marcando como visitado...")
                        addVisitedPosition(mob.Position)
                        stuckCounter = 0
                        currentTarget = nil
                        task.wait(1)
                        continue
                    end
                else
                    stuckCounter = 0
                    currentTarget = mob
                end
                
                -- Voa at√© o mob
                local flyTween = flyToPosition(mob.Position)
                
                -- Espera o voo completar
                local startTime = tick()
                local maxWaitTime = 10
                
                repeat
                    task.wait(0.1)
                    local distance = (hrp.Position - mob.Position).Magnitude
                    
                    if distance < 15 then break end
                    if not mob.Parent then break end
                    
                until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
                
                if currentTween then
                    currentTween:Cancel()
                    currentTween = nil
                end
                
                print("üìç Chegou pr√≥ximo ao mob!")
                
                -- Ataca o mob atual
                atacarInimigos()
                
                task.wait(1)
                addVisitedPosition(mob.Position)
                
            else
                print("‚ùå Nenhum mob encontrado!")
                
                -- Se Dungeon INF est√° ativa e n√£o h√° mobs, resetar com gems
                if dungeonInfinita and isInDungeon() then
                    visitedPositions = {}
                    currentTarget = nil
                    stuckCounter = 0
                    
                    print("üîÑ Dungeon INF ativa - Resetando com gems automaticamente...")
                    stopAutoFly()
                    resetarDungeon()
                    task.wait(5)
                    
                    -- Recriar dungeon
                    criarDungeon()
                    task.wait(8)
                    
                    -- Reativar sistema de combate
                    if isInDungeon() then
                        startCombatSystem()
                    end
                    return
                else
                    -- Dungeon normal - marcar como completada
                    dungeonCompleted = true
                    salvarConfig()
                    print("‚úÖ Dungeon completada!")
                    break
                end
            end
            
            task.wait(0.5)
        end
        
        print("üõë Sistema de combate finalizado")
        autoFlyActive = false
        disableFlight()
    end)
end

-- ===== Loop principal =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(3)
        
        -- APENAS no modo Dungeon INF: Criar/Entrar na dungeon automaticamente
        if dungeonInfinita then
            if not isInDungeon() and (not dungeonActive or dungeonCompleted) then
                print("üöÅ Dungeon INF - Criando nova dungeon...")
                resetDungeonStatus()
                
                if ativarEvento then 
                    entrarCastelo()
                    task.wait(3) 
                end
                
                criarDungeon()
                task.wait(8)
            end
        end

        -- Se est√° em dungeon e deve iniciar combate
        if isInDungeon() and dungeonActive and not dungeonCompleted and not autoFlyActive then
            print("üéÆ Iniciando sistema de combate...")
            
            -- Esperar mobs aparecerem
            local waitStart = tick()
            while tick() - waitStart < 30 do
                if mobsVivos() then 
                    print("‚úÖ Mobs detectados!")
                    break 
                end
                print("‚è≥ Aguardando mobs aparecerem...")
                task.wait(2)
            end
            
            if mobsVivos() then
                startCombatSystem()
            else
                print("‚ùå Nenhum mob encontrado ap√≥s 30 segundos")
                dungeonCompleted = true
                salvarConfig()
            end
        end
        
        -- Processar ap√≥s completar dungeon
        if dungeonCompleted and not autoFlyActive then
            if dungeonInfinita then
                print("üöÅ Dungeon INF - Sistema autom√°tico gerencia tudo...")
                -- No modo INF, o pr√≥prio sistema de combate j√° reinicia
            else
                print("üéØ Dungeon Normal completada - Saindo...")
                if ativarGems then
                    print("üíé Usando gems para reset...")
                    resetarDungeon()
                else
                    print("üö™ Saindo do castelo...")
                    sairCastelo()
                end
                print("‚úÖ Dungeon Normal finalizada - Use Dungeon INF para modo autom√°tico!")
                break -- Sai do loop para dungeon normal
            end
        end
        
        -- Verifica√ß√£o de seguran√ßa
        if dungeonActive and not isInDungeon() and not dungeonCompleted then
            print("‚ö†Ô∏è Dungeon ativa mas n√£o est√° em dungeon - resetando status")
            resetDungeonStatus()
        end
    end
    
    print("üõë Loop de auto dungeon parado")
    stopAutoFly()
end

-- ===== GUI =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (SEPARATED MODES)",
    SubTitle = "Auto Dungeon vs Dungeon INF",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

-- Status Tab
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
‚úÖ Dungeon Completada: %s
üîÑ Auto Dungeon: %s
üöÅ Dungeon INF (Voo): %s
‚úàÔ∏è Sistema de Voo: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        dungeonCompleted and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå",
        dungeonInfinita and "‚úÖ" or "‚ùå",
        autoFlyActive and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

task.spawn(function()
    while true do
        updateStatus()
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Combate com voo (apenas 1 dungeon)",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        else
            stopAutoFly()
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

-- Bot√£o Dungeon INF
t:AddToggle("ToggleDungeonInf", {
    Title = "üöÅ Dungeon INF",
    Description = "Voo autom√°tico + Cria√ß√£o e reset infinito",
    Default = dungeonInfinita,
    Callback = function(state)
        dungeonInfinita = state
        salvarConfig()
        
        if state then
            print("üöÅ Dungeon INF ativada - Modo infinito autom√°tico!")
            ativarGems = true  -- For√ßa usar gems no modo INF
            ativarDungeon = true -- Ativa auto dungeon automaticamente
            salvarConfig()
            -- Inicia o loop se n√£o estiver rodando
            if not ativarDungeon then
                task.spawn(autoDungeonLoop)
            end
        else
            print("üõë Dungeon INF desativada")
        end
    end
})

t:AddButton({
    Title = "üîÑ Reset Status",
    Description = "Limpa status da dungeon",
    Callback = function()
        resetDungeonStatus()
        stopAutoFly()
        print("üîÑ Status resetado!")
    end
})

t:AddButton({
    Title = "üõë Parar Sistema",
    Description = "Para todo o sistema",
    Callback = function()
        ativarDungeon = false
        salvarConfig()
        stopAutoFly()
        print("üõë Sistema parado completamente!")
    end
})

-- Bot√£o flutuante
local floatingGui = Instance.new("ScreenGui")
floatingGui.Name = "AllanHubFloating"
floatingGui.Parent = player:WaitForChild("PlayerGui")
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "‚öô"
toggleButton.TextScaled = true
toggleButton.Parent = floatingGui
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    if Window and Window.Frame then
        Window.Frame.Visible = hubVisivel
    end
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Watch do andar
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üè¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Reconectar personagem
player.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = char:WaitForChild("HumanoidRootPart")
    stopAutoFly()  -- Para o voo atual
    print("üîÑ Personagem reconectado")
end)

-- Autostart
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("‚úÖ Allan Hub - Sistema √öNICO de Voo Carregado!")
print("üöÅ Agora usa APENAS sistema de voo, sem teleporte!")