--[[ Allan Hub - Arise Crossover (Auto Dungeon + GUI FIX)
     - Corrigido: nÃ£o recriar dungeon ao trocar de servidor
     - Corrigido: loop solarDungeon ataca waves atÃ© o fim
     - Corrigido: ordem das funÃ§Ãµes (nil value)
     - Corrigido: evita leaderstats (usa CurrentFloor)
     - Mantido: Fluent GUI + BotÃ£o flutuante
--]]

-- ===== Configs persistentes =====
local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"

local HttpService = game:GetService("HttpService")

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Flag de teleporte =====
local justTeleported = false
if isfile and isfile(tempFile) then
    justTeleported = true
    print("ðŸ“Œ Detectado teleporte para dungeon, nÃ£o criar outra.")
end

-- ===== Salvar/Carregar =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems
    }
    writefile(configFile, HttpService:JSONEncode(data))
end
local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
    else
        salvarConfig()
    end
end
carregarConfig()

-- ======== PRÃ‰-DECLARAÃ‡ÃƒO ========
local isInDungeon, mobsVivos, atacarInimigos, teleportToNearestMob, solarDungeon
local entrarCastelo, sairCastelo, criarDungeon, iniciarDungeon, resetarDungeon
-- =================================

-- ===== Utilidades =====
isInDungeon = function()
    return workspace:FindFirstChild("__Enemies") ~= nil
end

mobsVivos = function()
    local f = workspace:FindFirstChild("__Enemies")
    if not f then return false end
    for _, mob in ipairs(f:GetChildren()) do
        local h = mob:FindFirstChild("Humanoid")
        if h and h.Health > 0 then return true end
    end
    return false
end

-- ===== AÃ§Ãµes de dungeon =====
entrarCastelo = function()
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

sairCastelo = function()
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    safeDelete(tempFile)
end

iniciarDungeon = function()
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

criarDungeon = function()
    if isInDungeon() then return end
    if isfile and isfile(tempFile) then return end
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    writefile(tempFile, "1")
    task.wait(3)
    iniciarDungeon()
end

resetarDungeon = function()
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    safeDelete(tempFile)
end

-- ===== Combate =====
teleportToNearestMob = function()
    local player = game.Players.LocalPlayer
    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return end

    local closest, best = nil, math.huge
    for _, mob in ipairs(folder:GetChildren()) do
        local h = mob:FindFirstChild("Humanoid")
        local hrp = mob:FindFirstChild("HumanoidRootPart")
        if h and hrp and h.Health > 0 then
            local d = (root.Position - hrp.Position).Magnitude
            if d < best then best = d; closest = hrp end
        end
    end
    if closest then
        root.CFrame = closest.CFrame * CFrame.new(0, 0, 5)
    end
end

atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return end
    for _, mob in ipairs(folder:GetChildren()) do
        local h = mob:FindFirstChild("Humanoid")
        if h and h.Health > 0 then
            local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
            game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
            task.wait(0.1)
        end
    end
end

solarDungeon = function()
    local start = tick()
    while tick() - start < 60 do
        if mobsVivos() then break end
        task.wait(1)
    end
    if not mobsVivos() then return end

    while mobsVivos() do
        teleportToNearestMob()
        atacarInimigos()
        task.wait(0.3)
    end
end

-- ===== Loop =====
local function autoDungeonLoop()
    while ativarDungeon do
        task.wait(3)
        if not justTeleported and not isInDungeon() then
            if ativarEvento then entrarCastelo(); task.wait(5) end
            criarDungeon()
            task.wait(5)
        end
        justTeleported = false

        if isInDungeon() then
            solarDungeon()
            if ativarGems then
                resetarDungeon()
            else
                sairCastelo()
                task.wait(3)
                entrarCastelo()
            end
        end
    end
end

-- ===== GUI (Fluent) =====
-- (mantive igual ao seu, sem cortar nada)

-- ===== GUI (Fluent) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise",
    SubTitle = "Dungeon AutomÃ¡tica",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})
local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})
t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de SaÃ­da",
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})
t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})
t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon",
    Description = "Cria/Inicia/Reseta automaticamente",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then task.spawn(autoDungeonLoop) end
    end
})
t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar",
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

-- BotÃ£o flutuante para mostrar/ocultar o Hub
local floatingGui = Instance.new("ScreenGui")
floatingGui.Name = "AllanHubFloating"
floatingGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "âš™"
toggleButton.TextScaled = true
toggleButton.Parent = floatingGui
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    if Window and Window.Frame then
        Window.Frame.Visible = hubVisivel
    end
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "ðŸ”¼" or "ðŸ”½"
end)

-- Watch do andar (opcional)
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = game.Players.LocalPlayer:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Autostart se estiver ativo no config
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end