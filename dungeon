local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- ===== Verifica√ß√µes de seguran√ßa =====
local function waitForChild(parent, childName, timeout)
    timeout = timeout or 10
    local startTime = tick()
    
    while not parent:FindFirstChild(childName) and tick() - startTime < timeout do
        task.wait(0.1)
    end
    
    return parent:FindFirstChild(childName)
end

local function safeFireServer(remote, ...)
    local success, error = pcall(function()
        remote:FireServer(...)
    end)
    
    if not success then
        warn("Erro ao disparar remote:", error)
        return false
    end
    return true
end

-- ===== Detec√ß√£o de Dungeon melhorada =====
local isInDungeon = function()
    local playerGui = player:WaitForChild("PlayerGui", 5)
    if not playerGui then 
        print("‚ùå PlayerGui n√£o encontrada")
        return false 
    end
    
    -- Lista de termos para detectar UI de dungeon
    local dungeonTerms = {
        "inimigos restantes", "enemies remaining", "tempo restante", 
        "time remaining", "sala:", "room:", "wave", "onda", "boss"
    }
    
    for _, gui in pairs(playerGui:GetChildren()) do
        if gui:IsA("ScreenGui") and gui.Enabled then
            for _, descendant in pairs(gui:GetDescendants()) do
                if descendant:IsA("TextLabel") and descendant.Visible then
                    local text = descendant.Text:lower()
                    for _, term in ipairs(dungeonTerms) do
                        if text:find(term) then
                            print("‚úÖ Dungeon detectada pela UI:", descendant.Text)
                            return true
                        end
                    end
                end
            end
        end
    end
    
    -- Verifica√ß√£o alternativa por objetos no workspace
    local dungeonIndicators = {
        "__Enemies", "DungeonEnemies", "Mobs", "Enemies", 
        "NPCs", "Monsters", "DungeonFolder"
    }
    
    for _, indicator in ipairs(dungeonIndicators) do
        if workspace:FindFirstChild(indicator) then
            print("‚úÖ Dungeon detectada por pasta:", indicator)
            return true
        end
    end
    
    return false
end

-- ===== Encontrar pasta de mobs =====
local encontrarPastaMobs = function()
    local possibleFolders = {
        "__Enemies", "DungeonEnemies", "Mobs", "Enemies",
        "NPCs", "Monsters", "EnemyFolder", "MobFolder"
    }
    
    -- Procurar nas pastas conhecidas primeiro
    for _, folderName in ipairs(possibleFolders) do
        local folder = workspace:FindFirstChild(folderName)
        if folder and #folder:GetChildren() > 0 then
            print("üìÅ Pasta de mobs encontrada:", folderName)
            return folder
        end
    end
    
    -- Procurar em subpastas do workspace
    for _, child in pairs(workspace:GetChildren()) do
        if (child:IsA("Folder") or child:IsA("Model")) and child.Name ~= "Camera" then
            local mobCount = 0
            for _, subchild in pairs(child:GetChildren()) do
                if subchild:IsA("Model") then
                    local humanoid = subchild:FindFirstChild("Humanoid")
                    if humanoid then
                        mobCount = mobCount + 1
                    end
                end
            end
            
            if mobCount >= 3 then -- Se tem 3+ mobs, provavelmente √© a pasta certa
                print("üìÅ Pasta de mobs encontrada por contagem:", child.Name, "- Mobs:", mobCount)
                return child
            end
        end
    end
    
    print("‚ùå Nenhuma pasta de mobs encontrada")
    return nil
end

-- ===== Contar mobs vivos =====
local contarMobsVivos = function()
    local folder = encontrarPastaMobs()
    if not folder then return 0, {} end
    
    local count = 0
    local mobList = {}
    
    for _, mob in pairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 and humanoid.MaxHealth > 0 then
                count = count + 1
                table.insert(mobList, {
                    name = mob.Name,
                    health = math.floor(humanoid.Health),
                    maxHealth = math.floor(humanoid.MaxHealth),
                    model = mob
                })
            end
        end
    end
    
    return count, mobList
end

-- ===== Teleporte seguro =====
local teleportToNearestMob = function()
    local character = player.Character
    if not character then 
        print("‚ùå Character n√£o encontrado")
        return false 
    end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then 
        print("‚ùå HumanoidRootPart n√£o encontrado")
        return false 
    end
    
    local count, mobList = contarMobsVivos()
    if count == 0 then 
        print("‚ùå Nenhum mob vivo para teleportar")
        return false 
    end
    
    -- Encontrar o mob mais pr√≥ximo
    local closest = nil
    local bestDistance = math.huge
    
    for _, mobInfo in pairs(mobList) do
        local mob = mobInfo.model
        local mobRoot = mob:FindFirstChild("HumanoidRootPart") or 
                       mob:FindFirstChild("Torso") or 
                       mob:FindFirstChild("Head")
        
        if mobRoot then
            local distance = (root.Position - mobRoot.Position).Magnitude
            if distance < bestDistance then
                bestDistance = distance
                closest = {root = mobRoot, info = mobInfo}
            end
        end
    end
    
    if closest then
        -- Teleporte seguro com verifica√ß√£o
        local targetPosition = closest.root.CFrame * CFrame.new(0, 0, 5)
        root.CFrame = targetPosition
        
        print("üìç Teleportado para:", closest.info.name, 
              "- HP:", closest.info.health .. "/" .. closest.info.maxHealth,
              "- Dist√¢ncia:", math.floor(bestDistance))
        return true
    end
    
    return false
end

-- ===== Sistema de ataque melhorado =====
local atacarMobs = function()
    local count, mobList = contarMobsVivos()
    if count == 0 then return 0 end
    
    local attacked = 0
    local remote = ReplicatedStorage:FindFirstChild("BridgeNet2")
    if remote then
        remote = remote:FindFirstChild("dataRemoteEvent")
    end
    
    if not remote then
        print("‚ùå Remote de ataque n√£o encontrado")
        return 0
    end
    
    for _, mobInfo in pairs(mobList) do
        local mobName = mobInfo.name
        
        -- M√∫ltiplos m√©todos de ataque
        local attackMethods = {
            { Event = "Attack", Enemy = mobName, AttackType = "All" },
            { Event = "Combat", Target = mobName, Action = "Attack" },
            { Event = "DungeonAttack", Enemy = mobName },
            { Event = "KillEnemy", Target = mobName },
            { Event = "AttackMob", Mob = mobName }
        }
        
        print("‚öîÔ∏è Atacando:", mobName, "- HP:", mobInfo.health .. "/" .. mobInfo.maxHealth)
        
        for _, attackData in ipairs(attackMethods) do
            local args = { { attackData, "\5" } }
            
            if safeFireServer(remote, unpack(args)) then
                task.wait(0.05)
            end
        end
        
        -- Tentar ClickDetector se existir
        local clickDetector = mobInfo.model:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            local success = pcall(function()
                fireclickdetector(clickDetector)
            end)
            if success then
                print("üñ±Ô∏è ClickDetector ativado para:", mobName)
            end
        end
        
        attacked = attacked + 1
        task.wait(0.1)
    end
    
    print("‚öîÔ∏è Total de ataques enviados:", attacked)
    return attacked
end

-- ===== Fun√ß√£o de debug =====
local debugDungeon = function()
    print("\nüîç === DEBUG DUNGEON COMPLETO ===")
    print("üè∞ Em dungeon:", isInDungeon())
    
    local count, mobList = contarMobsVivos()
    print("üëπ Mobs vivos:", count)
    
    if count > 0 then
        print("üìã Lista de mobs:")
        for i, mobInfo in ipairs(mobList) do
            print("  " .. i .. ".", mobInfo.name, "-", mobInfo.health .. "/" .. mobInfo.maxHealth .. " HP")
        end
    end
    
    -- Verificar pastas do workspace
    print("üìÅ Pastas do Workspace com modelos:")
    for _, child in pairs(workspace:GetChildren()) do
        if (child:IsA("Folder") or child:IsA("Model")) and child.Name ~= "Camera" then
            local modelCount = 0
            for _, subchild in pairs(child:GetChildren()) do
                if subchild:IsA("Model") then
                    modelCount = modelCount + 1
                end
            end
            if modelCount > 0 then
                print("  üìÇ", child.Name, "- Modelos:", modelCount)
            end
        end
    end
    
    -- Verificar remote
    local remote = ReplicatedStorage:FindFirstChild("BridgeNet2")
    if remote then
        remote = remote:FindFirstChild("dataRemoteEvent")
        print("üîó Remote encontrado:", remote and "‚úÖ" or "‚ùå")
    else
        print("üîó BridgeNet2 n√£o encontrado")
    end
    
    print("üîç === FIM DEBUG ===\n")
end

-- ===== Fun√ß√£o principal de combate =====
local solarDungeon = function()
    print("üåü === INICIANDO COMBATE NA DUNGEON ===")
    
    -- Verificar se est√° na dungeon
    if not isInDungeon() then
        print("‚ùå N√£o parece estar em uma dungeon")
        debugDungeon()
        return false
    end
    
    -- Aguardar mobs aparecerem
    local waitTime = 0
    local maxWait = 30
    
    print("‚è≥ Aguardando mobs aparecerem...")
    while waitTime < maxWait do
        local count = contarMobsVivos()
        if count > 0 then
            print("‚úÖ Mobs detectados! Iniciando combate...")
            break
        end
        
        task.wait(1)
        waitTime = waitTime + 1
        
        if waitTime % 5 == 0 then
            print("‚è≥ Aguardando... (" .. (maxWait - waitTime) .. "s restantes)")
        end
    end
    
    local mobCount = contarMobsVivos()
    if mobCount == 0 then
        print("‚ùå Nenhum mob encontrado ap√≥s", maxWait, "segundos")
        debugDungeon()
        return false
    end
    
    -- Loop principal de combate
    local combatStart = tick()
    local maxCombatTime = 300 -- 5 minutos
    local lastMobCount = mobCount
    local stuckTimer = 0
    
    while combatStart + maxCombatTime > tick() do
        local currentMobCount = contarMobsVivos()
        
        if currentMobCount == 0 then
            print("üéâ Todos os mobs foram derrotados!")
            return true
        end
        
        print("üîÑ Ciclo de combate - Mobs restantes:", currentMobCount)
        
        -- Teleportar e atacar
        if teleportToNearestMob() then
            task.wait(0.5)
            atacarMobs()
        end
        
        -- Verificar se est√° travado
        if currentMobCount == lastMobCount then
            stuckTimer = stuckTimer + 1
            if stuckTimer >= 10 then
                print("‚ö†Ô∏è Poss√≠vel travamento - fazendo debug...")
                debugDungeon()
                stuckTimer = 0
            end
        else
            stuckTimer = 0
        end
        
        lastMobCount = currentMobCount
        task.wait(2)
    end
    
    print("‚è∞ Timeout no combate ap√≥s", math.floor(maxCombatTime/60), "minutos")
    return false
end

-- ===== Interface de controle =====
-- Assumindo que 't' √© sua aba da GUI
if t then
    t:AddButton({
        Title = "üîç Debug Dungeon",
        Description = "Mostrar informa√ß√µes detalhadas",
        Callback = function()
            debugDungeon()
        end
    })

    t:AddButton({
        Title = "‚öîÔ∏è Combate Manual",
        Description = "Executar combate uma vez",
        Callback = function()
            task.spawn(solarDungeon)
        end
    })

    t:AddButton({
        Title = "üìç Teleportar para Mob",
        Description = "Teleportar para o mob mais pr√≥ximo",
        Callback = function()
            teleportToNearestMob()
        end
    })

    t:AddButton({
        Title = "üëÄ Contar Mobs",
        Description = "Mostrar quantos mobs est√£o vivos",
        Callback = function()
            local count, mobList = contarMobsVivos()
            print("üëπ Mobs vivos:", count)
            for _, mobInfo in ipairs(mobList) do
                print("  -", mobInfo.name, "(" .. mobInfo.health .. "/" .. mobInfo.maxHealth .. " HP)")
            end
        end
    })
end

print("‚úÖ Script de dungeon carregado com sucesso!")

-- ===== Auto-executar se detectar dungeon =====
task.spawn(function()
    if isInDungeon() then
        print("üè∞ Dungeon detectada automaticamente!")
        task.wait(2)
        solarDungeon()
    end
end)