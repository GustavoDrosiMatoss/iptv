local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local ativarAutoFly  = false
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== FUN√á√ÉO DE AUTO FARM COM VOO (MODIFICADA PARA SER MAIS FLEX√çVEL) =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- << MODIFICADO >>: Esta agora √© a pasta padr√£o, mas podemos usar outras.
local defaultEnemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies")

local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil
local autoFlyRunning = false
local autoFlyCoroutine = nil

local FLIGHT_SPEED = 500
local FLIGHT_HEIGHT = 5

local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function enableFlight()
    if flyConnection then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = true end
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    flyConnection = bodyVelocity
end

local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

local function flyToPosition(targetPosition)
    enableFlight()
    if currentTween then currentTween:Cancel(); currentTween = nil end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    return currentTween
end

-- << MODIFICADO >>: Agora aceita uma pasta de inimigos como argumento.
local function getClosestUnvisitedMob(enemiesFolder)
    if not enemiesFolder or not enemiesFolder:IsA("Folder") then
        print("Pasta de inimigos inv√°lida ou n√£o encontrada.")
        return nil
    end

    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            if mob and mob:IsA("BasePart") and mob.Parent then
                local dist = (hrp.Position - mob.Position).Magnitude
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    for _, mobData in pairs(allMobs) do
        if not isPositionVisited(mobData.mob.Position) then
            if mobData.distance < shortestDistance then
                shortestDistance = mobData.distance
                closestMob = mobData.mob
            end
        end
    end
    
    if not closestMob and #allMobs > 0 then
        visitedPositions = {} -- Limpa a lista se n√£o achar um n√£o visitado, para tentar de novo
        shortestDistance = allMobs[1].distance
        closestMob = allMobs[1].mob
    end
    
    return closestMob
end

-- << MODIFICADO >>: Passa a pasta para a fun√ß√£o getClosestUnvisitedMob.
local function flyToMobLoop(enemiesFolder)
    enableFlight()
    
    while autoFlyRunning do
        local mob = getClosestUnvisitedMob(enemiesFolder)
        
        if mob and mob.Parent then
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    addVisitedPosition(mob.Position)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end
            
            local flyTween = flyToPosition(mob.Position)
            local startTime = tick()
            local maxWaitTime = 10
            
            repeat
                task.wait(0.1)
                if not autoFlyRunning then break end
                local distance = (hrp.Position - mob.Position).Magnitude
                if distance < 15 or not mob.Parent then break end
            until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
            
            if currentTween then currentTween:Cancel(); currentTween = nil end
            
            task.wait(2) -- Tempo para seu personagem atacar o mob
            addVisitedPosition(mob.Position)
        else
            -- Se n√£o encontrar mais mobs, para o loop para que a dungeon possa ser resetada.
            print("Nenhum mob encontrado na pasta especificada. Parando o voo.")
            autoFlyRunning = false -- Para o loop while
            break
        end
        
        if autoFlyRunning then
            task.wait(0.5)
        end
    end
    -- Ao sair do loop, garante que o voo seja desativado
    disableFlight()
end

-- << MODIFICADO >>: Aceita um argumento para a pasta de inimigos.
local function startAutoFly(targetFolder)
    if autoFlyRunning then return end
    
    local folderToScan = targetFolder or defaultEnemiesFolder
    print("Iniciando voo autom√°tico para mobs na pasta:", folderToScan.Name)
    autoFlyRunning = true
    
    autoFlyCoroutine = coroutine.create(function()
        pcall(flyToMobLoop, folderToScan)
        -- Quando o loop termina, chama stopAutoFly para garantir a limpeza
        stopAutoFly()
    end)
    
    coroutine.resume(autoFlyCoroutine)
end

local function stopAutoFly()
    if not autoFlyRunning and not flyConnection then return end -- Evita prints desnecess√°rios
    autoFlyRunning = false
    if currentTween then currentTween:Cancel(); currentTween = nil end
    disableFlight()
    visitedPositions = {}
    currentTarget = nil
    stuckCounter = 0
    print("Script de voo autom√°tico parado!")
end

-- ===== FIM DA FUN√á√ÉO DE AUTO FARM COM VOO =====

local function safeDelete(path)
    if isfile and isfile(path) then
        pcall(function() writefile(path, "") end)
    end
end

local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        autofly = ativarAutoFly, dungeonActive = dungeonActive
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local success, data = pcall(function() return HttpService:JSONDecode(readfile(configFile)) end)
        if success and type(data) == "table" then
            andarEntrada  = tonumber(data.entrada) or andarEntrada
            andarSaida    = tonumber(data.saida) or andarSaida
            ativarEvento  = data.evento or false
            ativarDungeon = data.dungeon or false
            ativarGems    = data.gems or false
            ativarAutoFly = data.autofly or false
            dungeonActive = data.dungeonActive or false
        end
    else
        salvarConfig()
    end
end
carregarConfig()

local isInDungeon = function()
    return workspace:FindFirstChild("__Enemies") ~= nil or workspace:FindFirstChild("Dungeon") ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true -- Se encontrar pelo menos um vivo, j√° retorna
            end
        end
    end
    return false
end

local entrarCastelo = function()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join"}, [2] = "\12"})
end

local sairCastelo = function()
    print("üö™ Saindo do castelo")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon"}, [2] = "\12"})
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local iniciarDungeon = function()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Start"}, [2] = "\12"})
end

local criarDungeon = function()
    if dungeonActive or isInDungeon() then return end
    print("üÜï Criando nova dungeon...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Event = "DungeonAction", Action = "Create"}, [2] = "\12"})
    dungeonActive = true
    salvarConfig()
    task.wait(5)
    iniciarDungeon()
end

local resetarDungeon = function()
    print("üíé Resetando dungeon com gems...")
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer({[1] = {Type = "Gems", Event = "DungeonAction", Action = "BuyTicket"}, [2] = "\12"})
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local function verificarEresetarSeNecessario()
    print("üîé Verificando se a dungeon foi conclu√≠da...")
    task.wait(3)
    if not mobsVivos() then
        print("‚úÖ Dungeon limpa! Iniciando o processo de reset.")
        if ativarGems then
            resetarDungeon()
        else
            sairCastelo()
            task.wait(5)
            if ativarEvento then entrarCastelo() end
        end
        task.wait(3)
        return true
    else
        print("‚ö†Ô∏è Ainda existem mobs vivos.")
        return false
    end
end

-- << NOVA FUN√á√ÉO >>: Substitui a antiga 'solarDungeon'
local function solarDungeonComVoo()
    print("üåü Iniciando limpeza da dungeon com Auto Voo...")
    local dungeonEnemiesFolder = workspace:FindFirstChild("__Enemies")
    
    if not dungeonEnemiesFolder then
        print("‚ùå Pasta de inimigos da dungeon n√£o encontrada.")
        return
    end
    
    -- Inicia o voo focado apenas na pasta da dungeon
    startAutoFly(dungeonEnemiesFolder)
    
    local startTime = tick()
    -- Espera at√© que o voo pare (por n√£o achar mobs) ou d√™ timeout
    while autoFlyRunning and (tick() - startTime < 300) and ativarDungeon do
        print("‚úàÔ∏è Limpando dungeon... Aguardando Auto Voo terminar.")
        task.wait(2)
    end
    
    -- Garante que o voo seja parado ao final
    stopAutoFly()
    
    if tick() - startTime >= 300 then
        print("‚è∞ Timeout na limpeza da dungeon.")
    else
        print("üéâ Auto Voo concluiu a limpeza da dungeon!")
    end
end


-- << MODIFICADO >>: O loop principal agora usa a nova fun√ß√£o de combate com voo.
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5)
        
        if not isInDungeon() and not dungeonActive then
            print("üèóÔ∏è Preparando para criar dungeon...")
            if ativarEvento then entrarCastelo(); task.wait(5) end
            criarDungeon()
            task.wait(8)
        end

        if isInDungeon() then
            print("üéÆ Executando dungeon com Auto Voo...")
            -- Chama a nova fun√ß√£o que usa o voo para limpar
            solarDungeonComVoo()
            
            -- Ap√≥s a tentativa de limpeza, verifica e reseta
            verificarEresetarSeNecessario()
        end
    end
    print("üõë Loop de auto dungeon parado")
end

-- ===== GUI (Inalterada) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED)",
    SubTitle = "Dungeon com Auto Voo + Farm Voador",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })
local autoFarmTab = Window:AddTab({ Title = "Auto Farm", Icon = "zap" })
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({Title = "Status Atual",Content = "Aguardando..."})

local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
‚úàÔ∏è Auto Farm Voador: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå",
        autoFlyRunning and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

task.spawn(function()
    while true do
        pcall(updateStatus)
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Usa o Auto Voo para limpar a dungeon",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

autoFarmTab:AddToggle("ToggleAutoFly", {
    Title = "Auto Farm Voador (Mundo Aberto)",
    Description = "Ativa/Desativa o farm no mundo principal",
    Default = ativarAutoFly,
    Callback = function(state)
        ativarAutoFly = state
        salvarConfig()
        if state then
            startAutoFly() -- Chama sem argumento para usar a pasta padr√£o
        else
            stopAutoFly()
        end
    end
})

autoFarmTab:AddParagraph({
    Title = "Informa√ß√µes do Auto Farm",
    Content = "O Auto Farm Voador ir√° voar automaticamente at√© os mobs. Use o toggle 'Auto Dungeon' na outra aba para farmar dungeons, e este para farmar no mundo aberto."
})

t:AddButton({
    Title = "üîÑ Reset Dungeon Status",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("üîÑ Status da dungeon resetado!")
    end
})

local floatingGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
floatingGui.Name = "AllanHubFloating"; floatingGui.ResetOnSpawn = false
local toggleButton = Instance.new("TextButton", floatingGui)
toggleButton.Size = UDim2.new(0, 50, 0, 50); toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100); toggleButton.Text = "‚öô"; toggleButton.TextScaled = true
toggleButton.Active = true; toggleButton.Draggable = true
local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    Window.Frame.Visible = hubVisivel
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end
if ativarAutoFly then startAutoFly() end

print("‚úÖ Allan Hub carregado com sistema de Dungeon por Auto Voo!")
_G.stopAutoFly = stopAutoFly
