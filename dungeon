local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local ativarAutoFly  = false  -- Nova flag para auto voo
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false  -- Nova flag para controle

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Salvar/Carregar (incluindo flag dungeon e auto fly) =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        autoFly = ativarAutoFly,  -- Salvar estado do auto fly
        dungeonActive = dungeonActive  -- Salvar estado da dungeon
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
        ativarAutoFly = data.autoFly or false  -- Carregar estado do auto fly
        dungeonActive = data.dungeonActive or false  -- Carregar estado
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Verifica√ß√µes melhoradas =====
local isInDungeon = function()
    local enemies = workspace:FindFirstChild("__Enemies")
    local dungeonFolder = workspace:FindFirstChild("Dungeon") -- Adicionar outras verifica√ß√µes se necess√°rio
    return enemies ~= nil or dungeonFolder ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    local count = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                count = count + 1
            end
        end
    end
    print("üéØ Mobs vivos encontrados:", count)
    return count > 0
end

-- ===== A√ß√µes corrigidas =====
local entrarCastelo = function()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local sairCastelo = function()
    print("üö™ Saindo do castelo")
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local iniciarDungeon = function()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local criarDungeon = function()
    if dungeonActive then 
        print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o")
        return 
    end
    
    if isInDungeon() then 
        print("‚ö†Ô∏è J√° est√° em uma dungeon")
        dungeonActive = true
        salvarConfig()
        return 
    end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5) -- Esperar mais tempo para criar
    iniciarDungeon()
end

local resetarDungeon = function()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

-- ===== Fun√ß√£o de Voo Integrada =====
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies")

local visitedPositions = {}
local currentTarget = nil
local stuckCounter = 0
local flyConnection = nil
local currentTween = nil

-- Configura√ß√µes de voo
local FLIGHT_SPEED = 500 -- Velocidade de voo
local FLIGHT_HEIGHT = 5 -- Altura acima do mob

-- Fun√ß√£o para verificar se uma posi√ß√£o j√° foi visitada recentemente
local function isPositionVisited(position)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

-- Fun√ß√£o para adicionar posi√ß√£o √† lista de visitadas
local function addVisitedPosition(position)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

-- Fun√ß√£o para ativar o voo
local function enableFlight()
    if flyConnection then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    flyConnection = bodyVelocity
end

-- Fun√ß√£o para desativar o voo
local function disableFlight()
    if flyConnection then
        flyConnection:Destroy()
        flyConnection = nil
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

-- Fun√ß√£o para voar at√© uma posi√ß√£o usando Tween
local function flyToPosition(targetPosition)
    enableFlight()
    
    -- Para o tween anterior se existir
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    -- Cria o tween de movimento
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut,
        0,
        false,
        0
    )
    
    currentTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    currentTween:Play()
    
    print("Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    
    return currentTween
end

local function getClosestUnvisitedMob()
    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder and mobFolder.Parent then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart") or mobFolder:FindFirstChildWhichIsA("BasePart", true)
            
            if mob and mob:IsA("BasePart") and mob.Parent then
                local dist = (hrp.Position - mob.Position).Magnitude
                
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChildOfClass("Humanoid")
                    local isAlive = true
                    
                    if humanoid then
                        isAlive = humanoid.Health > 0
                    end
                    
                    if isAlive then
                        table.insert(allMobs, {mob = mob, folder = mobFolder, distance = dist})
                    end
                end
            end
        end
    end
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        local mob = mobData.mob
        if not isPositionVisited(mob.Position) then
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    -- Se n√£o encontrar mobs n√£o visitados, limpa a lista e pega qualquer um
    if not closestMob and #allMobs > 0 then
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            local mob = mobData.mob
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    print("Mobs encontrados no alcance:", #allMobs, "| Dist√¢ncia do mais pr√≥ximo:", math.floor(shortestDistance))
    return closestMob
end

-- Loop de voo autom√°tico com verifica√ß√£o de mobs e recria√ß√£o de dungeon
local function flyToMobLoop()
    enableFlight()
    
    while ativarAutoFly do
        local mob = getClosestUnvisitedMob()
        
        if mob and mob.Parent then
            -- Verifica se √© o mesmo alvo da vez anterior
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    print("Parece que estou preso no mesmo mob, marcando como visitado...")
                    addVisitedPosition(mob.Position)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end
            
            -- Voa at√© o mob
            local flyTween = flyToPosition(mob.Position)
            
            -- Espera o voo completar ou um tempo m√°ximo
            local startTime = tick()
            local maxWaitTime = 10 -- M√°ximo 10 segundos para chegar ao mob
            
            repeat
                task.wait(0.1)
                local distance = (hrp.Position - mob.Position).Magnitude
                
                -- Se chegou perto o suficiente, para o tween
                if distance < 15 then
                    break
                end
                
                -- Se o mob morreu ou sumiu, para o tween
                if not mob.Parent then
                    break
                end
                
            until (tick() - startTime) > maxWaitTime or flyTween.PlaybackState == Enum.PlaybackState.Completed
            
            -- Para o tween se ainda estiver rodando
            if currentTween then
                currentTween:Cancel()
                currentTween = nil
            end
            
            print("Chegou pr√≥ximo ao mob!")
            
            -- Aguarda um pouco no mob antes de marcar como visitado
            task.wait(2)
            addVisitedPosition(mob.Position)
            
        else
            print("Nenhum mob encontrado! Verificando se precisa recriar dungeon...")
            visitedPositions = {}
            currentTarget = nil
            stuckCounter = 0
            if isInDungeon() and not mobsVivos() then
                -- Sem mobs vivos, recria a dungeon
                print("Recriando dungeon automaticamente...")
                if ativarGems then
                    resetarDungeon()
                    task.wait(5)
                else
                    sairCastelo()
                    task.wait(5)
                    if ativarEvento then entrarCastelo() end
                    task.wait(3)
                end
                criarDungeon()
            end
            task.wait(2)
        end
        
        task.wait(0.5)
    end
    
    disableFlight()
    print("Loop de voo autom√°tico parado!")
end

-- Fun√ß√£o para parar o voo
local function stopAutoFly()
    ativarAutoFly = false
    salvarConfig()
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    disableFlight()
    print("Script de voo autom√°tico parado!")
end

-- ===== Combate melhorado (integrado com voo se ativado) =====
local teleportToNearestMob = function()
    local char = player.Character
    if not char then return false end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end

    local closest, bestDistance = nil, math.huge
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            local hrp = mob:FindFirstChild("HumanoidRootPart")
            if humanoid and hrp and humanoid.Health > 0 then
                local distance = (root.Position - hrp.Position).Magnitude
                if distance < bestDistance then
                    bestDistance = distance
                    closest = hrp
                end
            end
        end
    end
    
    if closest then
        root.CFrame = closest.CFrame * CFrame.new(0, 0, 5)
        print("üìç Teleportado para mob mais pr√≥ximo")
        return true
    end
    return false
end

local atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    print("‚öîÔ∏è Atacou", attacked, "inimigos")
    return attacked
end

-- ===== Fun√ß√£o principal corrigida (usa voo se ativado) =====
local solarDungeon = function()
    print("üåü Iniciando combate na dungeon...")
    
    -- Esperar mobs aparecerem (at√© 30 segundos)
    local waitStart = tick()
    while tick() - waitStart < 30 do
        if mobsVivos() then
            print("‚úÖ Mobs detectados, iniciando combate!")
            break
        end
        print("‚è≥ Aguardando mobs aparecerem...")
        task.wait(2)
    end
    
    if not mobsVivos() then
        print("‚ùå Nenhum mob encontrado ap√≥s 30 segundos")
        return
    end

    -- Loop de combate
    local combatStart = tick()
    while mobsVivos() and tick() - combatStart < 300 do -- M√°ximo 5 minutos
        if ativarAutoFly then
            -- Usa o loop de voo se ativado
            local mob = getClosestUnvisitedMob()
            if mob then
                flyToPosition(mob.Position)
            end
        else
            teleportToNearestMob()
        end
        task.wait(0.5)
        atacarInimigos()
        task.wait(1)
    end
    
    if mobsVivos() then
        print("‚è∞ Timeout no combate ap√≥s 5 minutos")
    else
        print("üéâ Todos os mobs foram derrotados!")
    end
end

-- ===== Loop principal corrigido =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5) -- Espera maior entre ciclos
        
        if not isInDungeon() and not dungeonActive then
            print("üèóÔ∏è Preparando para criar dungeon...")
            
            if ativarEvento then 
                entrarCastelo()
                task.wait(5) 
            end
            
            criarDungeon()
            task.wait(8) -- Mais tempo para processar
        end

        if isInDungeon() then
            print("üéÆ Executando dungeon...")
            solarDungeon()
            task.wait(3)
            
            if ativarGems then
                resetarDungeon()
                task.wait(5)
            else
                sairCastelo()
                task.wait(5)
                if ativarEvento then entrarCastelo() end
                task.wait(3)
            end
        end
    end
    
    print("üõë Loop de auto dungeon parado")
end

-- ===== GUI (com novo toggle para auto fly) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED)",
    SubTitle = "Dungeon Autom√°tica Corrigida",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

-- Status Tab
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

-- Fun√ß√£o para atualizar status
local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
‚úàÔ∏è Auto Fly: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå",
        ativarAutoFly and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

-- Atualizar status a cada 2 segundos
task.spawn(function()
    while true do
        updateStatus()
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(and The user has a script for a Roblox game, likely "Arise" or something similar, involving dungeon automation in a castle. They want to add a flying function to mobs, which they've provided code for.

Key requests:

1. Add the flying function to the script.

2. Add a button to toggle the flying to mobs on/off.

3. Using this flying function that identifies mobs, check if there are living mobs in the dungeon, and if not, recreate the dungeon.

The script is in Lua for Roblox, using Fluent UI for the GUI.

First, integrate the provided flying code into the main script.

The flying code has:

- Functions to enable/disable flight.

- Fly to position using Tween.

- Get closest unvisited mob.

- Loop to fly to mobs.

It targets mobs in workspace:WaitForChild("__Main"):WaitForChild("__Enemies")

But in the original script, enemies are in workspace:FindFirstChild("__Enemies")

There's a discrepancy: original uses "__Enemies", flying code uses "__Main/__Enemies".

I need to adjust to match the original: workspace.__Enemies

The original has functions like mobsVivos() which checks workspace.__Enemies for living mobs.

The flying code should integrate with that.

Add a toggle button in the GUI for "Auto Fly to Mobs".

When toggled on, start the flyToMobLoop().

When off, call stopScript().

In the loop or somewhere, check if no mobs are found, and if in dungeon, recreate it.

The request: "using this flying function that identifies mobs she verifies if there are living mobs in the dungeon and if not recreates the dungeon"

In the flyToMobLoop(), when no mob is found (else branch), and if isInDungeon(), then recreate the dungeon.

But recreate means? Probably reset or exit and create new.

Looking at original: if no mobs, it already has logic in solarDungeon() to detect no mobs and finish.

But since we're adding flying, perhaps replace or enhance the combat part.

In original, solarDungeon() has:

- Wait for mobs

- Then loop: teleportToNearestMob(), attack, wait.

They want to replace the teleport with flying.

And instead of teleport, use the flying tween.

Also, in the loop, if no mobs, proceed to reset or exit.

To integrate:

- Add a variable like ativarFly = false

- Save/load it in config.

- Add toggle in GUI.

- In solarDungeon(), instead of teleportToNearestMob(), if ativarFly, use the flying logic.

But the flying is a loop that continuously finds and flies to next mob.

Perhaps modify solarDungeon() to use the flying instead of instant teleport.

But the flying code has its own loop.

Perhaps make the flyToMobLoop() part of the combat, and in it, when no mobs, trigger the next step.

Since it's auto dungeon, perhaps when no mobs, call the reset or exit.

Let's plan:

- Add global ativarFly = false, save/load.

- Add toggle in GUI.

- When toggle on, start task.spawn(flyToMobLoop)

- In flyToMobLoop, in the else branch (no mob found):

  if isInDungeon() then

    -- No mobs, so finish dungeon

    if ativarGems then

      resetarDungeon()

    else

      sairCastelo()

      if ativarEvento then entrarCastelo() end

    end

  end

But need to wait a bit or confirm.

Also, in the loop, when flying to mob, perhaps attack when close.

The original attacks all mobs at once in atacarInimigos().

The flying code just flies to each mob, waits 2 seconds, marks visited.

But doesn't attack.

I need to add attack when close to mob.

In the repeat loop, after arriving, before adding visited, call atacarInimigos() or attack that mob.

Since attack is "All", perhaps call atacarInimigos() after arriving.

But to integrate properly.

Perhaps replace the teleportToNearestMob() with flyToNearestMob().

Make a function flyToNearestMob() similar to teleport, but using the tween.

And use the getClosestUnvisitedMob() logic.

The flying code has visited to avoid revisiting.

In dungeon, probably need to visit each mob if needed, but since attack is "All", maybe fly to one, attack all.

Perhaps simplest: in solarDungeon(), replace teleportToNearestMob() with a flyToNearestMob() that uses tween to closest mob.

And in the loop, while mobsVivos().

No need for visited if attack kills all.

But if mobs are spread out, maybe need to fly around.

The flying code seems designed to patrol all mobs.

For the game, since attack "All", probably flying to one is enough, and attack kills all?

I don't know the game mechanics.

Assuming attack "All" attacks all enemies, then flying to any one is sufficient.

But the original teleports to nearest, attacks all.

So, replace teleport with fly.

Modify teleportToNearestMob to flyToNearestMob.

Copy the logic.

First, fix the folder: use workspace.__Enemies

In flying code, change to local enemiesFolder = workspace:WaitForChild("__Enemies")

Yes.

For getClosestUnvisitedMob, but if not needed unvisited, simplify to getClosestMob().

Since if attack all, no need to visit multiple.

But perhaps mobs are in different rooms, need to go to each group.

But to match original, just fly to nearest each time.

In loop: fly to nearest, attack all, wait, repeat until no mobs.

Yes.

If during loop no closest mob, exit.

Also, add the button to toggle ativarFly, which switches between teleport or fly.

If ativarFly, use flyToNearestMob else teleportToNearestMob.

Yes.

For the check: already in mobsVivos() and while loop.

For recreate: when no mobs, it exits the loop, then in autoDungeonLoop, after solarDungeon(), it resets or exits.

Yes, already handles.

The request: "she verifies if there are living mobs in the dungeon and if not recreates the dungeon"

But in the loop, when no mobs, it recreates via reset or exit and create new.

Yes.

With flying, same.

I think integrating by replacing teleport with fly if toggle on.

Also, need to add enableFlight at start of combat, disable at end.

Since tween moves the hrp.

Now, to code.

First, insert the flying code parts into the main script.

Add variables, functions.

Correct the folder.

Remove the __Main.

Add ativarFly = false

In load/save.

Add toggle in GUI.

In solarDungeon(), before loop:

if ativarFly then enableFlight() end

In the loop:

if ativarFly then

  flyToNearestMob()

else

  teleportToNearestMob()

end

Then after loop:

if ativarFly then disableFlight() end

Define flyToNearestMob():

Similar to teleport, but use flyToPosition(closest.Position)

Wait for tween complete or distance <15

Something like.

Also, remove the loop from flying code, since we have the combat loop.

The provided flying is a loop to continuously fly to next unvisited.

For dungeon, perhaps use that loop instead of solarDungeon loop.

Replace the while in solarDungeon with the flyToMobLoop logic, but stop when no mobs.

The flyToMobLoop is infinite.

Perhaps modify solarDungeon to:

Wait for mobs.

Then enableFlight()

Then while mobsVivos() do

  local mob = getClosestUnvisitedMob()

  if mob then

    flyToPosition(mob.Position)

    -- wait for arrive

    atacarInimigos()

    task.wait(1)

    addVisitedPosition(mob.Position)

  else

    break

  end

end

disableFlight()

Yes, that way it flies to each unvisited mob, attacks all when close.

If mobs are grouped, might not need to visit all, but if needed, it will.

If attack all kills all at once, it will do one fly, attack, done.

If not, it will continue to next.

Perfect.

In getClosestUnvisitedMob, if no unvisited, it clears visited and picks closest.

Good.

For the recreate: already handled after solarDungeon().

I think this satisfies.

Also, the button is to activate the flying function, so ativarFly toggle, and when on, use flying in combat, else teleport.

Yes.

Add to status: Auto Fly: ‚úÖ or ‚ùå

Now, to implement.

The script uses task.wait, print, etc.

Need to be careful with integration.

The flying code has stuckCounter, etc.

I'll keep it.

In my modified, I'll include it in the loop.

No, in solarDungeon, it's while mobsVivos(), but inside, if mob, fly, attack.

But if stuck, the stuck logic is for same target.

Perhaps add the stuck logic.

But for simplicity, since attack all, perhaps no need for unvisited.

Let's see.

To minimize changes, I'll make flyToNearestMob() using the getClosestUnvisitedMob(), with visited, stuck, etc.

But it's a bit much.

Since the user provided the code, perhaps add it as is, add toggle to start/stop the loop.

Then, in the else of flyToMobLoop, if no mob and isInDungeon and ativarDungeon, then

if ativarGems then resetarDungeon() else sairCastelo() if ativarEvento then entrarCastelo() end end

Then task.wait(5)

Then, the loop will continue, and since out of dungeon, it won't trigger until new.

But the loop is while true, so it will keep checking.

But when autoDungeon is on, it has its own loop.

Might conflict.

If autoDungeon on, it creates, starts, then solarDungeon which would be replaced by starting the fly loop.

But the fly loop is infinite, so need to start it in solarDungeon, and stop when no mobs.

But the provided code has infinite loop, and when no mob, wait 2.

To adapt, perhaps start the fly loop in solarDungeon, but modify the loop to break when no mobs and confirmed.

The request is to add the function, add button to activate, and when no mobs, recreate.

So, perhaps the flying is separate from the auto dungeon.

But the script is for auto dungeon.

The user says "Adicion nela a funa de voar at√© os mobs" "add to it the function to fly to the mobs"

"And want a button to activate the function fly to mobs"

"And using this function of fly that identifies the mobs it verifies if has living mobs in the dungeon and if not recreate the dungeon"

So, add the code, add button to toggle the fly loop on/off.

And in the fly loop, in the else (no mob), if isInDungeon(), then recreate (which is reset if gems, or exit and create).

But since recreate would exit dungeon, and the loop continues, when out, it won't find mobs, but will keep printing no mob.

But if autoDungeon is on, the auto loop will create new when not in dungeon.

To avoid conflict, perhaps when toggle fly on, it uses fly for combat, but keep the structure.

I think integrating into solarDungeon is better.

Let me do that.

I'll define the flying functions.

Then in solarDungeon:

- Wait for mobs

- if not, return

- enableFlight() if ativarFly

- local combatStart = tick()

- while mobsVivos() and tick() - combatStart < 300 do

  local mob = getClosestUnvisitedMob()

  if mob then

    -- stuck logic

    if currentTarget == mob then

      stuckCounter = stuckCounter +1

      if stuck >3 then

        addVisitedPosition(mob.Position)

        stuckCounter = 0

        currentTarget = nil

        task.wait(1)

        continue

      end

    else

      stuckCounter =0

      currentTarget = mob

    end

    -- fly

    local flyTween = flyToPosition(mob.Position)

    -- wait

    local startTime = tick()

    repeat

      task.wait(0.1)

      local distance = (hrp.Position - mob.Position).Magnitude

      if distance <15 then break end

      if not mob.Parent then break end

    until (tick() - startTime) >10 or flyTween.PlaybackState == Enum.PlaybackState.Completed

    if currentTween then currentTween:Cancel() currentTween = nil end

    atacarInimigos()

    task.wait(1)

    addVisitedPosition(mob.Position)

  else

    print("No mob found in getClosest")

    break

  end

end

- disableFlight() if ativarFly

- if mobsVivos() then timeout else done

Yes, this is the fly loop adapted to the combat while.

When no mob from getClosest, break.

And since getClosest clears visited if no unvisited.

Perfect.

If not ativarFly, use the old loop with teleport.

No, the user wants to add the fly, so perhaps always use fly, but toggle to enable the fly mode vs teleport mode.

The button is to activate the function voar at√© os mobs, so probably the toggle chooses between teleport or fly.

I'll add if ativarFly then use the fly loop else use the old teleport loop.

In the solarDungeon, have two branches.

To save space, I can have:

local moveToMobFunction = ativarFly and flyToNearestMob or teleportToNearestMob

But for the fly, it's more involved with visited etc.

Since the fly is more advanced, perhaps make the loop the fly one if ativarFly, else the old one.

Yes.

So, in solarDungeon:

print("üåü Iniciando combate na dungeon...")

-- Esperar mobs...

if not mobsVivos() after wait, return

local combatStart = tick()

if ativarFly then

  enableFlight()

  visitedPositions = {} -- reset

  currentTarget = nil

  stuckCounter = 0

  while mobsVivos() and tick() - combatStart <300 do

    local mob = getClosestUnvisitedMob() -- this returns the BasePart

    if not mob then break end

    -- stuck

    if currentTarget and currentTarget == mob then

      stuckCounter = stuckCounter + 1

      if stuckCounter >3 then

        print("Preso, marcando visitado")

        addVisitedPosition(mob.Position)

        stuckCounter =0

        currentTarget = nil

        task.wait(1)

        continue

      end

    else

      stuckCounter =0

      currentTarget = mob

    end

    flyToPosition(mob.Position)

    local startTime = tick()

    repeat 

      task.wait(0.1)

      local dist = (hrp.Position - mob.Position).Magnitude

      if dist <15 then break end

      if not mob or not mob.Parent then break end

    until tick() - startTime >10

    if currentTween then currentTween:Cancel() currentTween = nil end

    print("Chegou ao mob")

    atacarInimigos()

    task.wait(0.5)

    addVisitedPosition(mob.Position)

  end

  disableFlight()

else

  -- old loop

  while mobsVivos() and tick() - combatStart <300 do

    teleportToNearestMob()

    task.wait(0.5)

    atacarInimigos()

    task.wait(1)

  end

end

-- then if mobsVivos() timeout else done

Yes.

For getClosestUnvisitedMob, adapt.

In the code, it returns the hrp or basepart.

But in original, mobs are models in __Enemies, with HumanoidRootPart.

In getClosest, find closest mob:FindFirstChild("HumanoidRootPart")

Yes.

Also, in flying code, it uses mobFolder:FindFirstChild("HumanoidRootPart") or FindFirstChildWhichIsA("BasePart", true)

But to match, use HumanoidRootPart.

Assume they have it.

Also, change enemiesFolder to workspace.__Enemies

workspace:WaitForChild("__Enemies")

Yes.

For allMobs, use mobFolder = mob (since children are the mob models)

Yes.

local folder = workspace:FindFirstChild("__Enemies")

Then for _, mob in pairs(folder:GetChildren())

Yes.

Fix that.

No __Main.

Also, maxDistance = 50000, seems large, ok.

In isAlive, if humanoid Health >0

Yes.

The function finds in __Enemies, perfect.

Add the functions: enableFlight, disableFlight, flyToPosition, isPositionVisited, addVisitedPosition, getClosestUnvisitedMob

Remove the flyToMobLoop and stopScript from the added code.

Since toggle will set ativarFly, and it's used in solarDungeon.

If autoDungeon on, it will use fly if toggle on.

No need for separate loop.

Perfect.

For the recreate, it's already done after the combat.

When combat ends (no mobs or timeout), it proceeds to reset.

Yes.

Add to GUI:

t:AddToggle("ToggleAutoFly", {

    Title = "Auto Fly to Mobs",

    Description = "Voa at√© os mobs em vez de teleportar",

    Default = ativarFly,

    Callback = function(state) ativarFly = state; salvarConfig() end

})

Yes.

Add to status:

Auto Fly: %s

ativarFly and "‚úÖ" or "‚ùå"

Yes.

Add to save/load:

ativarFly = data.fly or false

data.fly = ativarFly

Yes.

Declare local ativarFly = false at top.

Also, need to define the globals like visitedPositions = {}, currentTarget, stuckCounter, currentTween in the scope, but since used in function, define them inside solarDungeon or global.

Better define at top:

local visitedPositions = {}

etc.

But since only used when fly, but ok.

In solarDungeon, reset them when fly.

Yes, as I have.

For char, hrp: at top, but since script has player, add:

local char = player.Character or player.CharacterAdded:Wait()

local hrp = char:WaitForChild("HumanoidRootPart")

But if character respawns, may need to update.

For now, assume.

The flying code has that.

Ok.

I think this works.

Now, since no tools needed, just output the modified script.

The response should be the updated script.```lua
local ativarEvento   = false
local ativarDungeon  = false
local ativarGems     = false
local ativarFly      = false  -- Nova flag para voar
local andarEntrada   = 10
local andarSaida     = 1
local currentFloor   = 0
local configFile     = "allan_hub_castelo.json"
local tempFile       = "temp_dungeon.json"
local dungeonActive  = false  -- Nova flag para controle

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Configura√ß√µes de voo
local FLIGHT_SPEED = 500 -- Velocidade de voo
local FLIGHT_HEIGHT = 5 -- Altura acima do mob

-- ===== Compat de arquivos =====
local function safeDelete(path)
    if isfile and isfile(path) then
        if delfile then delfile(path)
        elseif deletefile then deletefile(path)
        else writefile(path, "") end
    end
end

-- ===== Salvar/Carregar (incluindo flag dungeon e fly) =====
local function salvarConfig()
    local data = {
        entrada = andarEntrada, saida = andarSaida,
        evento = ativarEvento, dungeon = ativarDungeon, gems = ativarGems,
        fly = ativarFly, dungeonActive = dungeonActive  -- Salvar estados
    }
    writefile(configFile, HttpService:JSONEncode(data))
end

local function carregarConfig()
    if isfile and isfile(configFile) then
        local data = HttpService:JSONDecode(readfile(configFile))
        andarEntrada  = tonumber(data.entrada) or andarEntrada
        andarSaida    = tonumber(data.saida) or andarSaida
        ativarEvento  = data.evento or false
        ativarDungeon = data.dungeon or false
        ativarGems    = data.gems or false
        ativarFly     = data.fly or false
        dungeonActive = data.dungeonActive or false  -- Carregar estado
    else
        salvarConfig()
    end
end
carregarConfig()

-- ===== Verifica√ß√µes melhoradas =====
local isInDungeon = function()
    local enemies = workspace:FindFirstChild("__Enemies")
    local dungeonFolder = workspace:FindFirstChild("Dungeon") -- Adicionar outras verifica√ß√µes se necess√°rio
    return enemies ~= nil or dungeonFolder ~= nil
end

local mobsVivos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end
    
    local count = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                count = count + 1
            end
        end
    end
    print("üéØ Mobs vivos encontrados:", count)
    return count > 0
end

-- ===== A√ß√µes corrigidas =====
local entrarCastelo = function()
    print("üè∞ Entrando no castelo - Andar:", andarEntrada)
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarEntrada), Event = "CastleAction", Action = "Join" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local sairCastelo = function()
    print("üö™ Saindo do castelo")
    local args = {
        [1] = { [1] = { Check = true, Floor = tostring(andarSaida), Event = "CastleAction", Action = "LeaveDungeon" }, [2] = "\12" }
    }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

local iniciarDungeon = function()
    print("‚ñ∂Ô∏è Iniciando dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Start" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
end

local criarDungeon = function()
    if dungeonActive then 
        print("‚ö†Ô∏è Dungeon j√° est√° ativa, pulando cria√ß√£o")
        return 
    end
    
    if isInDungeon() then 
        print("‚ö†Ô∏è J√° est√° em uma dungeon")
        dungeonActive = true
        salvarConfig()
        return 
    end
    
    print("üÜï Criando nova dungeon...")
    local args = { [1] = { [1] = { Event = "DungeonAction", Action = "Create" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    
    dungeonActive = true
    salvarConfig()
    writefile(tempFile, "1")
    
    task.wait(5) -- Esperar mais tempo para criar
    iniciarDungeon()
end

local resetarDungeon = function()
    print("üíé Resetando dungeon com gems...")
    local args = { [1] = { [1] = { Type = "Gems", Event = "DungeonAction", Action = "BuyTicket" }, [2] = "\12" } }
    game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    dungeonActive = false
    salvarConfig()
    safeDelete(tempFile)
end

-- ===== Fun√ß√µes de voo =====
local function enableFlight()
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
    return bodyVelocity
end

local function disableFlight(bodyVelocity)
    if bodyVelocity then
        bodyVelocity:Destroy()
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function flyToPosition(targetPosition, currentTween)
    -- Para o tween anterior se existir
    if currentTween then
        currentTween:Cancel()
    end
    
    local targetCFrame = CFrame.new(targetPosition + Vector3.new(0, FLIGHT_HEIGHT, 0))
    local distance = (hrp.Position - targetPosition).Magnitude
    local duration = distance / FLIGHT_SPEED
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut,
        0,
        false,
        0
    )
    
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    tween:Play()
    
    print("Voando para posi√ß√£o:", math.floor(targetPosition.X), math.floor(targetPosition.Y), math.floor(targetPosition.Z))
    
    return tween
end

local function isPositionVisited(position, visitedPositions)
    for _, visitedPos in pairs(visitedPositions) do
        if (position - visitedPos).Magnitude < 10 then
            return true
        end
    end
    return false
end

local function addVisitedPosition(position, visitedPositions)
    table.insert(visitedPositions, position)
    if #visitedPositions > 10 then
        table.remove(visitedPositions, 1)
    end
end

local function getClosestUnvisitedMob(visitedPositions, hrp)
    local closestMob = nil
    local shortestDistance = math.huge
    local allMobs = {}
    local maxDistance = 50000
    local enemiesFolder = workspace:FindFirstChild("__Enemies")
    if not enemiesFolder then return nil end
    
    for _, mobFolder in pairs(enemiesFolder:GetChildren()) do
        if mobFolder:IsA("Model") then
            local mob = mobFolder:FindFirstChild("HumanoidRootPart")
            if mob then
                local dist = (hrp.Position - mob.Position).Magnitude
                if dist <= maxDistance then
                    local humanoid = mobFolder:FindFirstChild("Humanoid")
                    local isAlive = humanoid and humanoid.Health > 0 or false
                    if isAlive then
                        table.insert(allMobs, {mob = mob, distance = dist})
                    end
                end
            end
        end
    end
    
    -- Procura por mobs n√£o visitados primeiro
    for _, mobData in pairs(allMobs) do
        local mob = mobData.mob
        if not isPositionVisited(mob.Position, visitedPositions) then
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mob
            end
        end
    end
    
    -- Se n√£o encontrar, limpa visitados e pega o mais pr√≥ximo
    if not closestMob and #allMobs > 0 then
        visitedPositions = {}
        for _, mobData in pairs(allMobs) do
            local dist = mobData.distance
            if dist < shortestDistance then
                shortestDistance = dist
                closestMob = mobData.mob
            end
        end
    end
    
    print("Mobs encontrados no alcance:", #allMobs, "| Dist√¢ncia do mais pr√≥ximo:", math.floor(shortestDistance))
    return closestMob
end

-- ===== Combate melhorado =====
local teleportToNearestMob = function()
    local char = player.Character
    if not char then return false end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return false end

    local closest, bestDistance = nil, math.huge
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            local hrp = mob:FindFirstChild("HumanoidRootPart")
            if humanoid and hrp and humanoid.Health > 0 then
                local distance = (root.Position - hrp.Position).Magnitude
                if distance < bestDistance then
                    bestDistance = distance
                    closest = hrp
                end
            end
        end
    end
    
    if closest then
        root.CFrame = closest.CFrame * CFrame.new(0, 0, 5)
        print("üìç Teleportado para mob mais pr√≥ximo")
        return true
    end
    return false
end

local atacarInimigos = function()
    local folder = workspace:FindFirstChild("__Enemies")
    if not folder then return 0 end
    
    local attacked = 0
    for _, mob in ipairs(folder:GetChildren()) do
        if mob:IsA("Model") then
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local args = { [1] = { [1] = { Event = "Attack", Enemy = mob.Name, AttackType = "All" }, [2] = "\5" } }
                game.ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                attacked = attacked + 1
                task.wait(0.1)
            end
        end
    end
    print("‚öîÔ∏è Atacou", attacked, "inimigos")
    return attacked
end

-- ===== Fun√ß√£o principal corrigida com voo integrado =====
local solarDungeon = function()
    print("üåü Iniciando combate na dungeon...")
    
    -- Esperar mobs aparecerem (at√© 30 segundos)
    local waitStart = tick()
    while tick() - waitStart < 30 do
        if mobsVivos() then
            print("‚úÖ Mobs detectados, iniciando combate!")
            break
        end
        print("‚è≥ Aguardando mobs aparecerem...")
        task.wait(2)
    end
    
    if not mobsVivos() then
        print("‚ùå Nenhum mob encontrado ap√≥s 30 segundos")
        return
    end

    -- Loop de combate
    local combatStart = tick()
    local bodyVelocity = nil
    local currentTween = nil
    local visitedPositions = {}
    local currentTarget = nil
    local stuckCounter = 0

    if ativarFly then
        bodyVelocity = enableFlight()
    end

    while mobsVivos() and tick() - combatStart < 300 do  -- M√°ximo 5 minutos
        if ativarFly then
            local mob = getClosestUnvisitedMob(visitedPositions, hrp)
            if not mob then
                print("‚ùå Nenhum mob n√£o visitado encontrado")
                break
            end

            -- L√≥gica de stuck
            if currentTarget and currentTarget == mob then
                stuckCounter = stuckCounter + 1
                if stuckCounter > 3 then
                    print("Parece que estou preso no mesmo mob, marcando como visitado...")
                    addVisitedPosition(mob.Position, visitedPositions)
                    stuckCounter = 0
                    currentTarget = nil
                    task.wait(1)
                    continue
                end
            else
                stuckCounter = 0
                currentTarget = mob
            end

            -- Voa at√© o mob
            currentTween = flyToPosition(mob.Position, currentTween)

            -- Espera chegar
            local startTime = tick()
            local maxWaitTime = 10
            repeat
                task.wait(0.1)
                if not mob or not mob.Parent then break end
                local distance = (hrp.Position - mob.Position).Magnitude
                if distance < 15 then break end
            until (tick() - startTime) > maxWaitTime

            if currentTween then
                currentTween:Cancel()
                currentTween = nil
            end

            print("Chegou pr√≥ximo ao mob!")

            atacarInimigos()
            task.wait(0.5)

            addVisitedPosition(mob.Position, visitedPositions)
        else
            teleportToNearestMob()
            task.wait(0.5)
            atacarInimigos()
            task.wait(1)
        end
    end
    
    if ativarFly then
        disableFlight(bodyVelocity)
    end

    if mobsVivos() then
        print("‚è∞ Timeout no combate ap√≥s 5 minutos")
    else
        print("üéâ Todos os mobs foram derrotados!")
    end
end

-- ===== Loop principal corrigido =====
local function autoDungeonLoop()
    print("üîÑ Iniciando loop de auto dungeon...")
    
    while ativarDungeon do
        task.wait(5) -- Espera maior entre ciclos
        
        if not isInDungeon() and not dungeonActive then
            print("üèóÔ∏è Preparando para criar dungeon...")
            
            if ativarEvento then 
                entrarCastelo()
                task.wait(5) 
            end
            
            criarDungeon()
            task.wait(8) -- Mais tempo para processar
        end

        if isInDungeon() then
            print("üéÆ Executando dungeon...")
            solarDungeon()
            task.wait(3)
            
            if ativarGems then
                resetarDungeon()
                task.wait(5)
            else
                sairCastelo()
                task.wait(5)
                if ativarEvento then entrarCastelo() end
                task.wait(3)
            end
        end
    end
    
    print("üõë Loop de auto dungeon parado")
end

-- ===== GUI (com novo toggle) =====
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Window = Fluent:CreateWindow({
    Title = "Allan Hub - Arise (FIXED)",
    SubTitle = "Dungeon Autom√°tica Corrigida",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.End
})

local t = Window:AddTab({ Title = "Auto Castelo", Icon = "home" })

-- Status Tab
local statusTab = Window:AddTab({ Title = "Status", Icon = "activity" })
local statusParagraph = statusTab:AddParagraph({
    Title = "Status Atual",
    Content = "Aguardando..."
})

-- Fun√ß√£o para atualizar status
local function updateStatus()
    local status = string.format([[
üè∞ Em Castelo: %s
‚öîÔ∏è Em Dungeon: %s  
üëπ Mobs Vivos: %s
üéØ Dungeon Ativa: %s
üîÑ Auto Dungeon: %s
‚úàÔ∏è Auto Fly: %s
]], 
        ativarEvento and "‚úÖ" or "‚ùå",
        isInDungeon() and "‚úÖ" or "‚ùå",
        mobsVivos() and "‚úÖ" or "‚ùå", 
        dungeonActive and "‚úÖ" or "‚ùå",
        ativarDungeon and "‚úÖ" or "‚ùå",
        ativarFly and "‚úÖ" or "‚ùå"
    )
    statusParagraph:SetDesc(status)
end

-- Atualizar status a cada 2 segundos
task.spawn(function()
    while true do
        updateStatus()
        task.wait(2)
    end
end)

local andaresEntrada = {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
local andaresSaida = {}
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada, Multi = false, Default = tostring(andarEntrada),
    Callback = function(v) andarEntrada = tonumber(v); salvarConfig() end
})

t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da", 
    Values = andaresSaida, Multi = false, Default = tostring(andarSaida),
    Callback = function(v) andarSaida = tonumber(v); salvarConfig() end
})

t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa/Desativa o Auto Castelo",
    Default = ativarEvento,
    Callback = function(state)
        ativarEvento = state; salvarConfig()
        if state then entrarCastelo() end
    end
})

t:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon", 
    Description = "Cria/Inicia/Reseta automaticamente",
    Default = ativarDungeon,
    Callback = function(state)
        ativarDungeon = state; salvarConfig()
        if state then 
            task.spawn(autoDungeonLoop)
        end
    end
})

t:AddToggle("ToggleUseGems", {
    Title = "Usar Gems para Reset",
    Description = "Compra ticket com gems para resetar", 
    Default = ativarGems,
    Callback = function(state) ativarGems = state; salvarConfig() end
})

t:AddToggle("ToggleAutoFly", {
    Title = "Auto Fly to Mobs",
    Description = "Voa at√© os mobs em vez de teleportar durante o combate",
    Default = ativarFly,
    Callback = function(state) ativarFly = state; salvarConfig() end
})

-- Bot√µes de controle manual
t:AddButton({
    Title = "üîÑ Reset Dungeon Status",
    Description = "Limpa flags de dungeon",
    Callback = function()
        dungeonActive = false
        salvarConfig()
        safeDelete(tempFile)
        print("üîÑ Status da dungeon resetado!")
    end
})

-- Bot√£o flutuante (mantido igual)
local floatingGui = Instance.new("ScreenGui")
floatingGui.Name = "AllanHubFloating"
floatingGui.Parent = player:WaitForChild("PlayerGui")
floatingGui.ResetOnSpawn = false

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(0, 20, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
toggleButton.Text = "‚öô"
toggleButton.TextScaled = true
toggleButton.Parent = floatingGui
toggleButton.Active = true
toggleButton.Draggable = true

local hubVisivel = true
toggleButton.MouseButton1Click:Connect(function()
    hubVisivel = not hubVisivel
    if Window and Window.Frame then
        Window.Frame.Visible = hubVisivel
    end
    toggleButton.BackgroundColor3 = hubVisivel and Color3.fromRGB(100,100,255) or Color3.fromRGB(255,100,100)
    toggleButton.Text = hubVisivel and "üîº" or "üîΩ"
end)

-- Watch do andar (mantido)
task.spawn(function()
    while task.wait(1) do
        if ativarEvento then
            local floorValue = player:FindFirstChild("CurrentFloor")
            if floorValue and tonumber(floorValue.Value) ~= currentFloor then
                currentFloor = tonumber(floorValue.Value)
                print("üè¢ Andar atual:", currentFloor)
                if currentFloor == andarSaida then sairCastelo() end
            end
        end
    end
end)

-- Autostart se estiver ativo no config
if ativarEvento then entrarCastelo() end
if ativarDungeon then task.spawn(autoDungeonLoop) end

print("‚úÖ Allan Hub carregado com corre√ß√µes!")