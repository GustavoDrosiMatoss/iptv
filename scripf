if not game or not game.GetService then
    warn("Ambiente do jogo n√£o est√° dispon√≠vel.")
    return
end
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local teleportEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local selectedMobName = ""
local movementMethod = "Tween" -- M√©todo de movimento padr√£o
local farmingStyle = "Default" -- Estilo de farm padr√£o

-- Novo sistema de armazenamento
local ConfigSystem = {}
local HttpService = game:GetService("HttpService")
ConfigSystem.Folder = "Allan Hub"
ConfigSystem.SubFolder = "AriseCrossover"
ConfigSystem.FileName = player.Name .. "_Config.json"
ConfigSystem.FilePath = ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder .. "/" .. ConfigSystem.FileName
ConfigSystem.DefaultConfig = {
    SelectedMobName = "",
    FarmSelectedMob = false,
    AutoFarmNearestNPCs = false,
    MainAutoDestroy = false,
    MainAutoArise = false,
    FarmingMethod = "Tween",
    DamageMobs = false,
    SelectedShop = "",
    SelectedWeapon = "",
    AutoBuyEnabled = false,
    AutoScanEnabled = false,
    ScanDelay = 1,
    SelectedRanks = {},
    AutoSellEnabled = false
}
ConfigSystem.CurrentConfig = {}

-- Fun√ß√£o para criar pastas se n√£o existirem
ConfigSystem.CreateFolders = function()
    -- Testar diferentes m√©todos para criar pasta em v√°rios executores
    local success = pcall(function()
        if makefolder then
            if not isfolder(ConfigSystem.Folder) then
                makefolder(ConfigSystem.Folder)
            end
            
            if not isfolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder) then
                makefolder(ConfigSystem.Folder .. "/" .. ConfigSystem.SubFolder)
            end
        end
    end)
    
    return success
end

-- Fun√ß√£o para salvar configura√ß√£o (th·ª≠ nhi·ªÅu ph∆∞∆°ng th·ª©c)
ConfigSystem.SaveConfig = function()
    -- Garantir que a pasta existe
    ConfigSystem.CreateFolders()
    
    -- M√£ h√≥a c·∫•u h√¨nh th√†nh chu·ªói JSON
    local jsonData = HttpService:JSONEncode(ConfigSystem.CurrentConfig)
    
    -- Testar diferentes m√©todos de salvar
    local success, err = pcall(function()
        -- M√©todo 1: writefile tr·ª±c ti·∫øp (Synapse X, KRNL, Script-Ware)
        if writefile then
            writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- M√©todo 2: Usar SaveInstance (alguns outros executores)
        if saveinstance then
            saveinstance(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- M√©todo 3: Fluxus v√† alguns outros executores
        if fluxus and fluxus.save_file then
            fluxus.save_file(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- M√©todo 4: Delta v√† alguns outros executores
        if delta_config and delta_config.save then
            delta_config.save(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        -- M√©todo 5: Codex
        if writefile and getrenv().writefile then
            getrenv().writefile(ConfigSystem.FilePath, jsonData)
            return true
        end
        
        return false
    end)
    
    if success then
        print("Configura√ß√£o salva com sucesso em: " .. ConfigSystem.FilePath)
        return true
    else
        warn("Falha ao salvar configura√ß√£o:", err)
        return false
    end
end

-- Fun√ß√£o para carregar configura√ß√£o (th·ª≠ nhi·ªÅu ph∆∞∆°ng th·ª©c)
ConfigSystem.LoadConfig = function()
    -- Th·ª≠ c√°c ph∆∞∆°ng th·ª©c ƒë·ªçc kh√°c nhau
    local success, content = pcall(function()
        -- M√©todo 1: readfile padr√£o (Synapse X, KRNL, Script-Ware)
        if readfile and isfile and isfile(ConfigSystem.FilePath) then
            return readfile(ConfigSystem.FilePath)
        end
        
        -- M√©todo 2: Fluxus
        if fluxus and fluxus.read_file and fluxus.file_exists and fluxus.file_exists(ConfigSystem.FilePath) then
            return fluxus.read_file(ConfigSystem.FilePath)
        end
        
        -- M√©todo 3: Delta
        if delta_config and delta_config.load and delta_config.exists and delta_config.exists(ConfigSystem.FilePath) then
            return delta_config.load(ConfigSystem.FilePath)
        end
        
        -- M√©todo 4: Codex
        if readfile and getrenv().readfile and isfile and getrenv().isfile and getrenv().isfile(ConfigSystem.FilePath) then
            return getrenv().readfile(ConfigSystem.FilePath)
        end
        
        return nil
    end)
    
    if success and content then
        local data
        success, data = pcall(function()
            return HttpService:JSONDecode(content)
        end)
        
        if success and data then
        ConfigSystem.CurrentConfig = data
            print("Configura√ß√£o carregada de: " .. ConfigSystem.FilePath)
        return true
    else
            warn("Erro ao analisar configura√ß√£o, criando nova.")
        end
    end
    
    -- Se n√£o conseguir ler ou ocorrer erro, criar configura√ß√£o padr√£o
        ConfigSystem.CurrentConfig = table.clone(ConfigSystem.DefaultConfig)
        ConfigSystem.SaveConfig()
    print("Inicializando nova configura√ß√£o")
        return false
    end

-- Criar um sistema de auto save separado
local function setupAutoSave()
    spawn(function()
        while wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                ConfigSystem.SaveConfig()
            end)
        end
    end)
end

-- Carregar configura√ß√£o ao iniciar
ConfigSystem.LoadConfig()
setupAutoSave() -- Iniciando salvamento autom√°tico

-- Atualizar fun√ß√£o para salvar imediatamente ao alterar valor
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then
            for _, element in pairs(tab._components) do
                if element and element.OnChanged then
                    element.OnChanged:Connect(function()
                        pcall(function()
                            ConfigSystem.SaveConfig()
                        end)
                    end)
                end
            end
        end
    end
end

-- Configurar SaveManager do Fluent para compatibilidade
local playerName = game:GetService("Players").LocalPlayer.Name
if InterfaceManager then
    InterfaceManager:SetFolder("Allan Hub")
end
if SaveManager then
    SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)
end

-- Detectar automaticamente novo HumanoidRootPart quando o jogador renascer
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
end)

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end

            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function getNearestSelectedEnemy()
    -- Se nenhum inimigo for encontrado em 5 segundos, atualizar lista
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 5 then
        killedNPCs = {} -- Redefinir lista de inimigos mortos
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time() -- Atualizar hora em que o inimigo foi encontrado
    end
    
    return nearestEnemy
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] then
            return enemy
        end
    end
    return nil
end

local function fireShowPetsRemote()
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ShowPets"
            },
            [2] = "\t"
        }
    }
    remote:FireServer(unpack(args))
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
    elseif movementMethod == "Walk" then
        hrp.Parent:MoveTo(enemyHrp.Position)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.2)
    end
end

local function teleportDungeon()
    while teleportEnabled do
        local function getDistance(pos1, pos2)
            return (pos1 - pos2).Magnitude
        end

        local function getClosestEnemy()
            local closestEnemy = nil
            local closestDistance = math.huge
            local playerPosition = hrp.Position
            for _, enemy in pairs(enemiesFolder:GetChildren()) do
                local hp = enemy:GetAttribute("HP")
                if hp and hp > 0 and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local distance = getDistance(playerPosition, enemy.HumanoidRootPart.Position)
                    if distance < closestDistance then
                        closestDistance = distance
                        closestEnemy = enemy
                    end
                end
            end
            return closestEnemy
        end

        local function moveToEnemy(enemy)
            if enemy and enemy:FindFirstChild("HumanoidRootPart") then
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(hrp, tweenInfo, {
                    CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
                })
                tween:Play()
                tween.Completed:Wait()
            end
        end

        local enemy = getClosestEnemy()
        if enemy then
            moveToEnemy(enemy)
            while teleportEnabled and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 do
                task.wait(0.3)
            end
        else
            task.wait(1)
        end
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = getNearestSelectedEnemy()
        
        -- Se n√£o encontrar alvo em 3 segundos, atualizar lista
        if not target and os.time() - lastResetTime > 3 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Lista de inimigos mortos foi atualizada")
        end
        
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.5)
            fireShowPetsRemote()

            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })

            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.20)
    end
end

-- Farm Method Selection Dropdown
local Fluent
local SaveManager
local InterfaceManager

local success, err = pcall(function()
    Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
    SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
    InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
end)

if not success then
    warn("Erro ao carregar biblioteca Fluent: " .. tostring(err))
    -- Th·ª≠ t·∫£i t·ª´ URL d·ª± ph√≤ng
    pcall(function()
        Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Fluent.lua"))()
        SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
        InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
    end)
end

if not Fluent then
    error("N√£o foi poss√≠vel carregar a biblioteca Fluent. Verifique sua conex√£o com a internet ou executor.")
    return
end

local Window = Fluent:CreateWindow({
    Title = "Allan Hub | Arise Crossover",
    SubTitle = "",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 350),
    Acrylic = false,
    Theme = "Luffy",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    dungeon = Window:AddTab({ Title = "Dungeon ", Icon = "" }),
    desert = Window:AddTab({ Title = "Deserto Infinito", Icon = "" }),
    tp = Window:AddTab({ Title = "Teleports", Icon = "" }),
    mount = Window:AddTab({ Title = "Mount Location/farm", Icon = "" }),
    shop = Window:AddTab({ Title = "Shop", Icon = "" }),
    Player = Window:AddTab({ Title = "Player", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
}


-- T·∫°o mapping gi·ªØa c√°c map v√† danh s√°ch mob t∆∞∆°ng ·ª©ng
local mobsByWorld = {
    ["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
    ["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
    ["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
    ["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
    ["BCWorld"] = {"Sortudo", "Michille", "Wind"},
    ["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
    ["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
    ["DBWorld"] = {"Turtle", "Green", "Sky"},
    ["OPMWorld"] = {"Rider", "Cryborg", "Hurricane"}
}

local selectedWorld = "SoloWorld" -- Default world

-- Dropdown ƒë·ªÉ ch·ªçn World/Map
Tabs.Main:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Values = {"SoloWorld", "NarutoWorld", "OPWorld", "BleachWorld", "BCWorld", "ChainsawWorld", "JojoWorld", "DBWorld", "OPMWorld"},
    Multi = false,
    Default = selectedWorld,
    Callback = function(world)
        selectedWorld = world
        ConfigSystem.CurrentConfig.SelectedWorld = world
        
        -- C·∫≠p nh·∫≠t danh s√°ch mob d·ª±a tr√™n world ƒë∆∞·ª£c ch·ªçn
        local mobDropdown = Fluent.Options.WorldMobDropdown
        if mobDropdown then
            mobDropdown:SetValues(mobsByWorld[world] or {})
            -- ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu c√≥ mob
            if #mobsByWorld[world] > 0 then
                selectedMobName = mobsByWorld[world][1]
                mobDropdown:SetValue(selectedMobName)
                ConfigSystem.CurrentConfig.SelectedMobName = selectedMobName
            else
                selectedMobName = ""
            end
        end
        
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de world
    end
})

-- Dropdown ƒë·ªÉ ch·ªçn Mob trong world ƒë√£ ch·ªçn
Tabs.Main:AddDropdown("WorldMobDropdown", {
    Title = "Select Enemy",
    Values = mobsByWorld[selectedWorld] or {},
    Multi = false,
    Default = mobsByWorld[selectedWorld] and mobsByWorld[selectedWorld][1] or "",
    Callback = function(mob)
        selectedMobName = mob
        ConfigSystem.CurrentConfig.SelectedMobName = mob
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao trocar de mob
        print("Selected Mob:", selectedMobName) -- Debug
    end
})

Tabs.Main:AddToggle("FarmSelectedMob", {
    Title = "Farm Selected Mob",
    Default = ConfigSystem.CurrentConfig.FarmSelectedMob or false,
    Callback = function(state)
        teleportEnabled = state
        damageEnabled = state -- ƒê·∫£m b·∫£o t√≠nh nƒÉng t·∫•n c√¥ng mobs ƒë∆∞·ª£c k√≠ch ho·∫°t
        ConfigSystem.CurrentConfig.FarmSelectedMob = state
        ConfigSystem.SaveConfig()
        killedNPCs = {} -- Redefinir lista de NPC mortos ao iniciar farm
        if state then
            task.spawn(teleportToSelectedEnemy)
        end
    end
})

Tabs.Main:AddToggle("TeleportMobs", {
    Title = "Auto farm (nearest NPCs)",
    Default = ConfigSystem.CurrentConfig.AutoFarmNearestNPCs or false,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmNearestNPCs = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(teleportAndTrackDeath)
        end
    end
})

local Dropdown = Tabs.Main:AddDropdown("MovementMethod", {
    Title = "Farming Method",
    Values = {"Tween", "Teleport"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.FarmingMethod == "Teleport" and 2 or 1,
    Callback = function(option)
        movementMethod = option
        ConfigSystem.CurrentConfig.FarmingMethod = option
        ConfigSystem.SaveConfig()
    end 
})

Tabs.Main:AddToggle("GamepassShadowFarm", {
    Title = "Shadow farm",
    Default = false,
    Callback = function(state)
        local attackatri = game:GetService("Players").LocalPlayer.Settings
        local atri = attackatri:GetAttribute("AutoAttack")
        
        if state then
            -- B·∫≠t t√≠nh nƒÉng
            if atri == false then
                attackatri:SetAttribute("AutoAttack", true)
            end
            print("Shadow farm ativado")
        else
            -- T·∫Øt t√≠nh nƒÉng
            attackatri:SetAttribute("AutoAttack", false)
            print("Shadow farm desativado")
        end
    end
})

-- Adicionar toggle de Auto Attack
local autoAttackEnabled = false
local attackCooldown = 0.5

Tabs.Main:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack Mobs",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        
        if state then
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Ativado ataque autom√°tico a mobs",
                Duration = 3
            })
            
            -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p auto attack
            task.spawn(function()
                while autoAttackEnabled do
                    local targetEnemy
                    
                    -- Ki·ªÉm tra xem Farm Selected Mob c√≥ ƒëang b·∫≠t kh√¥ng
                    if ConfigSystem.CurrentConfig.FarmSelectedMob and selectedMobName ~= "" then
                        -- N·∫øu ƒëang farm mob ƒë√£ ch·ªçn, t√¨m mob ƒë√≥
                        targetEnemy = getNearestSelectedEnemy()
                    else
                        -- N·∫øu kh√¥ng, t√¨m b·∫•t k·ª≥ mob n√†o g·∫ßn nh·∫•t
                        targetEnemy = getNearestEnemy()
                    end
                    
                    if targetEnemy then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "PunchAttack",
                                    ["Enemy"] = targetEnemy.Name
                                },
                                [2] = "\4"
                            }
                        }
                        remote:FireServer(unpack(args))
                    end
                    task.wait(attackCooldown) -- Ch·ªù gi·ªØa c√°c l·∫ßn t·∫•n c√¥ng
                end
            end)
        else
            Fluent:Notify({
                Title = "Auto Attack",
                Content = "Desativado ataque autom√°tico a mobs",
                Duration = 3
            })
        end
    end
})

local function SetSpawnAndReset(spawnName)
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "ChangeSpawn",
                ["Spawn"] = spawnName
            },
            [2] = "\n"
        }
    }

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
    remote:FireServer(unpack(args))

    -- Esperar um pouco antes de renascer (t√πy ch·ªçn, ƒë·ªÉ ƒë·∫£m b·∫£o ƒëi·ªÉm h·ªìi sinh ƒë∆∞·ª£c thi·∫øt l·∫≠p)
    task.wait(0.5)

    -- H·ªìi sinh nh√¢n v·∫≠t
    local player = game.Players.LocalPlayer
if player.Character and player.Character.Parent then
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0 -- T·∫°o ra c√°i ch·∫øt t·ª± nhi√™n m√† kh√¥ng x√≥a nh√¢n v·∫≠t ƒë·ªôt ng·ªôt
    end
end

end

local TweenService = game:GetService("TweenService")

-- L·∫•y Player v√† HumanoidRootPart
local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- C·∫≠p nh·∫≠t HRP khi nh√¢n v·∫≠t h·ªìi sinh
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart") -- L·∫•y HRP m·ªõi sau khi h·ªìi sinh
end)

-- H√†m di chuy·ªÉn (Lu√¥n s·ª≠ d·ª•ng HRP m·ªõi nh·∫•t)
local function teleportWithTween(targetCFrame)
    if hrp then
        local tweenInfo = TweenInfo.new(
            2, -- Th·ªùi gian (gi√¢y)
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.Out,
            0, -- Kh√¥ng l·∫∑p l·∫°i
            false, -- Kh√¥ng ƒë·∫£o ng∆∞·ª£c
            0 -- Kh√¥ng ƒë·ªô tr·ªÖ
        )

        local tweenGoal = {CFrame = targetCFrame}
        local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
        tween:Play()
    end
end


-- Locations List
local locations = {
    {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668, -0.41691944, -8.07482721e-08, 0.908943415, -2.94452178e-07, 1, -4.62235228e-08, -0.908943415, -2.86911842e-07, -0.41691944)},
    {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379, 0.836233854, -7.47273816e-08, -0.548372984, 2.59595481e-07, 1, 2.59595481e-07, 0.548372984, -3.59437678e-07, 0.836233854)},
    {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244, 0.8239398, -3.60997859e-07, -0.566677332, 2.59595453e-07, 1, -2.59595396e-07, 0.566677332, 6.67841249e-08, 0.8239398)},
    {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646, 0.978662074, 0.000114096198, -0.205476329, -0.000112703143, 1, 1.84834444e-05, 0.205476329, 5.06878177e-06, 0.978662074)},
    {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292, -0.999887109, -1.20863996e-12, 0.0150266131, -1.12492459e-12, 1, 5.57959278e-12, -0.0150266131, 5.56205906e-12, -0.999887109)},
    {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113, -0.534268856, -4.75206689e-05, 0.845314622, -7.48304665e-05, 1, 8.92103617e-06, -0.845314622, -5.84890549e-05, -0.534268856)},
    {Name = "Location 7", CFrame = CFrame.new(4325.36523, 118.995422, -4819.78857, -0.257801384, 3.98855832e-07, -0.966197908, -5.63039578e-07, 1, 5.63040146e-07, 0.966197908, 6.89160231e-07, -0.257801384)}
    
    
}

-- Add buttons for each location
for _, loc in ipairs(locations) do
    Tabs.mount:AddButton({
        Title = loc.Name,
        Callback = function()
            teleportWithTween(loc.CFrame)
        end
    })
end


local autoDestroy = false
local autoArise = false

-- Function to Fire DestroyPrompt


local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")


local function fireDestroy()
    while autoDestroy do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local DestroyPrompt = rootPart and rootPart:FindFirstChild("DestroyPrompt")

                if DestroyPrompt then
                    DestroyPrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(DestroyPrompt)
                end
            end
        end
    end
end



-- Function to Fire ArisePrompt

local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")


local function fireArise()
    while autoArise do
        task.wait(0.3)  -- Delay to prevent overloading

        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") then
                local rootPart = enemy:FindFirstChild("HumanoidRootPart")
                local arisePrompt = rootPart and rootPart:FindFirstChild("ArisePrompt")

                if arisePrompt then
                    arisePrompt:SetAttribute("MaxActivationDistance", 100000)
                    fireproximityprompt(arisePrompt)
                end
            end
        end
    end
end


-- Auto Destroy Toggle
Tabs.Main:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = ConfigSystem.CurrentConfig.MainAutoDestroy or false,
    Callback = function(state)
        autoDestroy = state
        ConfigSystem.CurrentConfig.MainAutoDestroy = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.Main:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = ConfigSystem.CurrentConfig.MainAutoArise or false,
    Callback = function(state)
        autoArise = state
        ConfigSystem.CurrentConfig.MainAutoArise = state
        ConfigSystem.SaveConfig()
        if state then
            task.spawn(fireArise)
        end
    end
})

Tabs.dungeon:AddToggle("AutoDestroy", {
    Title = "Auto Destroy",
    Default = false,
    Flag = "DungeonAutoDestroy", -- Adicionar Flag para salvar configura√ß√£o
    Callback = function(state)
        autoDestroy = state
        if state then
            task.spawn(fireDestroy)
        end
    end
})

-- Auto Arise Toggle
Tabs.dungeon:AddToggle("AutoArise", {
    Title = "Auto Arise",
    Default = false,
    Flag = "DungeonAutoArise", -- Adicionar Flag para salvar configura√ß√£o
    Callback = function(state)
        autoArise = state
        if state then
            task.spawn(fireArise)
        end
    end
})


local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local dungeonFolder = workspace:WaitForChild("__Main"):WaitForChild("__Dungeon")

-- ==========================
-- AUTO FARM DUNGEON COM REL√çQUIA AUTOM√ÅTICA
-- ==========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
local player = game.Players.LocalPlayer

-- ======================================================
-- üìù Lista de Runas: [NomeInterno] = "Nome para Exibir"
-- ‚ûï Adicione mais manualmente aqui
-- ======================================================
local RUNE_LIST = {
    ["DgJojoRune"] = "Jojo Rune",
    -- ["DgOutraRune"] = "Outra Rune",
    -- ["DgSuperRune"] = "Super Runa"
}

-- Lista de runas selecionadas (nomes internos)
local selectedRunes = {}
-- Toggle de uso de rel√≠quia
local useRelicEnabled = false

-- ==========================
-- Fun√ß√µes Auxiliares
-- ==========================
local function getDistance(a, b)
    return (a - b).Magnitude
end

local function getClosestEnemy()
    local enemiesFolder = workspace:FindFirstChild("_Main") and workspace.Main._Enemies.Server
    if not enemiesFolder then return nil end

    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

    local pos = character.HumanoidRootPart.Position
    local closest, minDist = nil, math.huge

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        local hp = enemy:GetAttribute("HP")
        if hp and hp > 0 and enemy.Position then
            local d = getDistance(pos, enemy.Position)
            if d < minDist then
                minDist = d
                closest = enemy
            end
        end
    end
    return closest
end

local function moveToEnemy(enemy, currentTween)
    local TweenService = game:GetService("TweenService")
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or not enemy.Position then
        return false, currentTween
    end

    if currentTween then currentTween:Cancel() end

    character.PrimaryPart = character.HumanoidRootPart
    character.HumanoidRootPart.Anchored = false

    local info = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    currentTween = TweenService:Create(character.PrimaryPart, info, {CFrame = enemy.CFrame})
    currentTween:Play()

    task.spawn(function()
        currentTween.Completed:Wait()
        currentTween = nil
    end)

    return true, currentTween
end

-- ==========================
-- ‚öî Fun√ß√£o para criar e iniciar dungeon (com runas se ativado)
-- ==========================
local function createAndStartDungeon()
    -- Criar dungeon
    local createArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\13"
        }
    }
    Remote:FireServer(unpack(createArgs))
    task.wait(0.5)

    -- Se ‚ÄúUsar Rel√≠quia‚Äù estiver ativo, adiciona as runas selecionadas
    if useRelicEnabled and #selectedRunes > 0 then
        for slot, runeInternalName in ipairs(selectedRunes) do
            local addRuneArgs = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = 7368292297,
                        ["Action"] = "AddItems",
                        ["Slot"] = slot,
                        ["Event"] = "DungeonAction",
                        ["Item"] = runeInternalName
                    },
                    [2] = "\13"
                }
            }
            Remote:FireServer(unpack(addRuneArgs))
            print(string.format("[RUNA] Adicionada: %s (Slot %d)", runeInternalName, slot))
            task.wait(0.2)
        end
    end

    -- Iniciar dungeon
    local startArgs = {
        [1] = {
            [1] = {
                ["Dungeon"] = 7368292297,
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\13"
        }
    }
    Remote:FireServer(unpack(startArgs))
    print("‚ñ∂ Dungeon criada e iniciada.")
end

-- ==========================
-- üåÄ Sistema de Auto Farm com Recria√ß√£o
-- ==========================
ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate = ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate or false
ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate or ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate

local autoFarmEnabled = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate
local currentTween = nil
local lastEnemyCheck = tick()
local maxTimeWithoutEnemies = 5

local function monitorDungeon()
    print("[AUTO-FARM] Iniciado.")
    while autoFarmEnabled do
        pcall(function()
            if not workspace:FindFirstChild("__Main") then
                createAndStartDungeon()
                task.wait(5)
            end

            local enemy = getClosestEnemy()
            local now = tick()

            if enemy then
                lastEnemyCheck = now
                local ok
                ok, currentTween = moveToEnemy(enemy, currentTween)
                if ok then
                    local attempts = 0
                    while autoFarmEnabled and enemy.Parent and enemy:GetAttribute("HP") and enemy:GetAttribute("HP") > 0 and attempts < 100 do
                        task.wait(0.1)
                        attempts += 1
                    end
                end
            else
                local idleTime = now - lastEnemyCheck
                if idleTime >= maxTimeWithoutEnemies then
                    print("[AUTO-FARM] Dungeon limpa, recriando...")
                    createAndStartDungeon()
                    lastEnemyCheck = tick()
                    task.wait(5)
                else
                    task.wait(1)
                end
            end
        end)
        task.wait(0.1)
    end
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    print("[AUTO-FARM] Parado.")
end

-- ==========================
-- üåü UI: Dropdown de Rel√≠quias + Toggle de ‚ÄúUsar Rel√≠quia‚Äù
-- ==========================
local dungeonTab = Tabs.dungeon

-- Converte lista interna ‚Üí nomes bonitos
local runeDisplayNames = {}
for internal, display in pairs(RUNE_LIST) do
    table.insert(runeDisplayNames, display)
end

-- Dropdown para selecionar quais rel√≠quias usar (multi)
dungeonTab:AddDropdown("SelectRelics", {
    Title = "Selecionar Rel√≠quias",
    Values = runeDisplayNames,
    Multi = true,
    Default = {"Jojo Rune"}, -- seleciona Jojo por padr√£o
    Callback = function(selectedDisplayNames)
        selectedRunes = {}
        for _, displayName in ipairs(selectedDisplayNames) do
            for internal, display in pairs(RUNE_LIST) do
                if display == displayName then
                    table.insert(selectedRunes, internal)
                end
            end
        end
        print("[RELIC] Selecionadas:", table.concat(selectedRunes, ", "))
    end
})

-- Toggle para ativar o uso autom√°tico da rel√≠quia
dungeonTab:AddToggle("UseRelicToggle", {
    Title = "Usar Rel√≠quia",
    Default = false,
    Callback = function(state)
        useRelicEnabled = state
        print("[RELIC] Uso autom√°tico:", state and "ATIVADO" or "DESATIVADO")
    end
})

-- Toggle de Auto Farm
dungeonTab:AddToggle("AutoFarmDungeon", {
    Title = "Auto Farm Dungeon (Recria√ß√£o)",
    Default = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate,
    Flag = "AutoFarmDungeonRecreate",
    Callback = function(state)
        autoFarmEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(monitorDungeon)
        else
            if currentTween then currentTween:Cancel() end
            print("[AUTO-FARM] Desativado.")
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Thay ƒë·ªïi c√°ch l∆∞u c·∫•u h√¨nh ƒë·ªÉ s·ª≠ d·ª•ng t√™n ng∆∞·ªùi ch∆°i
local playerName = game:GetService("Players").LocalPlayer.Name
InterfaceManager:SetFolder("Allan Hub")
SaveManager:SetFolder("Allan Hub/AriseCrossover/" .. playerName)

-- X√≥a ƒëo·∫°n x√¢y d·ª±ng ph·∫ßn c·∫•u h√¨nh trong Settings tab
-- InterfaceManager:BuildInterfaceSection(Tabs.Settings)
-- SaveManager:BuildConfigSection(Tabs.Settings)

-- Th√™m th√¥ng tin v√†o tab Settings
Tabs.Settings:AddParagraph({
    Title = "C·∫•u h√¨nh t·ª± ƒë·ªông",
    Content = "C·∫•u h√¨nh c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u theo t√™n nh√¢n v·∫≠t: " .. playerName
})

Tabs.Settings:AddParagraph({
    Title = "Ph√≠m t·∫Øt",
    Content = "Nh·∫•n LeftControl ƒë·ªÉ ·∫©n/hi·ªán giao di·ªán"
})

-- Th√™m n√∫t x√≥a c·∫•u h√¨nh hi·ªán t·∫°i
Tabs.Settings:AddButton({
    Title = "X√≥a c·∫•u h√¨nh hi·ªán t·∫°i",
    Description = "ƒê·∫∑t l·∫°i t·∫•t c·∫£ c√†i ƒë·∫∑t v·ªÅ m·∫∑c ƒë·ªãnh",
    Callback = function()
        SaveManager:Delete("AutoSave_" .. playerName)
        Fluent:Notify({
            Title = "ƒê√£ x√≥a c·∫•u h√¨nh",
            Content = "T·∫•t c·∫£ c√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i v·ªÅ m·∫∑c ƒë·ªãnh",
            Duration = 3
        })
    end
})

Window:SelectTab(1)

Fluent:Notify({
    Title = "Allan Hub",
    Content = "Script ƒë√£ t·∫£i xong! C·∫•u h√¨nh t·ª± ƒë·ªông l∆∞u theo t√™n ng∆∞·ªùi ch∆°i: " .. playerName,
    Duration = 3
})

-- Thay ƒë·ªïi c√°ch t·∫£i c·∫•u h√¨nh
local function AutoSaveConfig()
    local configName = "AutoSave_" .. playerName
    
    -- T·ª± ƒë·ªông l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i
    task.spawn(function()
        while task.wait(5) do -- Salvar a cada 5 segundos
            pcall(function()
                SaveManager:Save(configName)
            end)
        end
    end)
    
    -- T·∫£i c·∫•u h√¨nh ƒë√£ l∆∞u n·∫øu c√≥
    pcall(function()
        SaveManager:Load(configName)
    end)
end

-- Th·ª±c thi t·ª± ƒë·ªông l∆∞u/t·∫£i c·∫•u h√¨nh
AutoSaveConfig()

-- Th√™m h·ªó tr·ª£ Mobile UI
repeat task.wait(0.25) until game:IsLoaded()
getgenv().Image = "rbxassetid://13099788281" -- ID t√†i nguy√™n h√¨nh ·∫£nh ƒë√£ s·ª≠a
getgenv().ToggleUI = "LeftControl" -- Ph√≠m ƒë·ªÉ b·∫≠t/t·∫Øt giao di·ªán

-- T·∫°o giao di·ªán mobile cho ng∆∞·ªùi d√πng ƒëi·ªán tho·∫°i
task.spawn(function()
    local success, errorMsg = pcall(function()
        if not getgenv().LoadedMobileUI == true then 
            getgenv().LoadedMobileUI = true
            local OpenUI = Instance.new("ScreenGui")
            local ImageButton = Instance.new("ImageButton")
            local UICorner = Instance.new("UICorner")
            
            -- Ki·ªÉm tra thi·∫øt b·ªã
            if syn and syn.protect_gui then
                syn.protect_gui(OpenUI)
                OpenUI.Parent = game:GetService("CoreGui")
            elseif gethui then
                OpenUI.Parent = gethui()
            else
                OpenUI.Parent = game:GetService("CoreGui")
            end
            
            OpenUI.Name = "OpenUI"
            OpenUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            
            ImageButton.Parent = OpenUI
            ImageButton.BackgroundColor3 = Color3.fromRGB(105,105,105)
            ImageButton.BackgroundTransparency = 0.8
            ImageButton.Position = UDim2.new(0.9,0,0.1,0)
            ImageButton.Size = UDim2.new(0,50,0,50)
            ImageButton.Image = getgenv().Image
            ImageButton.Draggable = true
            ImageButton.Transparency = 0.2
            
            UICorner.CornerRadius = UDim.new(0,200)
            UICorner.Parent = ImageButton
            
            ImageButton.MouseButton1Click:Connect(function()
                game:GetService("VirtualInputManager"):SendKeyEvent(true,getgenv().ToggleUI,false,game)
            end)
        end
    end)
    
    if not success then
        warn("Erro ao criar bot√£o da UI Mobile: " .. tostring(errorMsg))
    end
end)

-- Ki·ªÉm tra script ƒë√£ t·∫£i th√†nh c√¥ng
local scriptSuccess, scriptError = pcall(function()
    Fluent:Notify({
        Title = "Script iniciado com sucesso",
        Content = "Allan Hub | Arise Crossover est√° ativo",
        Duration = 5
    })
end)

if not scriptSuccess then
    warn("L·ªói khi kh·ªüi ƒë·ªông script: " .. tostring(scriptError))
    -- Th·ª≠ c√°ch kh√°c ƒë·ªÉ th√¥ng b√°o ng∆∞·ªùi d√πng
    if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui") then
        local screenGui = Instance.new("ScreenGui")
        screenGui.Parent = game:GetService("Players").LocalPlayer.PlayerGui
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(0.3, 0, 0.1, 0)
        textLabel.Position = UDim2.new(0.35, 0, 0.45, 0)
        textLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.Text = "Allan Hub ƒë√£ kh·ªüi ƒë·ªông nh∆∞ng g·∫∑p l·ªói. H√£y th·ª≠ l·∫°i."
        textLabel.Parent = screenGui
        
        local uiCorner = Instance.new("UICorner")
        uiCorner.CornerRadius = UDim.new(0, 8)
        uiCorner.Parent = textLabel
        
        game:GetService("Debris"):AddItem(screenGui, 5)
    end
end

-- Th√™m event listener ƒë·ªÉ l∆∞u ngay khi thay ƒë·ªïi gi√° tr·ªã
local function setupSaveEvents()
    for _, tab in pairs(Tabs) do
        if tab and tab._components then -- Ki·ªÉm tra tab v√† tab._components c√≥ t·ªìn t·∫°i kh√¥ng
        for _, element in pairs(tab._components) do
                if element and element.OnChanged then -- Ki·ªÉm tra element v√† element.OnChanged c√≥ t·ªìn t·∫°i kh√¥ng
                element.OnChanged:Connect(function()
                    pcall(function()
                        SaveManager:Save("AutoSave_" .. playerName)
                    end)
                end)
                end
            end
        end
    end
end

-- Th·ª±c thi t·ª± ƒë·ªông l∆∞u/t·∫£i c·∫•u h√¨nh
AutoSaveConfig()
setupSaveEvents() -- Th√™m d√≤ng n√†y

local BuyWeaponSection = Tabs.shop:AddSection("Buy Weapon")
-- Mapping gi·ªØa shops v√† weapons
local weaponsByShop = {
    ["WeaponShop1"] = {"SpikeMace", "GemStaff", "DualKando", "CrystalScepter", "DualBoneMace", "DualSteelNaginata"},
    ["WeaponShop2"] = {"MonsterSlayer", "DualBasicStaffs", "PirateSaber", "BronzeGreatAxe", "MixedBattleAxe", "DualAncientMace"},
    ["WeaponShop3"] = {"DualPirateSaber", "DualSteelSabers", "DualSteelButterfly", "SteelSaber", "SteelButterfly", "SteelKando"},
    ["WeaponShop4"] = {"SteelNaginata", "GreatKopesh", "BoneMace", "CrimsonStaff", "AncientMace", "GreatSaber"},
    ["WeaponShop5"] = {"DualGreatSaber", "BasicStaff", "StellKopesh", "GreatTrident", "DualCrystalScepter", "DualTrident"},
    ["WeaponShop6"] = {"OzSword2", "CrystalSword2", "ObsidianDualAxe2", "SilverSpear2", "DragonAxe2", "DualDivineAxe2"},
    ["WeaponShop7"] = {"BloodStaff2", "DualCrimsonStaff2", "DualGemStaffs2", "GreatScythe2", "TwinObsidianDualStaff2", "SlayerScythe2"},
    ["WeaponShop8"] = {"BeholderStaff2", "TwinMixedAxe2", "TwinTrollSlayer2", "RuneAxe2", "DualSilverSpear2", "DualDragonAxe2"},
    ["WeaponShop9"] = {"SteelSword2", "SteelSpear2", "StarSpear2", "BoneStaff2", "SunGreatAxe2", "EnergyGreatSword2"},
}

local selectedShop = "WeaponShop1" -- Shop m·∫∑c ƒë·ªãnh
local selectedWeapon = "" -- Weapon m·∫∑c ƒë·ªãnh
local autoBuyEnabled = false -- Tr·∫°ng th√°i Auto Buy

-- C·∫≠p nh·∫≠t ConfigSystem ƒë·ªÉ l∆∞u c√°c bi·∫øn m·ªõi
ConfigSystem.DefaultConfig.SelectedShop = selectedShop
ConfigSystem.DefaultConfig.SelectedWeapon = selectedWeapon
ConfigSystem.DefaultConfig.AutoBuyEnabled = autoBuyEnabled

-- Dropdown ƒë·ªÉ ch·ªçn Shop
Tabs.shop:AddDropdown("ShopDropdown", {
    Title = "Select Shop",
    Values = {"WeaponShop1", "WeaponShop2", "WeaponShop3", "WeaponShop4", "WeaponShop5", "WeaponShop6", "WeaponShop7", "WeaponShop8", "WeaponShop9"},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedShop or selectedShop,
    Callback = function(shop)
        selectedShop = shop
        ConfigSystem.CurrentConfig.SelectedShop = shop
        
        -- C·∫≠p nh·∫≠t danh s√°ch weapon d·ª±a tr√™n shop ƒë∆∞·ª£c ch·ªçn
        local weaponDropdown = Fluent.Options.WeaponDropdown
        if weaponDropdown then
            weaponDropdown:SetValues(weaponsByShop[shop] or {})
            -- ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu c√≥ weapon
            if #weaponsByShop[shop] > 0 then
                selectedWeapon = weaponsByShop[shop][1]
                weaponDropdown:SetValue(selectedWeapon)
                ConfigSystem.CurrentConfig.SelectedWeapon = selectedWeapon
            else
                selectedWeapon = ""
            end
        end
        
        ConfigSystem.SaveConfig()
    end
})

-- Dropdown ƒë·ªÉ ch·ªçn Weapon trong shop ƒë√£ ch·ªçn
Tabs.shop:AddDropdown("WeaponDropdown", {
    Title = "Select Weapon",
    Values = weaponsByShop[selectedShop] or {},
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeapon or (weaponsByShop[selectedShop] and weaponsByShop[selectedShop][1] or ""),
    Callback = function(weapon)
        selectedWeapon = weapon
        ConfigSystem.CurrentConfig.SelectedWeapon = weapon
        ConfigSystem.SaveConfig()
        print("Selected Weapon:", selectedWeapon) -- Debug
    end
})
-- ‚è≥ ƒê·ªìng b·ªô l·∫°i danh s√°ch v≈© kh√≠ sau khi GUI ƒë√£ kh·ªüi t·∫°o
task.defer(function()
    local currentShop = ConfigSystem.CurrentConfig.SelectedShop
    local currentWeapon = ConfigSystem.CurrentConfig.SelectedWeapon
    local weaponDropdown = Fluent.Options.WeaponDropdown

    if currentShop and weaponsByShop[currentShop] and weaponDropdown then
        weaponDropdown:SetValues(weaponsByShop[currentShop])
        if table.find(weaponsByShop[currentShop], currentWeapon) then
            weaponDropdown:SetValue(currentWeapon)
        else
            local defaultWeapon = weaponsByShop[currentShop][1]
            selectedWeapon = defaultWeapon
            weaponDropdown:SetValue(defaultWeapon)
            ConfigSystem.CurrentConfig.SelectedWeapon = defaultWeapon
            ConfigSystem.SaveConfig()
        end
    end
end)


-- H√†m ƒë·ªÉ mua weapon
local function buyWeapon()
    if selectedShop and selectedWeapon and selectedWeapon ~= "" then
        local args = {
            [1] = {
                [1] = {
                    ["Action"] = "Buy",
                    ["Shop"] = selectedShop,
                    ["Item"] = selectedWeapon,
                    ["Event"] = "ItemShopAction"
                },
                [2] = "\n"
            }
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
        print("Comprado:", selectedWeapon, "da loja:", selectedShop)
    else
        print("Por favor, selecione uma loja e uma arma!")
    end
end

-- Toggle ƒë·ªÉ b·∫≠t/t·∫Øt Auto Buy
Tabs.shop:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy Weapon",
    Default = ConfigSystem.CurrentConfig.AutoBuyEnabled or false,
    Callback = function(state)
        autoBuyEnabled = state
        ConfigSystem.CurrentConfig.AutoBuyEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            task.spawn(function()
                while autoBuyEnabled do
                    buyWeapon()
                    task.wait(1) -- Ch·ªù 1 gi√¢y gi·ªØa m·ªói l·∫ßn mua
                end
            end)
        end
    end
})
local UpdateWeaponSection = Tabs.shop:AddSection("Update Weapon")
-- Th√™m code cho tab Update sau ph·∫ßn m√£ c·ªßa tab Buy
-- H√†m ƒë·ªÉ l·∫•y danh s√°ch t√™n v≈© kh√≠ duy nh·∫•t t·ª´ inventory
local function getUniqueWeaponNames()
    local weapons = {}
    local seenNames = {} -- ƒê·ªÉ theo d√µi t√™n duy nh·∫•t

    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    print("Obtendo lista de armas...") -- G·ª† L·ªñI

    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name") -- L·∫•y thu·ªôc t√≠nh "Name"
        if weaponName then
            print("Arma encontrada:", weaponName) -- G·ª† L·ªñI
            if not seenNames[weaponName] then
                table.insert(weapons, weaponName)
                seenNames[weaponName] = true -- ƒê√°nh d·∫•u t√™n ƒë√£ th·∫•y
            end
        end
    end
    return weapons
end

-- H√†m ƒë·ªÉ l·∫•y danh s√°ch ID c·ªßa t·∫•t c·∫£ v≈© kh√≠ c√πng lo·∫°i
local function getWeaponIDs(weaponType)
    local weaponIDs = {}
    
    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name")
        -- Ki·ªÉm tra xem v≈© kh√≠ c√≥ ph·∫£i l√† lo·∫°i ƒëang t√¨m ki·∫øm kh√¥ng
        if weaponName == weaponType then
            table.insert(weaponIDs, weapon.Name) -- Th√™m ID c·ªßa v≈© kh√≠ v√†o danh s√°ch
            print("ID da arma encontrado:", weapon.Name) -- G·ª† L·ªñI
        end
    end
    
    return weaponIDs
end

-- L·∫•y danh s√°ch t√™n v≈© kh√≠ ban ƒë·∫ßu
local weaponTypes = getUniqueWeaponNames()
local selectedWeaponType = weaponTypes[1] or "" -- Lo·∫°i v≈© kh√≠ m·∫∑c ƒë·ªãnh
local autoUpdateEnabled = false -- Tr·∫°ng th√°i Auto Update
local autoSelectedEnabled = false -- Tr·∫°ng th√°i Auto Update cho v≈© kh√≠ ƒë√£ ch·ªçn

-- C·∫≠p nh·∫≠t ConfigSystem
ConfigSystem.DefaultConfig.SelectedWeaponType = selectedWeaponType
ConfigSystem.DefaultConfig.AutoUpdateEnabled = autoUpdateEnabled
ConfigSystem.DefaultConfig.AutoSelectedEnabled = autoSelectedEnabled

-- Dropdown ƒë·ªÉ ch·ªçn lo·∫°i v≈© kh√≠ mu·ªën n√¢ng c·∫•p
Tabs.shop:AddDropdown("WeaponTypeDropdown", {
    Title = "Select Weapon",
    Values = weaponTypes,
    Multi = false,
    Default = ConfigSystem.CurrentConfig.SelectedWeaponType or selectedWeaponType,
    Callback = function(weaponType)
        selectedWeaponType = weaponType
        ConfigSystem.CurrentConfig.SelectedWeaponType = weaponType
        ConfigSystem.SaveConfig()
        print("Selected Weapon Type:", selectedWeaponType) -- G·ª† L·ªñI
    end
})

-- H√†m ƒë·ªÉ l·∫•y t·∫•t c·∫£ v≈© kh√≠ theo level
local function getWeaponsByLevel(weaponType)
    local weaponsByLevel = {}
    
    -- Kh·ªüi t·∫°o m·∫£ng ƒë·ªÉ l∆∞u tr·ªØ v≈© kh√≠ theo level
    for i = 1, 7 do
        weaponsByLevel[i] = {}
    end
    
    local playerWeapons = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:GetChildren()
    for _, weapon in ipairs(playerWeapons) do
        local weaponName = weapon:GetAttribute("Name")
        local weaponLevel = weapon:GetAttribute("Level") or 1
        
        -- N·∫øu kh√¥ng ch·ªçn lo·∫°i v≈© kh√≠ c·ª• th·ªÉ ho·∫∑c v≈© kh√≠ thu·ªôc lo·∫°i ƒë√£ ch·ªçn
        if (not weaponType or weaponType == "" or weaponName == weaponType) and weaponLevel >= 1 and weaponLevel <= 7 then
            table.insert(weaponsByLevel[weaponLevel], weapon.Name)
            print("Arma encontrada:", weaponName, "Level:", weaponLevel, "ID:", weapon.Name)
        end
    end
    
    return weaponsByLevel
end

-- H√†m ƒë·ªÉ n√¢ng c·∫•p v≈© kh√≠ theo level
local function upgradeWeaponsByLevel(weaponType)
    local weaponsByLevel = getWeaponsByLevel(weaponType)
    local anyUpgraded = false
    
    -- Duy·ªát qua t·ª´ng level, b·∫Øt ƒë·∫ßu t·ª´ level th·∫•p nh·∫•t
    for level = 1, 6 do
        local weapons = weaponsByLevel[level]
        
        -- N·∫øu c√≥ √≠t nh·∫•t 3 v≈© kh√≠ c√πng level, th·ª±c hi·ªán n√¢ng c·∫•p
        while #weapons >= 3 do
            -- L·∫•y 3 v≈© kh√≠ ƒë·∫ßu ti√™n ƒë·ªÉ n√¢ng c·∫•p
            local upgradeWeapons = {
                weapons[1],
                weapons[2],
                weapons[3]
            }
            
            -- X√≥a 3 v≈© kh√≠ n√†y kh·ªèi danh s√°ch
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            table.remove(weapons, 1)
            
            -- Th·ª±c hi·ªán n√¢ng c·∫•p
            local weaponName = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons:FindFirstChild(upgradeWeapons[1]):GetAttribute("Name")
            
            local args = {
                [1] = {
                    [1] = {
                        ["Type"] = weaponName,
                        ["BuyType"] = "Gems",
                        ["Weapons"] = upgradeWeapons,
                        ["Event"] = "UpgradeWeapon",
                        ["Level"] = level + 1
                    },
                    [2] = "\n"
                }
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            print("ƒêang n√¢ng c·∫•p", #upgradeWeapons, "v≈© kh√≠", weaponName, "t·ª´ level", level, "l√™n level", level + 1)
            
            Fluent:Notify({
                Title = "ƒêang n√¢ng c·∫•p",
                Content = "ƒêang n√¢ng c·∫•p " .. weaponName .. " t·ª´ level " .. level .. " l√™n level " .. (level + 1),
                Duration = 3
            })
            
            anyUpgraded = true
            task.wait(1) -- ƒê·ª£i 1 gi√¢y ƒë·ªÉ tr√°nh spam server
        end
    end
    
    if not anyUpgraded then
        Fluent:Notify({
            Title = "Th√¥ng b√°o",
            Content = "Kh√¥ng c√≥ v≈© kh√≠ n√†o ƒë·ªß s·ªë l∆∞·ª£ng ƒë·ªÉ n√¢ng c·∫•p",
            Duration = 3
        })
    end
    
    return anyUpgraded
end

-- N√∫t ƒë·ªÉ l√†m m·ªõi danh s√°ch v≈© kh√≠
Tabs.shop:AddButton({
    Title = "Refresh Weapon List",
    Description = "Refresh the list of available weapons",
    Callback = function()
        weaponTypes = getUniqueWeaponNames()
        local weaponTypeDropdown = Fluent.Options.WeaponTypeDropdown
        if weaponTypeDropdown then
            weaponTypeDropdown:SetValues(weaponTypes)
            if #weaponTypes > 0 and not table.find(weaponTypes, selectedWeaponType) then
                selectedWeaponType = weaponTypes[1]
                weaponTypeDropdown:SetValue(selectedWeaponType)
                ConfigSystem.CurrentConfig.SelectedWeaponType = selectedWeaponType
                ConfigSystem.SaveConfig()
            end
        end
        
        Fluent:Notify({
            Title = "Danh s√°ch ƒë√£ l√†m m·ªõi",
            Content = "ƒê√£ c·∫≠p nh·∫≠t danh s√°ch v≈© kh√≠ c√≥ s·∫µn",
            Duration = 3
        })
    end
})

-- Toggle ƒë·ªÉ b·∫≠t/t·∫Øt n√¢ng c·∫•p v≈© kh√≠ ƒë√£ ch·ªçn
Tabs.shop:AddToggle("AutoSelectToggle", {
    Title = "Upgrade Selected Weapon",
    Default = ConfigSystem.CurrentConfig.AutoSelectedEnabled or false,
    Callback = function(state)
        autoSelectedEnabled = state
        ConfigSystem.CurrentConfig.AutoSelectedEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if not selectedWeaponType or selectedWeaponType == "" then
                Fluent:Notify({
                    Title = "L·ªói",
                    Content = "Vui l√≤ng ch·ªçn lo·∫°i v≈© kh√≠ tr∆∞·ªõc khi n√¢ng c·∫•p",
                    Duration = 3
                })
                return
            end
            
            task.spawn(function()
                while autoSelectedEnabled do
                    local upgraded = upgradeWeaponsByLevel(selectedWeaponType)
                    if not upgraded then
                        task.wait(5) -- ƒê·ª£i l√¢u h∆°n n·∫øu kh√¥ng c√≥ v≈© kh√≠ n√†o ƒë∆∞·ª£c n√¢ng c·∫•p
                    else
                        task.wait(1) -- ƒê·ª£i ng·∫Øn h∆°n n·∫øu c√≥ v≈© kh√≠ ƒë∆∞·ª£c n√¢ng c·∫•p
                    end
                end
            end)
        end
    end
})

-- Th√™m section sell pet v√†o tab shop
local SellPetSection = Tabs.shop:AddSection("Sell Pet")
-- √Ånh x·∫° c√°c rank s·ªë sang ch·ªØ c√°i
local rankMapping = {
    [1] = "E",
    [2] = "D",
    [3] = "C",
    [4] = "B",
    [5] = "A",
    [6] = "S",
    [7] = "SS",
    [8] = "G",
    [9] = "N"
}

-- T·∫°o m·∫£ng gi√° tr·ªã ƒë·ªÉ hi·ªÉn th·ªã trong dropdown
local rankValues = {}
for i = 1, 9 do
    table.insert(rankValues, rankMapping[i] .. " (Rank " .. i .. ")")
end

-- Bi·∫øn ƒë·ªÉ l∆∞u tr·∫°ng th√°i
local selectedRanks = {}
local autoSellEnabled = false

-- C·∫≠p nh·∫≠t ConfigSystem ƒë·ªÉ l∆∞u c√°c bi·∫øn m·ªõi
ConfigSystem.DefaultConfig.SelectedRanks = {}
ConfigSystem.DefaultConfig.AutoSellEnabled = false

-- Dropdown ƒë·ªÉ ch·ªçn Rank
Tabs.shop:AddDropdown("RankDropdown", {
    Title = "Choose Ranks",
    Values = rankValues,
    Multi = true,
    Default = ConfigSystem.CurrentConfig.SelectedRanks or {},
    Callback = function(selections)
        selectedRanks = {}
        -- Ki·ªÉm tra xem selections c√≥ ph·∫£i l√† table hay kh√¥ng
        if type(selections) == "table" then
            for selection, isSelected in pairs(selections) do
                -- Ch·ªâ x·ª≠ l√Ω c√°c m·ª•c ƒë√£ ch·ªçn (boolean = true)
                if isSelected == true then
                    -- Tr√≠ch xu·∫•t s·ªë rank t·ª´ chu·ªói (vd: t·ª´ "E (Rank 1)" l·∫•y ra 1)
                    local rankStr = selection:match("Rank (%d+)")
                    if rankStr then
                        local rank = tonumber(rankStr)
                        if rank then
                            table.insert(selectedRanks, rank)
                        end
                    end
                end
            end
        end
        ConfigSystem.CurrentConfig.SelectedRanks = selections
        ConfigSystem.SaveConfig()
        print("Selected Ranks:", table.concat(selectedRanks, ", "))
    end
})

-- H√†m ƒë·ªÉ b√°n pet theo rank
local function sellPetsByRank()
    local petFolder = player.leaderstats.Inventory:WaitForChild("Pets")
    local petsToSell = {}
    
    for _, pet in ipairs(petFolder:GetChildren()) do
        local rankVal = pet:GetAttribute("Rank")
        if typeof(rankVal) == "number" and table.find(selectedRanks, rankVal) then
            table.insert(petsToSell, pet.Name)
            
            -- N·∫øu ƒë·∫°t ƒë·ªß 20 pet ho·∫∑c ƒë√¢y l√† pet cu·ªëi c√πng, ti·∫øn h√†nh b√°n
            if #petsToSell >= 20 then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "SellPet",
                            ["Pets"] = petsToSell
                        },
                        [2] = "\t"
                    }
                }
                remote:FireServer(unpack(args))
                print("ƒê√£ b√°n", #petsToSell, "pet v·ªõi rank ƒë√£ ch·ªçn")
                
                -- ƒê·ª£i m·ªôt kho·∫£ng th·ªùi gian ng·∫Øn ƒë·ªÉ tr√°nh spam
                task.wait(0.3)
                
                -- ƒê·∫∑t l·∫°i danh s√°ch
                petsToSell = {}
            end
        end
    end
    
    -- B√°n n·ªët nh·ªØng pet c√≤n l·∫°i (n·∫øu c√≥)
    if #petsToSell > 0 then
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "SellPet",
                    ["Pets"] = petsToSell
                },
                [2] = "\t"
            }
        }
        remote:FireServer(unpack(args))
        print("ƒê√£ b√°n", #petsToSell, "pet c√≤n l·∫°i v·ªõi rank ƒë√£ ch·ªçn")
    end
end

-- N√∫t ƒë·ªÉ b√°n ngay
Tabs.shop:AddButton({
    Title = "Sell Now",
    Description = "Sell all pets with selected ranks immediately",
    Callback = function()
        if #selectedRanks > 0 then
            sellPetsByRank()
        else
            Fluent:Notify({
                Title = "Ch∆∞a ch·ªçn rank",
                Content = "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt rank ƒë·ªÉ b√°n pet",
                Duration = 3
            })
        end
    end
})

-- Toggle ƒë·ªÉ b·∫≠t/t·∫Øt Auto Sell
Tabs.shop:AddToggle("AutoSellToggle", {
    Title = "Auto Sell Pets",
    Default = ConfigSystem.CurrentConfig.AutoSellEnabled or false,
    Callback = function(state)
        autoSellEnabled = state
        ConfigSystem.CurrentConfig.AutoSellEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            if #selectedRanks > 0 then
                Fluent:Notify({
                    Title = "Auto Sell ƒë√£ b·∫≠t",
                    Content = "S·∫Ω t·ª± ƒë·ªông b√°n pet v·ªõi c√°c rank: " .. table.concat(selectedRanks, ", "),
                    Duration = 3
                })
                
                task.spawn(function()
                    while autoSellEnabled do
                        sellPetsByRank()
                        task.wait(5) -- ƒê·ª£i 5 gi√¢y gi·ªØa m·ªói l·∫ßn ki·ªÉm tra v√† b√°n
                    end
                end)
            else
                Fluent:Notify({
                    Title = "Ch∆∞a ch·ªçn rank",
                    Content = "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt rank ƒë·ªÉ b√°n pet",
                    Duration = 3
                })
            end
        end
    end
})
-- ==========================
-- Fun√ß√µes auxiliares compartilhadas
-- ==========================
local function createDungeon()
    print("[DEBUG] Tentando criar dungeon...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    print("‚úî Dungeon criada.")
    task.wait(3)

    -- Iniciar a dungeon
    local iniciarArgs = {
        [1] = {
            [1] = {
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            },
            [2] = "\12"
        }
    }
    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(iniciarArgs))
    print("‚ñ∂ Dungeon iniciada.")
end

local function leaveDungeon()
    print("[AUTO-EXIT] Saindo da dungeon...")
    local args = {
        [1] = {
            [1] = { ["Event"] = "LeaveDungeon" },
            [2] = "\12"
        }
    }
    pcall(function()
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    end)
end

local function getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function getClosestEnemy()
    local enemiesFolder = workspace.__Main.__Enemies.Server
    local closestEnemy = nil
    local closestDistance = math.huge
    local player = game.Players.LocalPlayer
    local playerCharacter = player.Character

    if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") then 
        return nil 
    end
    local playerPosition = playerCharacter.HumanoidRootPart.Position

    for _, enemy in pairs(enemiesFolder:GetChildren()) do
        local hp = enemy:GetAttribute("HP")
        if hp and hp > 0 and enemy.Position then
            local distance = getDistance(playerPosition, enemy.Position)
            if distance < closestDistance then
                closestDistance = distance
                closestEnemy = enemy
            end
        end
    end

    return closestEnemy
end

local function moveToEnemy(enemy, currentTween)
    local tweenService = game:GetService("TweenService")
    local player = game.Players.LocalPlayer
    local playerCharacter = player.Character
    if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") or not enemy.Position then
        return false, currentTween
    end

    if currentTween then
        currentTween:Cancel()
    end

    playerCharacter.PrimaryPart = playerCharacter.HumanoidRootPart
    playerCharacter.HumanoidRootPart.Anchored = false

    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    currentTween = tweenService:Create(playerCharacter.PrimaryPart, tweenInfo, {CFrame = enemy.CFrame})

    currentTween:Play()

    task.spawn(function()
        currentTween.Completed:Wait()
        currentTween = nil
    end)

    return true, currentTween
end

-- ==========================
-- SISTEMA 1: Auto Farm Dungeon INF
-- ==========================
ConfigSystem.DefaultConfig.AutoFarmDungeonINF = ConfigSystem.DefaultConfig.AutoFarmDungeonINF or false
ConfigSystem.CurrentConfig.AutoFarmDungeonINF = ConfigSystem.CurrentConfig.AutoFarmDungeonINF or ConfigSystem.DefaultConfig.AutoFarmDungeonINF

-- Vari√°veis espec√≠ficas do sistema INF
local teleportINFEnabled = ConfigSystem.CurrentConfig.AutoFarmDungeonINF
local currentTweenINF = nil
local lastEnemyCheckINF = tick()
local maxTimeWithoutEnemiesINF = 5

local function monitorEnemiesINF()
    print("[AUTO-FARM INF] Iniciando auto farm (sair da dungeon ap√≥s 5s sem mobs).")

    while teleportINFEnabled do
        pcall(function()
            -- ‚è∞ Checa hor√°rio do Castle Infernal
            local hora = os.date("*t")
            local minuto = hora.min

            if (minuto >= 15 and minuto < 30) or (minuto >= 45 and minuto < 55) then
                leaveDungeon()
                print(string.format("[AUTO-EXIT INF] Saiu da dungeon √†s %02d:%02d (hor√°rio Castle)", hora.hour, hora.min))
                task.wait(60) -- espera 1 min antes de verificar de novo
            else
                if not workspace:FindFirstChild("__Main") then
                    -- n√£o est√° dentro da dungeon -> cria e inicia
                    createDungeon()
                    task.wait(5)
                else
                    local closestEnemy = getClosestEnemy()
                    local currentTime = tick()

                    if closestEnemy then
                        lastEnemyCheckINF = currentTime
                        print("[AUTO-FARM INF] Movendo para inimigo:", closestEnemy.Name)

                        local success
                        success, currentTweenINF = moveToEnemy(closestEnemy, currentTweenINF)
                        
                        if success then
                            local attempts = 0
                            while teleportINFEnabled 
                                  and closestEnemy.Parent 
                                  and closestEnemy:GetAttribute("HP") 
                                  and closestEnemy:GetAttribute("HP") > 0 
                                  and attempts < 100 do
                                task.wait(0.1)
                                attempts += 1
                            end
                            print("[AUTO-FARM INF] Inimigo eliminado!")
                        end
                    else
                        local timeWithoutEnemies = currentTime - lastEnemyCheckINF
                        if timeWithoutEnemies >= maxTimeWithoutEnemiesINF then
                            print("[AUTO-EXIT INF] Nenhum inimigo encontrado em 5s. Saindo da dungeon...")
                            leaveDungeon()
                            task.wait(10) -- espera 10s fora antes de tentar recriar
                        else
                            task.wait(1)
                        end
                    end
                end
            end
        end)

        task.wait(0.1)
    end

    if currentTweenINF then
        currentTweenINF:Cancel()
        currentTweenINF = nil
    end
    print("[AUTO-FARM INF] Auto farm desativado.")
end

-- ==========================
-- SISTEMA 2: Auto Farm Dungeon (Recria√ß√£o)
-- ==========================
ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate = ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate or false
ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate or ConfigSystem.DefaultConfig.AutoFarmDungeonRecreate

-- Vari√°veis espec√≠ficas do sistema Recreate
local teleportRecreateEnabled = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate
local currentTweenRecreate = nil
local lastEnemyCheckRecreate = tick()
local maxTimeWithoutEnemiesRecreate = 5

local function recreateDungeon()
    print("[AUTO-RECREATE] Sem inimigos por muito tempo. Recriando dungeon...")

    if currentTweenRecreate then
        currentTweenRecreate:Cancel()
        currentTweenRecreate = nil
    end

    createDungeon()
    lastEnemyCheckRecreate = tick()
    task.wait(5)
end

local function monitorEnemiesRecreate()
    print("[AUTO-FARM RECREATE] Iniciando auto farm com recria√ß√£o autom√°tica (5s sem mobs).")

    while teleportRecreateEnabled do
        pcall(function()
            -- ‚è∞ Checa hor√°rio
            local hora = os.date("*t")
            local minuto = hora.min

            if (minuto >= 15 and minuto < 30) or (minuto >= 45 and minuto < 55) then
                leaveDungeon()
                print(string.format("[AUTO-EXIT RECREATE] Saiu da dungeon √†s %02d:%02d (hor√°rio bloqueado)", hora.hour, hora.min))
                task.wait(60)
            else
                if not workspace:FindFirstChild("__Main") then
                    createDungeon()
                    task.wait(5)
                end

                local closestEnemy = getClosestEnemy()
                local currentTime = tick()

                if closestEnemy then
                    lastEnemyCheckRecreate = currentTime
                    print("[AUTO-FARM RECREATE] Movendo para inimigo:", closestEnemy.Name)

                    local success
                    success, currentTweenRecreate = moveToEnemy(closestEnemy, currentTweenRecreate)
                    
                    if success then
                        local attempts = 0
                        while teleportRecreateEnabled 
                              and closestEnemy.Parent 
                              and closestEnemy:GetAttribute("HP") 
                              and closestEnemy:GetAttribute("HP") > 0 
                              and attempts < 100 do
                            task.wait(0.1)
                            attempts += 1
                        end
                        print("[AUTO-FARM RECREATE] Inimigo eliminado!")
                    end
                else
                    local timeWithoutEnemies = currentTime - lastEnemyCheckRecreate
                    if timeWithoutEnemies >= maxTimeWithoutEnemiesRecreate then
                        recreateDungeon()
                    else
                        local remainingTime = maxTimeWithoutEnemiesRecreate - timeWithoutEnemies
                        if math.floor(remainingTime) % 5 == 0 then
                            print(string.format("[AUTO-FARM RECREATE] Sem inimigos h√° %.1fs. Recriando em %.1fs...", 
                                timeWithoutEnemies, remainingTime))
                        end
                    end
                    task.wait(1)
                end
            end
        end)

        task.wait(0.1)
    end

    if currentTweenRecreate then
        currentTweenRecreate:Cancel()
        currentTweenRecreate = nil
    end
    print("[AUTO-FARM RECREATE] Auto farm desativado.")
end

-- ==========================
-- Toggles separados
-- ==========================

-- Toggle para Dungeon INF
Tabs.dungeon:AddToggle("DungeonINF", {
    Title = "Dungeon INF",
    Default = ConfigSystem.CurrentConfig.AutoFarmDungeonINF,
    Flag = "AutoFarmDungeonINF",
    Callback = function(state)
        teleportINFEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmDungeonINF = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(monitorEnemiesINF)
        else
            if currentTweenINF then
                currentTweenINF:Cancel()
                currentTweenINF = nil
            end
            print("[AUTO-FARM INF] Desativado pelo usu√°rio.")
        end
    end
})

-- Toggle para Auto Farm Dungeon (com recria√ß√£o)
Tabs.dungeon:AddToggle("AutoFarmDungeon", {
    Title = "Auto Farm Dungeon",
    Default = ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate,
    Flag = "AutoFarmDungeonRecreate",
    Callback = function(state)
        teleportRecreateEnabled = state
        ConfigSystem.CurrentConfig.AutoFarmDungeonRecreate = state
        ConfigSystem.SaveConfig()

        if state then
            task.spawn(monitorEnemiesRecreate)
        else
            if currentTweenRecreate then
                currentTweenRecreate:Cancel()
                currentTweenRecreate = nil
            end
            print("[AUTO-FARM RECREATE] Desativado pelo usu√°rio.")
        end
    end
})


-- ==========================
-- Auto Castle Sistema Modificado e Corrigido (com Sistema de Velocidade)
-- ==========================

local castleEnabled = false
local castleInfEnabled = false
local castleCreateOnlyEnabled = false
local castleSessionActive = false
local castleSpeedEnabled = false
local castleSpeedLevel = 1

-- =======================
-- CONFIGS COM SALVAMENTO AUTOM√ÅTICO
-- =======================

-- Andar de entrada (padr√£o 125)
if ConfigSystem.DefaultConfig.CastleEntryFloor == nil then
    ConfigSystem.DefaultConfig.CastleEntryFloor = 125
end
if ConfigSystem.CurrentConfig.CastleEntryFloor == nil then
    ConfigSystem.CurrentConfig.CastleEntryFloor = ConfigSystem.DefaultConfig.CastleEntryFloor
end
local entryFloor = ConfigSystem.CurrentConfig.CastleEntryFloor

-- Andar de reset (padr√£o 200)
if ConfigSystem.DefaultConfig.CastleResetFloor == nil then
    ConfigSystem.DefaultConfig.CastleResetFloor = 200
end
if ConfigSystem.CurrentConfig.CastleResetFloor == nil then
    ConfigSystem.CurrentConfig.CastleResetFloor = ConfigSystem.DefaultConfig.CastleResetFloor
end
local resetFloor = ConfigSystem.CurrentConfig.CastleResetFloor

-- Toggles padr√£o
if ConfigSystem.DefaultConfig.CastleInfToggle == nil then
    ConfigSystem.DefaultConfig.CastleInfToggle = false
end
if ConfigSystem.CurrentConfig.CastleInfToggle == nil then
    ConfigSystem.CurrentConfig.CastleInfToggle = ConfigSystem.DefaultConfig.CastleInfToggle
end

if ConfigSystem.DefaultConfig.CastleToggle == nil then
    ConfigSystem.DefaultConfig.CastleToggle = false
end
if ConfigSystem.CurrentConfig.CastleToggle == nil then
    ConfigSystem.CurrentConfig.CastleToggle = ConfigSystem.DefaultConfig.CastleToggle
end

if ConfigSystem.DefaultConfig.CastleCreateOnlyToggle == nil then
    ConfigSystem.DefaultConfig.CastleCreateOnlyToggle = false
end
if ConfigSystem.CurrentConfig.CastleCreateOnlyToggle == nil then
    ConfigSystem.CurrentConfig.CastleCreateOnlyToggle = ConfigSystem.DefaultConfig.CastleCreateOnlyToggle
end

-- Velocidade (novo)
if ConfigSystem.DefaultConfig.CastleSpeedEnabled == nil then
    ConfigSystem.DefaultConfig.CastleSpeedEnabled = false
end
if ConfigSystem.CurrentConfig.CastleSpeedEnabled == nil then
    ConfigSystem.CurrentConfig.CastleSpeedEnabled = ConfigSystem.DefaultConfig.CastleSpeedEnabled
end

if ConfigSystem.DefaultConfig.CastleSpeedLevel == nil then
    ConfigSystem.DefaultConfig.CastleSpeedLevel = 1
end
if ConfigSystem.CurrentConfig.CastleSpeedLevel == nil then
    ConfigSystem.CurrentConfig.CastleSpeedLevel = ConfigSystem.DefaultConfig.CastleSpeedLevel
end

castleSpeedEnabled = ConfigSystem.CurrentConfig.CastleSpeedEnabled
castleSpeedLevel = ConfigSystem.CurrentConfig.CastleSpeedLevel

-- ==========================
-- INPUTS DE CONFIGURA√á√ÉO
-- ==========================

Tabs.dungeon:AddInput("CastleEntryFloor", {
    Title = "Castle Entry Floor",
    Default = tostring(entryFloor),
    Placeholder = "Andar de entrada (ex: 125)",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            entryFloor = floor
            ConfigSystem.CurrentConfig.CastleEntryFloor = floor
            ConfigSystem.SaveConfig()
            warn("[Castle] Andar de entrada atualizado para:", floor)
        end
    end
})

Tabs.dungeon:AddInput("CastleResetFloor", {
    Title = "Castle Reset Detection Floor",
    Default = tostring(resetFloor),
    Placeholder = "Andar para detectar e resetar (ex: 200)",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor > 0 then
            resetFloor = floor
            ConfigSystem.CurrentConfig.CastleResetFloor = floor
            ConfigSystem.SaveConfig()
            warn("[Castle] Andar de reset atualizado para:", floor)
        end
    end
})

-- ==========================
-- FUN√á√ïES CASTLE B√ÅSICAS
-- ==========================

local function getCurrentCastleFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    local current = nil
    for i = 1, 300 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end

    if current then
        warn("[Castle] Andar atual detectado:", current)
    else
        warn("[Castle] Fora do castelo (nenhuma Room encontrada).")
    end
    return current
end

local function buyCastleTicket()
    warn("[Castle] Comprando ticket com Gems...")
    local args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "CastleAction",
                ["Action"] = "BuyTicket"
            },
            [2] = "\13"
        }
    }
    pcall(function() 
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args)) 
    end)
end

local function joinCastle(floor)
    floor = floor or entryFloor
    warn("[Castle] Entrando no andar " .. tostring(floor) .. "...")
    local joinArgs = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(floor),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\13"
        }
    }
    pcall(function() 
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(joinArgs)) 
    end)
end

local function createCastle()
    warn("[Auto Castle] Criando castelo...")
    local args = {
        [1] = {
            [1] = {
                ["Event"] = "CastleAction",
                ["Action"] = "Create"
            },
            [2] = "\13"
        }
    }
    pcall(function() 
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args)) 
    end)
    task.wait(3)
end

-- ==========================
-- VELOCIDADE DO CASTLE (NOVO)
-- ==========================

local function applyCastleSpeed(level)
    level = tonumber(level) or 1
    local args = {
        [1] = {
            [1] = {
                ["Speed"] = level,
                ["Event"] = "CastleAction",
                ["Action"] = "SpeedUp"
            },
            [2] = "\13"
        }
    }
    pcall(function()
        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    end)
    warn("[Castle Speed] Velocidade ajustada para: x" .. tostring(level))
end

local function castleSpeedLoop()
    task.spawn(function()
        warn("[Castle Speed] Loop iniciado!")
        while castleSpeedEnabled do
            applyCastleSpeed(castleSpeedLevel)
            task.wait(10)
        end
        warn("[Castle Speed] Loop encerrado.")
    end)
end

-- ==========================
-- CASTLE INF - FARM E PORTAL
-- ==========================

local function findFirePortal()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil, nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil, nil end
    
    for i = 1, 300 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local portal = room:FindFirstChild("FirePortal")
            if portal then
                return portal, i
            end
        end
    end
    return nil, nil
end

local function teleportToFirePortal()
    local portal, currentFloor = findFirePortal()
    if not portal then 
        warn("[Castle INF] FirePortal n√£o encontrado!")
        return false 
    end
    
    local player = game.Players.LocalPlayer
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return false end
    
    local hrp = char.HumanoidRootPart
    hrp.CFrame = portal.CFrame * CFrame.new(0, 2, -2)
    hrp.Velocity = Vector3.new(0, 0, 0)
    
    warn("[Castle INF] Teleportado para portal do andar " .. currentFloor)
    return true, currentFloor
end

local function activateFirePortal()
    local portal, currentFloor = findFirePortal()
    if not portal then return false end
    
    local prompt = portal:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        for _, obj in ipairs(portal:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                prompt = obj
                break
            end
        end
    end
    
    if not prompt and portal.Parent then
        prompt = portal.Parent:FindFirstChildOfClass("ProximityPrompt")
    end
    
    if prompt then
        for _ = 1, 3 do
            pcall(function() fireproximityprompt(prompt) end)
            task.wait(0.1)
        end
        warn("[Castle INF] Portal ativado! Subindo do andar " .. currentFloor)
        return true
    end
    return false
end

local function farmCastleMobs()
    local mobsKilled = false
    local enemiesFolder = workspace:FindFirstChild("__Main")
    
    if enemiesFolder then
        enemiesFolder = enemiesFolder:FindFirstChild("__Enemies")
        if enemiesFolder then
            enemiesFolder = enemiesFolder:FindFirstChild("Server")
        end
    end
    
    if enemiesFolder then
        for _, mob in pairs(enemiesFolder:GetChildren()) do
            if not castleInfEnabled then break end
            
            local hp = mob:GetAttribute("HP")
            if hp and hp > 0 and mob.Position then
                local player = game.Players.LocalPlayer
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = mob.CFrame * CFrame.new(0, 3, 0)
                    pcall(function()
                        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer({
                            {
                                ["PetPos"] = {},
                                ["AttackType"] = "All", 
                                ["Event"] = "Attack",
                                ["Enemy"] = mob.Name
                            },
                            "\7"
                        })
                    end)
                    warn("[Castle INF] Atacando mob:", mob.Name)
                    while castleInfEnabled and mob.Parent do
                        local currentHP = mob:GetAttribute("HP")
                        if not currentHP or currentHP <= 0 then
                            warn("[Castle INF] Mob eliminado:", mob.Name)
                            break
                        end
                        task.wait(0.2)
                    end
                    mobsKilled = true
                end
            end
        end
    end
    
    return mobsKilled
end

local function castleInfLoop()
    task.spawn(function()
        warn("[Castle INF] Loop iniciado!")
        while castleInfEnabled do
            local foundMobs = farmCastleMobs()
            if not foundMobs then
                local success = teleportToFirePortal()
                if success then
                    task.wait(1)
                    activateFirePortal()
                    task.wait(2)
                end
            end
            task.wait(0.5)
        end
        warn("[Castle INF] Loop encerrado.")
    end)
end

-- ==========================
-- AUTO CASTLE PRINCIPAL
-- ==========================

local function autoCastleLoop()
    task.spawn(function()
        warn("[Auto Castle] Loop iniciado!")
        while castleEnabled do
            local currentFloor = getCurrentCastleFloor()

            if not currentFloor then
                createCastle()
                task.wait(1)
                buyCastleTicket()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            else
                if currentFloor >= resetFloor then
                    warn("[Auto Castle] Detectou andar " .. currentFloor .. " ‚Üí Recriando...")
                    createCastle()
                    task.wait(1)
                    buyCastleTicket()
                    task.wait(1)
                    joinCastle(entryFloor)
                    Fluent:Notify({
                        Title = "Castle Recreated",
                        Content = "Andar " .. tostring(currentFloor) .. " - recriado.",
                        Duration = 4
                    })
                    task.wait(5)
                else
                    farmCastleMobs()
                    task.wait(1)
                end
            end
            task.wait(0.5)
        end
        warn("[Auto Castle] Loop encerrado.")
    end)
end

local function castleCreateOnlyLoop()
    task.spawn(function()
        warn("[Auto Castelo] Loop iniciado (sem reset)!")
        while castleCreateOnlyEnabled do
            local currentFloor = getCurrentCastleFloor()

            if not currentFloor then
                createCastle()
                task.wait(1)
                buyCastleTicket()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
                Fluent:Notify({
                    Title = "Auto Castelo",
                    Content = "Castelo criado no andar " .. tostring(entryFloor),
                    Duration = 3
                })
            else
                task.wait(2)
            end

            task.wait(0.5)
        end
        warn("[Auto Castelo] Loop encerrado.")
    end)
end

-- ==========================
-- TOGGLES E INTERFACE
-- ==========================

Tabs.dungeon:AddDropdown("CastleSpeedLevel", {
    Title = "Velocidade do Castle",
    Values = { "1", "2", "3", "4" },
    Default = tostring(castleSpeedLevel),
    Multi = false,
    Callback = function(selected)
        local level = tonumber(selected)
        if level and level >= 1 and level <= 4 then
            castleSpeedLevel = level
            ConfigSystem.CurrentConfig.CastleSpeedLevel = level
            ConfigSystem.SaveConfig()
            Fluent:Notify({
                Title = "Velocidade Atualizada",
                Content = "Nova velocidade: x" .. tostring(level),
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddToggle("CastleSpeedToggle", {
    Title = "Ativar Velocidade (x1‚Äìx4)",
    Description = "Aplica automaticamente a velocidade escolhida",
    Default = ConfigSystem.CurrentConfig.CastleSpeedEnabled or false,
    Callback = function(state)
        castleSpeedEnabled = state
        ConfigSystem.CurrentConfig.CastleSpeedEnabled = state
        ConfigSystem.SaveConfig()
        
        if state then
            Fluent:Notify({
                Title = "Velocidade Ativada",
                Content = "Usando velocidade x" .. tostring(castleSpeedLevel),
                Duration = 3
            })
            castleSpeedLoop()
        else
            Fluent:Notify({
                Title = "Velocidade Desativada",
                Content = "Parou de aplicar velocidade",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddToggle("CastleINF", {
    Title = "Castle INF (Farm + Portal)",
    Default = ConfigSystem.CurrentConfig.CastleInfToggle or false,
    Callback = function(state)
        castleInfEnabled = state
        ConfigSystem.CurrentConfig.CastleInfToggle = state
        ConfigSystem.SaveConfig()
        
        if state then
            Fluent:Notify({Title="Castle INF Ativado",Content="Farm e subida autom√°ticos",Duration=3})
            castleInfLoop()
        else
            Fluent:Notify({Title="Castle INF Desativado",Content="Farm parado",Duration=3})
        end
    end
})

Tabs.dungeon:AddToggle("AutoCastle", {
    Title = "Auto Castle (Create + Recreate)",
    Default = ConfigSystem.CurrentConfig.CastleToggle or false,
    Callback = function(state)
        castleEnabled = state
        ConfigSystem.CurrentConfig.CastleToggle = state
        ConfigSystem.SaveConfig()

        if state then
            Fluent:Notify({
                Title = "Auto Castle Ativado",
                Content = "Criando e gerenciando castelo...",
                Duration = 5
            })
            createCastle()
            task.wait(1)
            buyCastleTicket()
            task.wait(1)
            joinCastle(entryFloor)
            task.wait(2)
            castleSessionActive = true
            autoCastleLoop()
        else
            castleSessionActive = false
            Fluent:Notify({
                Title = "Auto Castle Desativado",
                Content = "Sistema parado",
                Duration = 3
            })
        end
    end
})

Tabs.dungeon:AddToggle("AutoCasteloOnly", {
    Title = "Auto Castelo (Criar Apenas)",
    Description = "Cria e entra automaticamente quando fora do castelo (sem reset)",
    Default = ConfigSystem.CurrentConfig.CastleCreateOnlyToggle or false,
    Callback = function(state)
        castleCreateOnlyEnabled = state
        ConfigSystem.CurrentConfig.CastleCreateOnlyToggle = state
        ConfigSystem.SaveConfig()
        
        if state then
            Fluent:Notify({
                Title = "Auto Castelo Ativado",
                Content = "Criar√° castelo e entrar√° automaticamente",
                Duration = 4
            })
            castleCreateOnlyLoop()
        else
            Fluent:Notify({
                Title = "Auto Castelo Desativado",
                Content = "Cria√ß√£o autom√°tica parada",
                Duration = 3
            })
        end
    end
})

-- ==========================
-- AUTO-BOOT (Reativa configs)
-- ==========================

if ConfigSystem.CurrentConfig.CastleInfToggle then
    castleInfEnabled = true
    castleInfLoop()
    warn("[Auto-Boot] Castle INF reativado")
end

if ConfigSystem.CurrentConfig.CastleToggle then
    castleEnabled = true
    createCastle()
    task.wait(1)
    buyCastleTicket()
    task.wait(1)
    joinCastle(entryFloor)
    task.wait(2)
    castleSessionActive = true
    autoCastleLoop()
    warn("[Auto-Boot] Auto Castle reativado")
end

if ConfigSystem.CurrentConfig.CastleCreateOnlyToggle then
    castleCreateOnlyEnabled = true
    castleCreateOnlyLoop()
    warn("[Auto-Boot] Auto Castelo reativado")
end

if ConfigSystem.CurrentConfig.CastleSpeedEnabled then
    castleSpeedEnabled = true
    castleSpeedLoop()
    warn("[Auto-Boot] Castle Speed reativado com velocidade x" .. tostring(castleSpeedLevel))
end

warn("[Castle System] Sistema carregado")



-- ==========================
-- Configura√ß√£o inicial
-- ==========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
local player = game.Players.LocalPlayer

-- Config defaults
if ConfigSystem.DefaultConfig.DesertInfiniteToggle == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteToggle = false
end
if ConfigSystem.DefaultConfig.DesertInfiniteSpeed == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteSpeed = 2
end
if ConfigSystem.DefaultConfig.DesertAutoSpeed == nil then
    ConfigSystem.DefaultConfig.DesertAutoSpeed = false
end
if ConfigSystem.DefaultConfig.DesertInfiniteTeleport == nil then
    ConfigSystem.DefaultConfig.DesertInfiniteTeleport = false
end
if ConfigSystem.DefaultConfig.DesertDungeonMode == nil then
    ConfigSystem.DefaultConfig.DesertDungeonMode = 1 -- 1 = Deserto, 2 = Castelo
end

-- Current config fallback
if ConfigSystem.CurrentConfig.DesertInfiniteToggle == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteToggle = ConfigSystem.DefaultConfig.DesertInfiniteToggle
end
if ConfigSystem.CurrentConfig.DesertInfiniteSpeed == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteSpeed = ConfigSystem.DefaultConfig.DesertInfiniteSpeed
end
if ConfigSystem.CurrentConfig.DesertAutoSpeed == nil then
    ConfigSystem.CurrentConfig.DesertAutoSpeed = ConfigSystem.DefaultConfig.DesertAutoSpeed
end
if ConfigSystem.CurrentConfig.DesertInfiniteTeleport == nil then
    ConfigSystem.CurrentConfig.DesertInfiniteTeleport = ConfigSystem.DefaultConfig.DesertInfiniteTeleport
end
if ConfigSystem.CurrentConfig.DesertDungeonMode == nil then
    ConfigSystem.CurrentConfig.DesertDungeonMode = ConfigSystem.DefaultConfig.DesertDungeonMode
end

-- Variables
local desertEnabled = ConfigSystem.CurrentConfig.DesertInfiniteToggle
local speedValue = ConfigSystem.CurrentConfig.DesertInfiniteSpeed
local autoSpeedEnabled = ConfigSystem.CurrentConfig.DesertAutoSpeed
local teleportEnabled = ConfigSystem.CurrentConfig.DesertInfiniteTeleport
local dungeonMode = ConfigSystem.CurrentConfig.DesertDungeonMode
local DUNGEON_ID = 5116548088
local desertSessionActive = false
local autoSpeedLoop = false

-- ==========================
-- FUN√á√ïES DE DETEC√á√ÉO
-- ==========================
local function estaNoMundoInfinito()
    local main = workspace:FindFirstChild("__Main")
    if main then
        local world = main:FindFirstChild("__World")
        if world then
            if world.Name == "InfiniteDesert" or world.Name == "DesertInfinite" then
                return true, "desert"
            end
            if world.Name == "InfiniteCastle" or world.Name == "CastleInfinite" then
                return true, "castle"
            end
        end
    end

    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local position = player.Character.HumanoidRootPart.Position
        local altitude = position.Y
        if altitude > 4000 then
            return true, "unknown"
        end
    end

    local playerGui = player:FindFirstChild("PlayerGui")
    if playerGui then
        for _, gui in pairs(playerGui:GetChildren()) do
            if gui.Name:find("Infinite") or gui.Name:find("Desert") or gui.Name:find("Castle") then
                return true, "gui"
            end
        end
    end

    return false, nil
end

local function estaNoDeserto()
    local emMundoInfinito, _ = estaNoMundoInfinito()
    return emMundoInfinito
end

-- ==========================
-- TELEPORT DIN√ÇMICO CORRIGIDO
-- ==========================
local desertCenter = Vector3.new(474.10, 4383.76, -1875.94)
local castleCenter = Vector3.new(446.69, 4384.64, -1897.36)

local function getTeleportPosition()
    local emMundo, tipo = estaNoMundoInfinito()

    if emMundo then
        if tipo == "desert" then
            return CFrame.new(desertCenter)
        elseif tipo == "castle" then
            return CFrame.new(castleCenter)
        end
    end

    -- fallback baseado no modo configurado
    if dungeonMode == 2 then
        return CFrame.new(castleCenter)
    else
        return CFrame.new(desertCenter)
    end
end

local function manterTeleport()
    task.spawn(function()
        while teleportEnabled do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local targetCFrame = getTeleportPosition()
                player.Character.HumanoidRootPart.CFrame = targetCFrame

                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = true
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                    player.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                    player.Character.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
                end
            end
            task.wait(0.1)
        end

        if player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            humanoid.PlatformStand = false
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

-- ==========================
-- VELOCIDADE
-- ==========================
local function aplicarVelocidade(valor)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
        return 
    end

    local noMundo, tipo = estaNoMundoInfinito()
    if not noMundo then return end

    local speedEvent = "InfiniteModeAction"
    if tipo == "castle" or dungeonMode == 2 then
        speedEvent = "InfiniteCastleAction"
    end

    local argsSpeed = {
        [1] = {
            [1] = {
                ["Speed"] = valor,
                ["Event"] = speedEvent,
                ["Action"] = "SpeedUp"
            },
            [2] = "\13"
        }
    }

    if remote then 
        remote:FireServer(unpack(argsSpeed))
    end
end

local function iniciarAutoVelocidade()
    if autoSpeedLoop then return end
    autoSpeedLoop = true
    task.spawn(function()
        while autoSpeedEnabled and autoSpeedLoop do
            if estaNoDeserto() then
                aplicarVelocidade(speedValue)
            end
            task.wait(10)
        end
        autoSpeedLoop = false
    end)
end

local function pararAutoVelocidade()
    autoSpeedEnabled = false
    autoSpeedLoop = false
end

-- ==========================
-- SESS√ÉO / CONTROLE
-- ==========================
local function monitorarSaidaDeserto()
    task.spawn(function()
        local tentativasConsecutivas = 0
        local maxTentativas = 3
        while desertSessionActive do
            local emMundoInfinito, _ = estaNoMundoInfinito()
            if not emMundoInfinito then
                tentativasConsecutivas += 1
                if tentativasConsecutivas >= maxTentativas then
                    desertSessionActive = false
                    pararAutoVelocidade()
                    break
                end
            else
                tentativasConsecutivas = 0
            end
            task.wait(3)
        end
    end)
end

local function resetarEstadoSessao()
    desertSessionActive = false
    pararAutoVelocidade()
end

local function iniciarDesertoInfinito()
    if desertSessionActive then return end

    local jaEsta, _ = estaNoMundoInfinito()
    if jaEsta then
        desertSessionActive = true
        aplicarVelocidade(speedValue)
        if autoSpeedEnabled then iniciarAutoVelocidade() end
        monitorarSaidaDeserto()
        return
    end

    desertSessionActive = true
    task.spawn(function()
        local eventName = (dungeonMode == 1) and "InfiniteModeAction" or "InfiniteCastleAction"

        local argsCreate = {
            [1] = {
                [1] = {
                    ["Event"] = eventName,
                    ["Action"] = "Create"
                },
                [2] = "\13"
            }
        }
        if remote then remote:FireServer(unpack(argsCreate)) end
        task.wait(3)

        local startSuccess = false
        for tentativa = 1, 3 do
            local argsStart = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = DUNGEON_ID,
                        ["Event"] = eventName,
                        ["Action"] = "Start"
                    },
                    [2] = "\13"
                }
            }
            if remote then remote:FireServer(unpack(argsStart)) end
            task.wait(4)
            local aindaNoMundo, _ = estaNoMundoInfinito()
            if aindaNoMundo then
                startSuccess = true
                break
            end
        end

        if not startSuccess then
            resetarEstadoSessao()
            return
        end

        task.wait(2)
        aplicarVelocidade(speedValue)
        if autoSpeedEnabled then iniciarAutoVelocidade() end
        monitorarSaidaDeserto()
    end)
end

-- ==========================
-- GUI
-- ==========================
Tabs.desert:AddDropdown("DesertDungeonMode", {
    Title = "Selecionar Modo",
    Values = { "Deserto Infinito", "Castelo Infinito" },
    Default = (dungeonMode == 1 and "Deserto Infinito") or "Castelo Infinito",
    Callback = function(value)
        dungeonMode = (value == "Deserto Infinito") and 1 or 2
        ConfigSystem.CurrentConfig.DesertDungeonMode = dungeonMode
        ConfigSystem.SaveConfig()
    end
})

Tabs.desert:AddToggle("DesertInfiniteToggle", {
    Title = "Ativar Deserto/Castelo Infinito",
    Default = desertEnabled,
    Callback = function(state)
        desertEnabled = state
        ConfigSystem.CurrentConfig.DesertInfiniteToggle = state
        ConfigSystem.SaveConfig()
        if state then iniciarDesertoInfinito() else resetarEstadoSessao() end
    end
})

Tabs.desert:AddInput("DesertInfiniteSpeed", {
    Title = "Velocidade",
    Default = tostring(speedValue),
    Placeholder = "Ex: 2",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            speedValue = num
            ConfigSystem.CurrentConfig.DesertInfiniteSpeed = num
            ConfigSystem.SaveConfig()
            aplicarVelocidade(num)
        end
    end
})

Tabs.desert:AddToggle("DesertAutoSpeed", {
    Title = "Auto Velocidade",
    Default = autoSpeedEnabled,
    Callback = function(state)
        autoSpeedEnabled = state
        ConfigSystem.CurrentConfig.DesertAutoSpeed = state
        ConfigSystem.SaveConfig()
        if state then
            if estaNoDeserto() then iniciarAutoVelocidade() end
        else
            pararAutoVelocidade()
        end
    end
})

Tabs.desert:AddToggle("DesertInfiniteTeleport", {
    Title = "Teleportar para o meio (Deserto/Castelo)",
    Default = teleportEnabled,
    Callback = function(state)
        teleportEnabled = state
        ConfigSystem.CurrentConfig.DesertInfiniteTeleport = state
        ConfigSystem.SaveConfig()
        if state then manterTeleport() end
    end
})

Tabs.desert:AddButton({
    Title = "Resetar Estado",
    Callback = function() resetarEstadoSessao() end
})

Tabs.desert:AddButton({
    Title = "Verificar Status (Debug)",
    Callback = function()
        local emMundo, tipo = estaNoMundoInfinito()
        warn("=== DEBUG DESERTO INFINITO ===")
        warn("[DEBUG] Sess√£o ativa:", desertSessionActive)
        warn("[DEBUG] Modo configurado:", (dungeonMode == 1 and "Deserto") or "Castelo")
        warn("[DEBUG] Em mundo infinito:", emMundo)
        warn("[DEBUG] Tipo detectado:", tipo or "nenhum")
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local pos = player.Character.HumanoidRootPart.Position
            warn(string.format("[DEBUG] Posi√ß√£o: X=%.1f, Y=%.1f, Z=%.1f", pos.X, pos.Y, pos.Z))
        end
        local main = workspace:FindFirstChild("__Main")
        if main then
            local world = main:FindFirstChild("__World")
            if world then
                warn("[DEBUG] Nome do mundo atual:", world.Name)
            end
        end
        warn("==============================")
    end
})

-- ==========================
-- AUTO CLICK (usando atributo AutoClick) COM SALVAMENTO
-- ==========================

-- Config padr√£o
if ConfigSystem.DefaultConfig.AutoClick == nil then
    ConfigSystem.DefaultConfig.AutoClick = false
end

-- Config atual
if ConfigSystem.CurrentConfig.AutoClick == nil then
    ConfigSystem.CurrentConfig.AutoClick = ConfigSystem.DefaultConfig.AutoClick
end

-- Vari√°vel
local autoClickAtivo = ConfigSystem.CurrentConfig.AutoClick

local function atualizarAutoClick(state)
    autoClickAtivo = state
    ConfigSystem.CurrentConfig.AutoClick = state
    ConfigSystem.SaveConfig()
    local player = game.Players.LocalPlayer
    player:SetAttribute("AutoClick", state)
    warn("[AutoClick] Estado atualizado para:", state)
end

-- ==========================
-- BOT√ÉO NA TAB MAIN
-- ==========================

Tabs.Main:AddToggle("AutoClickToggle", {
    Title = "Auto Click",
    Default = autoClickAtivo,
    Callback = function(state)
        atualizarAutoClick(state)
    end
})

-- Se estava ativo antes de reiniciar, reativa sozinho
if autoClickAtivo then
    atualizarAutoClick(true)
end
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
end)

local function teleportInstant(targetCFrame)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = targetCFrame
    end
end

-- Bot√µes na aba tp
Tabs.tp:AddButton({
    Title = "Slayer",
    Description = "Teleportar para Slayer",
    Callback = function()
        teleportInstant(CFrame.new(-6178.12, 25.88, 1162.91))
    end
})

Tabs.tp:AddButton({
    Title = "Kaiju",
    Description = "Teleportar para Kaiju",
    Callback = function()
        teleportInstant(CFrame.new(4444.13, 20.69, 119.92))
    end
})

Tabs.tp:AddButton({
    Title = "Cursed",
    Description = "Teleportar para Cursed",
    Callback = function()
        teleportInstant(CFrame.new(561.72, 31.21, 4455.98))
    end
})

Tabs.tp:AddButton({
    Title = "Nen City",
    Description = "Teleportar para Nen City",
    Callback = function()
        teleportInstant(CFrame.new(-4781.73, 34.66, -2669.36))
    end
})

Tabs.tp:AddButton({
    Title = "Mage",
    Description = "Teleportar para Mage",
    Callback = function()
        teleportInstant(CFrame.new(-4546.13, 41.53, -7541.96))
    end
})

Tabs.tp:AddButton({
    Title = "Wall",
    Description = "Teleportar para Wall",
    Callback = function()
        teleportInstant(CFrame.new(-8374.79, 40.25, -1801.58))
    end
})

Tabs.tp:AddButton({
    Title = "Hunter",
    Description = "Teleportar para Hunter",
    Callback = function()
        teleportInstant(CFrame.new(-219.01, 24.17, -15.40))
    end
})

Tabs.tp:AddButton({
    Title = "Hurricane",
    Description = "Teleportar para Hurricane",
    Callback = function()
        teleportInstant(CFrame.new(-1290.84, 24.91, -4614.62))
    end
})

Tabs.tp:AddButton({
    Title = "Shield",
    Description = "Teleportar para Shield",
    Callback = function()
        teleportInstant(CFrame.new(2401.57, 31.00, -3764.92))
    end
})
Tabs.tp:AddButton({
    Title = "Solo City",
    Description = "Teleportar para Solo City",
    Callback = function()
        teleportInstant(CFrame.new(577.97, 28.43, 261.45))
    end
})

Tabs.tp:AddButton({
    Title = "Brum City",
    Description = "Teleportar para Brum City",
    Callback = function()
        teleportInstant(CFrame.new(-2851.11, 49.40, -2011.40))
    end
})

Tabs.tp:AddButton({
    Title = "Kidama City",
    Description = "Teleportar para Kidama City",
    Callback = function()
        teleportInstant(CFrame.new(-3345.23, 21.96, -101.47))
    end
})

Tabs.tp:AddButton({
    Title = "Dragon City",
    Description = "Teleportar para Dragon City",
    Callback = function()
        teleportInstant(CFrame.new(-2549.56, 27.20, 5857.11))
    end
})

Tabs.tp:AddButton({
    Title = "Faceheal Town",
    Description = "Teleportar para Faceheal Town",
    Callback = function()
        teleportInstant(CFrame.new(2629.01, 45.43, -2628.31))
    end
})

Tabs.tp:AddButton({
    Title = "Nipon City",
    Description = "Teleportar para Nipon City",
    Callback = function()
        teleportInstant(CFrame.new(214.68, 32.90, -4301.60))
    end
})

Tabs.tp:AddButton({
    Title = "Xz City",
    Description = "Teleportar para Xz City",
    Callback = function()
        teleportInstant(CFrame.new(3299.47, 25.39, 6342.19))
    end
})

Tabs.tp:AddButton({
    Title = "World Arena",
    Description = "Teleportar para World Arena",
    Callback = function()
        teleportInstant(CFrame.new(1650.90, 23.65, -66.51))
    end
})

Tabs.tp:AddButton({
    Title = "Lucky Kingdom",
    Description = "Teleportar para Lucky Kingdom",
    Callback = function()
        teleportInstant(CFrame.new(198.34, 38.71, 4296.11))
    end
})

Tabs.tp:AddButton({
    Title = "Mori Town",
    Description = "Teleportar para Mori Town",
    Callback = function()
        teleportInstant(CFrame.new(4816.31, 29.94, -120.23))
    end
})

Tabs.tp:AddButton({
    Title = "Grass Village",
    Description = "Teleportar para Grass Village",
    Callback = function()
        teleportInstant(CFrame.new(3986.01, 59.15, 3247.99))
    end
})

Tabs.tp:AddButton({
    Title = "Jeju Event",
    Description = "Teleportar para Jeju Event",
    Callback = function()
        teleportInstant(CFrame.new(3986.01, 59.15, 3247.99)) -- <<< substitui pela coordenada correta
    end
})
